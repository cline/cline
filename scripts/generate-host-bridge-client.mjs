#!/usr/bin/env node

import * as fs from "fs/promises"
import * as path from "path"
import * as grpc from "@grpc/grpc-js"
import * as protoLoader from "@grpc/proto-loader"
import chalk from "chalk"

const DESCRIPTOR_SET = path.resolve("dist-standalone/proto/descriptor_set.pb")

// Contains the interface definitions for the host bridge clients.
const TYPES_FILE = path.resolve("src/generated/hosts/host-bridge-client-types.ts")
// Contains the ExternalHostBridgeClientManager for the external host bridge clients (using nice-grpc).
const EXTERNAL_CLIENT_FILE = path.resolve("src/generated/hosts/standalone/host-bridge-clients.ts")
// Contains the handler map for the external host bridge clients (using the custom service registry).
const VSCODE_CLIENT_FILE = path.resolve("src/generated/hosts/vscode/hostbridge-grpc-service-config.ts")

const typeNameToFQN = new Map()

function addTypeNameToFqn(name, fqn) {
	if (typeNameToFQN.has(name)) {
		throw new Error(`Proto type ${name} redefined (${fqn}).`)
	}
	typeNameToFQN.set(name, fqn)
}
function getFqn(name) {
	if (!typeNameToFQN.has(name)) {
		throw Error(`No FQN for ${name}`)
	}
	return typeNameToFQN.get(name)
}
/**
 * Main function to generate the host bridge client
 */
async function main() {
	// Load service definitions from descriptor set
	const descriptorBuffer = await fs.readFile(DESCRIPTOR_SET)
	const packageDefinition = protoLoader.loadFileDescriptorSetFromBuffer(descriptorBuffer)
	const proto = grpc.loadPackageDefinition(packageDefinition)

	// Extract host services and proto messages from the proto definition
	const hostServices = {}
	for (const [name, def] of Object.entries(proto.host)) {
		if (def && "service" in def) {
			hostServices[name] = def
		} else {
			addTypeNameToFqn(name, `proto.host.${name}`)
		}
	}
	for (const [name, def] of Object.entries(proto.cline)) {
		if (def && !("service" in def)) {
			addTypeNameToFqn(name, `proto.cline.${name}`)
		}
	}

	await generateTypesFile(hostServices)
	await generateExternalClientFile(hostServices)
	await generateVscodeClientFile(hostServices)

	console.log(`Generated host bridge client files at:`)
	console.log(`- ${TYPES_FILE}`)
	console.log(`- ${EXTERNAL_CLIENT_FILE}`)
	console.log(`- ${VSCODE_CLIENT_FILE}`)
}

/**
 * Generate the client interfaces file.
 */
async function generateTypesFile(hostServices) {
	const clientInterfaces = []
	for (const [name, def] of Object.entries(hostServices)) {
		const clientInterface = generateClientInterfaceType(name, def)
		clientInterfaces.push(clientInterface)
	}
	const content = `// GENERATED CODE -- DO NOT EDIT!
// Generated by scripts/generate-host-bridge-client.mjs
import * as proto from "@shared/proto/index"
import { StreamingCallbacks } from "@hosts/host-provider-types"

${clientInterfaces.join("\n\n")}
`
	// Write output file
	await fs.mkdir(path.dirname(TYPES_FILE), { recursive: true })
	await fs.writeFile(TYPES_FILE, content)
}

/**
 * Generate a client interface for a service.
 */
function generateClientInterfaceType(serviceName, serviceDefinition) {
	// Get the methods from the service definition
	const methods = Object.entries(serviceDefinition.service)
		.map(([methodName, methodDef]) => {
			const requestType = getFqn(methodDef.requestType.type.name)
			const responseType = getFqn(methodDef.responseType.type.name)

			if (!methodDef.responseStream) {
				// Generate unary method signature.
				return `	${methodName}(request: ${requestType}): Promise<${responseType}>;`
			}
			// Generate streaming method signature.
			return `	${methodName}(request: ${requestType}, callbacks: StreamingCallbacks<${responseType}>): () => void;`
		})
		.join("\n\n")

	// Generate the interface
	return `/**
 * Interface for ${serviceName} client.
 */
export interface ${serviceName}ClientInterface {

${methods}
}`
}

/**
 * Generate the external client implementations file.
 */
async function generateExternalClientFile(hostServices) {
	// Generate imports
	const imports = []
	// Add imports for the interfaces
	for (const [name, _def] of Object.entries(hostServices)) {
		imports.push(`import { ${name}ClientInterface } from "@generated/hosts/host-bridge-client-types"`)
	}
	const clientImplementations = []
	for (const [name, def] of Object.entries(hostServices)) {
		clientImplementations.push(generateExternalClientSetup(name, def))
	}

	const content = `// GENERATED CODE -- DO NOT EDIT!
// Generated by scripts/generate-host-bridge-client.mjs
import { asyncIteratorToCallbacks } from "@/standalone/utils"
import * as niceGrpc from "@generated/nice-grpc/index"
import { StreamingCallbacks } from "@hosts/host-provider-types"
import * as proto from "@shared/proto/index"
import { Channel, createClient } from "nice-grpc"

${imports.join("\n")}

${clientImplementations.join("\n\n")}
`
	// Write output file
	await fs.mkdir(path.dirname(EXTERNAL_CLIENT_FILE), { recursive: true })
	await fs.writeFile(EXTERNAL_CLIENT_FILE, content)
}

/**
 * Generate a client implementation class for a service
 */
function generateExternalClientSetup(serviceName, serviceDefinition) {
	// Get the methods from the service definition
	const methods = Object.entries(serviceDefinition.service)
		.map(([methodName, methodDef]) => {
			// Get fully qualified type names
			const requestType = getFqn(methodDef.requestType.type.name)
			const responseType = getFqn(methodDef.responseType.type.name)
			const isStreamingResponse = methodDef.responseStream

			if (!isStreamingResponse) {
				return `  ${methodName}(request: ${requestType}): Promise<${responseType}> {
    return this.client.${methodName}(request)
  }`
			} else {
				// Generate streaming method
				return `  ${methodName}(request: ${requestType}, callbacks: StreamingCallbacks<${responseType}>): () => void {
	const abortController = new AbortController()
	const stream: AsyncIterable<${responseType}> = this.client.${methodName}(request, {signal: abortController.signal})
    asyncIteratorToCallbacks(stream, callbacks)
	return () => {abortController.abort()}
  }`
			}
		})
		.join("\n\n")

	// Generate the class
	return `/**
 * Type-safe client implementation for ${serviceName}.
 */
export class ${serviceName}ClientImpl implements ${serviceName}ClientInterface {
  private client: niceGrpc.host.${serviceName}Client 

  constructor(channel: Channel) {
    this.client = createClient(niceGrpc.host.${serviceName}Definition, channel)
  }

${methods}
}`
}

/**
 * Generate the Vscode client setup file.
 */
async function generateVscodeClientFile(hostServices) {
	const imports = []
	const clientImplementations = []
	const handlerMap = []
	for (const [serviceName, serviceDefinition] of Object.entries(hostServices)) {
		const name = serviceName.replace(/Service$/, "").toLowerCase()
		for (const [methodName, _methodDef] of Object.entries(serviceDefinition.service)) {
			imports.push(`import { ${methodName} } from "@/hosts/vscode/hostbridge/${name}/${methodName}"`)
		}
		imports.push("")

		clientImplementations.push(generateVscodeClientImplementation(name, serviceDefinition))

		handlerMap.push(`	"host.${serviceName}": {
		requestHandler: ${name}ServiceRegistry.handleRequest,
		streamingHandler: ${name}ServiceRegistry.handleStreamingRequest,
	},`)
	}

	const content = `// GENERATED CODE -- DO NOT EDIT!
// Generated by scripts/generate-host-bridge-client.mjs
import { createServiceRegistry } from "@hosts/vscode/hostbridge-grpc-service"
import { HostServiceHandlerConfig } from "@hosts/vscode/hostbridge-grpc-handler"

${imports.join("\n")}
${clientImplementations.join("\n\n")}

/**
 * Map of host service names to their handler configurations
 */
export const hostServiceHandlers: Record<string, HostServiceHandlerConfig> = {
${handlerMap.join("\n")}
}
`

	// Write output file
	await fs.mkdir(path.dirname(VSCODE_CLIENT_FILE), { recursive: true })
	await fs.writeFile(VSCODE_CLIENT_FILE, content)
}

function generateVscodeClientImplementation(serviceName, serviceDefinition) {
	// Get the methods from the service definition
	const name = serviceName.replace(/Service$/, "").toLowerCase()

	const methods = Object.entries(serviceDefinition.service)
		.map(([methodName, methodDef]) => {
			// Get fully qualified type names
			const isStreamingResponse = methodDef.responseStream
			if (!isStreamingResponse) {
				return `${name}ServiceRegistry.registerMethod("${methodName}", ${methodName})`
			} else {
				return `${name}ServiceRegistry.registerMethod("${methodName}", ${methodName}, { isStreaming: true })`
			}
		})
		.join("\n")

	// Generate the class
	return `// Setup ${name} service registry
const ${name}ServiceRegistry = createServiceRegistry("${name}")
${methods}`
}

// Run the main function
main().catch((error) => {
	console.error(chalk.red("Error:"), error)
	process.exit(1)
})
