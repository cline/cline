name: Daily Issues Digest to Slack

on:
  schedule:
    # Runs once daily at 9:00 AM UTC (6:00 AM Argentina time)
    # To change frequency: https://crontab.guru/
    # Examples:
    #   "0 9 * * *"     = 9am UTC daily
    #   "0 9,17 * * *"  = 9am and 5pm UTC daily
    #   "0 */5 * * *"   = every 5 hours
    - cron: '0 9 * * *'
  
  # Allow manual trigger for testing
  workflow_dispatch:
    inputs:
      hours_lookback:
        description: 'Hours to look back for issues (default: 24)'
        required: false
        default: '24'

permissions:
  contents: read
  issues: read

env:
  # Default lookback period in hours
  HOURS_LOOKBACK: ${{ github.event.inputs.hours_lookback || '24' }}

jobs:
  digest:
    runs-on: ubuntu-latest
    steps:
      - name: Calculate time range
        id: time
        run: |
          # Calculate the timestamp for N hours ago in ISO 8601 format
          SINCE=$(date -u -d "${{ env.HOURS_LOOKBACK }} hours ago" +%Y-%m-%dT%H:%M:%SZ)
          echo "since=$SINCE" >> $GITHUB_OUTPUT
          echo "Looking back ${{ env.HOURS_LOOKBACK }} hours (since $SINCE)"

      - name: Fetch new and reopened issues
        id: issues
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SINCE="${{ steps.time.outputs.since }}"
          
          # Fetch issues updated since the lookback time
          # Filter out pull requests (they show up in issues API)
          ISSUES_JSON=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/issues?state=all&since=$SINCE&per_page=100" \
            --jq '[.[] | select(.pull_request == null)]')
          
          # Separate into categories
          # New issues: created_at >= SINCE
          NEW_ISSUES=$(echo "$ISSUES_JSON" | jq --arg since "$SINCE" \
            '[.[] | select(.created_at >= $since and .state == "open")]')
          
          # Reopened/Updated issues: older issues that were updated recently
          REOPENED_CANDIDATES_RAW=$(echo "$ISSUES_JSON" | jq --arg since "$SINCE" \
            '[.[] | select(.created_at < $since and .state == "open" and .updated_at >= $since)]')
          
          # For each reopened issue, fetch the last comment (or reopen comment)
          ENRICHED_REOPENED_ISSUES='[]'
          while IFS= read -r issue_json; do
            [ -z "$issue_json" ] && continue
            
            ISSUE_NUMBER=$(echo "$issue_json" | jq -r '.number')
            
            # Fetch the last comment on this issue
            LAST_COMMENT=$(gh api \
              -H "Accept: application/vnd.github+json" \
              "/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments?per_page=5" \
              --jq 'sort_by(.created_at) | last | {body: .body, user: .user.login} // {body: "", user: ""}' 2>/dev/null || echo '{"body":"","user":""}')
            
            LAST_COMMENT_BODY=$(echo "$LAST_COMMENT" | jq -r '.body // ""')
            LAST_COMMENT_USER=$(echo "$LAST_COMMENT" | jq -r '.user // ""')
            
            # Extract first 200 chars of the comment
            LAST_COMMENT_EXCERPT=$(echo "$LAST_COMMENT_BODY" | head -5 | tr '\n' ' ' | sed 's/  */ /g' | cut -c1-200 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # Add last comment to the issue object
            ENRICHED_ISSUE=$(echo "$issue_json" | jq \
              --arg comment "$LAST_COMMENT_EXCERPT" \
              --arg commenter "$LAST_COMMENT_USER" \
              '. + {last_comment: $comment, last_commenter: $commenter}')
            
            ENRICHED_REOPENED_ISSUES=$(echo "$ENRICHED_REOPENED_ISSUES" | jq --argjson issue "$ENRICHED_ISSUE" \
              '. + [$issue]')
          done < <(echo "$REOPENED_CANDIDATES_RAW" | jq -c '.[]')
          
          REOPENED_CANDIDATES="$ENRICHED_REOPENED_ISSUES"
          
          # For each new issue, fetch the github-actions bot comment
          ENRICHED_NEW_ISSUES='[]'
          while IFS= read -r issue_json; do
            [ -z "$issue_json" ] && continue
            
            ISSUE_NUMBER=$(echo "$issue_json" | jq -r '.number')
            
            # Fetch comments for this issue and find the github-actions bot comment
            BOT_COMMENT=$(gh api \
              -H "Accept: application/vnd.github+json" \
              "/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments?per_page=10" \
              --jq '[.[] | select(.user.login == "github-actions" or .user.login == "github-actions[bot]")] | first | .body // ""' 2>/dev/null || echo "")
            
            # Extract first 200 chars of bot comment
            BOT_COMMENT_EXCERPT=$(echo "$BOT_COMMENT" | head -5 | tr '\n' ' ' | sed 's/  */ /g' | cut -c1-200 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # Add bot comment to the issue object
            ENRICHED_ISSUE=$(echo "$issue_json" | jq --arg bot_comment "$BOT_COMMENT_EXCERPT" \
              '. + {bot_comment: $bot_comment}')
            
            ENRICHED_NEW_ISSUES=$(echo "$ENRICHED_NEW_ISSUES" | jq --argjson issue "$ENRICHED_ISSUE" \
              '. + [$issue]')
          done < <(echo "$NEW_ISSUES" | jq -c '.[]')
          
          # Count items
          NEW_COUNT=$(echo "$ENRICHED_NEW_ISSUES" | jq 'length')
          REOPENED_COUNT=$(echo "$REOPENED_CANDIDATES" | jq 'length')
          
          echo "new_count=$NEW_COUNT" >> $GITHUB_OUTPUT
          echo "reopened_count=$REOPENED_COUNT" >> $GITHUB_OUTPUT
          
          # Save to files for the next step
          echo "$ENRICHED_NEW_ISSUES" > /tmp/new_issues.json
          echo "$REOPENED_CANDIDATES" > /tmp/reopened_issues.json
          
          echo "Found $NEW_COUNT new issues and $REOPENED_COUNT reopened/updated issues"

      - name: Fetch issues with user comments
        id: comments
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SINCE="${{ steps.time.outputs.since }}"
          
          # Fetch all issue comments since the lookback time
          # Filter out bot comments (user.type != "Bot")
          COMMENTS_JSON=$(gh api \
            -H "Accept: application/vnd.github+json" \
            "/repos/${{ github.repository }}/issues/comments?since=$SINCE&per_page=100" \
            --jq '[.[] | select(.user.type != "Bot")]')
          
          # Get unique issue URLs from comments (to avoid duplicates)
          # Each comment has issue_url field that points to the issue API
          COMMENTED_ISSUE_URLS=$(echo "$COMMENTS_JSON" | jq -r '[.[].issue_url] | unique | .[]')
          
          # Fetch details for each commented issue
          COMMENTED_ISSUES='[]'
          for ISSUE_URL in $COMMENTED_ISSUE_URLS; do
            # Skip if empty
            [ -z "$ISSUE_URL" ] && continue
            
            # Fetch issue details
            ISSUE=$(gh api -H "Accept: application/vnd.github+json" "$ISSUE_URL" 2>/dev/null || echo '{}')
            
            # Skip pull requests and closed issues
            IS_PR=$(echo "$ISSUE" | jq 'has("pull_request")')
            STATE=$(echo "$ISSUE" | jq -r '.state // "unknown"')
            
            if [ "$IS_PR" = "false" ] && [ "$STATE" = "open" ]; then
              # Get the latest non-bot comment for this issue
              LATEST_COMMENT_DATA=$(echo "$COMMENTS_JSON" | jq --arg url "$ISSUE_URL" \
                '[.[] | select(.issue_url == $url)] | sort_by(.created_at) | last | {user: .user.login, body: .body} // {user: "unknown", body: ""}')
              
              LATEST_COMMENTER=$(echo "$LATEST_COMMENT_DATA" | jq -r '.user // "unknown"')
              LATEST_COMMENT_BODY=$(echo "$LATEST_COMMENT_DATA" | jq -r '.body // ""')
              
              # Extract first 200 chars of the comment
              COMMENT_EXCERPT=$(echo "$LATEST_COMMENT_BODY" | head -5 | tr '\n' ' ' | sed 's/  */ /g' | cut -c1-200 | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              
              # Add commenter info and comment excerpt to the issue
              ISSUE_WITH_COMMENTER=$(echo "$ISSUE" | jq \
                --arg commenter "$LATEST_COMMENTER" \
                --arg comment "$COMMENT_EXCERPT" \
                '. + {latest_commenter: $commenter, latest_comment: $comment}')
              
              COMMENTED_ISSUES=$(echo "$COMMENTED_ISSUES" | jq --argjson issue "$ISSUE_WITH_COMMENTER" \
                '. + [$issue]')
            fi
          done
          
          # Exclude issues that are already in "new issues" (created in this window)
          # We only want to show "commented on existing issues"
          COMMENTED_ISSUES=$(echo "$COMMENTED_ISSUES" | jq --arg since "$SINCE" \
            '[.[] | select(.created_at < $since)]')
          
          COMMENTED_COUNT=$(echo "$COMMENTED_ISSUES" | jq 'length')
          
          echo "commented_count=$COMMENTED_COUNT" >> $GITHUB_OUTPUT
          echo "$COMMENTED_ISSUES" > /tmp/commented_issues.json
          
          echo "Found $COMMENTED_COUNT issues with user comments"

      - name: Build Slack message
        id: message
        run: |
          NEW_COUNT="${{ steps.issues.outputs.new_count }}"
          REOPENED_COUNT="${{ steps.issues.outputs.reopened_count }}"
          COMMENTED_COUNT="${{ steps.comments.outputs.commented_count }}"
          
          # Check if there's anything to report
          if [ "$NEW_COUNT" -eq 0 ] && [ "$REOPENED_COUNT" -eq 0 ] && [ "$COMMENTED_COUNT" -eq 0 ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "No issues to report"
            exit 0
          fi
          
          echo "skip=false" >> $GITHUB_OUTPUT
          
          # Build the Slack blocks JSON
          BLOCKS='[]'
          
          # Header block
          BLOCKS=$(echo "$BLOCKS" | jq \
            '. + [{
              "type": "header",
              "text": {
                "type": "plain_text",
                "text": "üìä Daily Issues Digest",
                "emoji": true
              }
            }]')
          
          # Summary context
          BLOCKS=$(echo "$BLOCKS" | jq \
            --arg new "$NEW_COUNT" \
            --arg reopened "$REOPENED_COUNT" \
            --arg commented "$COMMENTED_COUNT" \
            --arg repo "${{ github.repository }}" \
            --arg hours "${{ env.HOURS_LOOKBACK }}" \
            '. + [{
              "type": "context",
              "elements": [{
                "type": "mrkdwn",
                "text": "*\($repo)* | Last \($hours) hours | üÜï \($new) new | üîÑ \($reopened) updated | üí¨ \($commented) commented"
              }]
            }]')
          
          # Divider
          BLOCKS=$(echo "$BLOCKS" | jq '. + [{"type": "divider"}]')
          
          # New Issues Section
          if [ "$NEW_COUNT" -gt 0 ]; then
            BLOCKS=$(echo "$BLOCKS" | jq '. + [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*üÜï New Issues*"
              }
            }]')
            
            # Add each new issue with "What happened?" excerpt (limit to 5 to avoid huge messages)
            # Extract text between "### What happened?" and "### Steps to reproduce"
            ISSUE_COUNT=0
            while IFS= read -r issue_json; do
              [ -z "$issue_json" ] && continue
              [ "$ISSUE_COUNT" -ge 5 ] && break
              
              NUMBER=$(echo "$issue_json" | jq -r '.number')
              TITLE=$(echo "$issue_json" | jq -r '.title')
              URL=$(echo "$issue_json" | jq -r '.html_url')
              USER=$(echo "$issue_json" | jq -r '.user.login')
              BODY=$(echo "$issue_json" | jq -r '.body // ""')
              BOT_COMMENT=$(echo "$issue_json" | jq -r '.bot_comment // ""')
              
              # Extract "What happened?" section
              # Get text after "### What happened?" and before "### Steps to reproduce"
              WHAT_HAPPENED=$(echo "$BODY" | sed -n '/### What happened?/,/### Steps to reproduce/p' | sed '1d;$d' | head -5 | tr '\n' ' ' | sed 's/  */ /g' | cut -c1-200)
              
              # Clean up the excerpt
              WHAT_HAPPENED=$(echo "$WHAT_HAPPENED" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
              
              # Build the issue block (use \n for newline in Slack mrkdwn)
              ISSUE_TEXT="‚Ä¢ <$URL|#$NUMBER>: *$TITLE* (_by $USER_)"
              
              # Add "What happened?" if available
              if [ -n "$WHAT_HAPPENED" ] && [ "$WHAT_HAPPENED" != "" ]; then
                ISSUE_TEXT="${ISSUE_TEXT}\n  üìù _${WHAT_HAPPENED}..._"
              fi
              
              # Add bot triage comment if available
              if [ -n "$BOT_COMMENT" ] && [ "$BOT_COMMENT" != "" ]; then
                ISSUE_TEXT="${ISSUE_TEXT}\n  ü§ñ _${BOT_COMMENT}..._"
              fi
              
              BLOCKS=$(echo "$BLOCKS" | jq --arg text "$ISSUE_TEXT" \
                '. + [{
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": $text
                  }
                }]')
              
              ISSUE_COUNT=$((ISSUE_COUNT + 1))
            done < <(cat /tmp/new_issues.json | jq -c '.[]')
            
            # Show if truncated
            if [ "$NEW_COUNT" -gt 5 ]; then
              REMAINING=$((NEW_COUNT - 5))
              BLOCKS=$(echo "$BLOCKS" | jq --arg remaining "$REMAINING" \
                '. + [{
                  "type": "context",
                  "elements": [{
                    "type": "mrkdwn",
                    "text": "_...and \($remaining) more_"
                  }]
                }]')
            fi
          fi
          
          # Reopened/Updated Issues Section
          if [ "$REOPENED_COUNT" -gt 0 ]; then
            BLOCKS=$(echo "$BLOCKS" | jq '. + [{"type": "divider"}]')
            BLOCKS=$(echo "$BLOCKS" | jq '. + [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*üîÑ Reopened/Recently Updated Issues*"
              }
            }]')
            
            # Add each reopened issue with last comment (limit to 5)
            REOPENED_COUNT_DISPLAY=0
            while IFS= read -r issue_json; do
              [ -z "$issue_json" ] && continue
              [ "$REOPENED_COUNT_DISPLAY" -ge 5 ] && break
              
              NUMBER=$(echo "$issue_json" | jq -r '.number')
              TITLE=$(echo "$issue_json" | jq -r '.title')
              URL=$(echo "$issue_json" | jq -r '.html_url')
              LAST_COMMENT=$(echo "$issue_json" | jq -r '.last_comment // ""')
              LAST_COMMENTER=$(echo "$issue_json" | jq -r '.last_commenter // ""')
              
              # Build the issue text
              ISSUE_TEXT="‚Ä¢ <$URL|#$NUMBER>: *$TITLE*"
              
              # Add last comment if available
              if [ -n "$LAST_COMMENT" ] && [ "$LAST_COMMENT" != "" ]; then
                ISSUE_TEXT="${ISSUE_TEXT}\n  üí¨ _${LAST_COMMENTER}: ${LAST_COMMENT}..._"
              fi
              
              BLOCKS=$(echo "$BLOCKS" | jq --arg text "$ISSUE_TEXT" \
                '. + [{
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": $text
                  }
                }]')
              
              REOPENED_COUNT_DISPLAY=$((REOPENED_COUNT_DISPLAY + 1))
            done < <(cat /tmp/reopened_issues.json | jq -c '.[]')
            
            # Show if truncated
            if [ "$REOPENED_COUNT" -gt 5 ]; then
              REMAINING=$((REOPENED_COUNT - 5))
              BLOCKS=$(echo "$BLOCKS" | jq --arg remaining "$REMAINING" \
                '. + [{
                  "type": "context",
                  "elements": [{
                    "type": "mrkdwn",
                    "text": "_...and \($remaining) more_"
                  }]
                }]')
            fi
          fi
          
          # Issues with User Comments Section (excluding bots)
          if [ "$COMMENTED_COUNT" -gt 0 ]; then
            BLOCKS=$(echo "$BLOCKS" | jq '. + [{"type": "divider"}]')
            BLOCKS=$(echo "$BLOCKS" | jq '. + [{
              "type": "section",
              "text": {
                "type": "mrkdwn",
                "text": "*üí¨ Issues with New Comments*"
              }
            }]')
            
            # Add each commented issue with comment content (limit to 5)
            COMMENTED_COUNT_DISPLAY=0
            while IFS= read -r issue_json; do
              [ -z "$issue_json" ] && continue
              [ "$COMMENTED_COUNT_DISPLAY" -ge 5 ] && break
              
              NUMBER=$(echo "$issue_json" | jq -r '.number')
              TITLE=$(echo "$issue_json" | jq -r '.title')
              URL=$(echo "$issue_json" | jq -r '.html_url')
              COMMENTER=$(echo "$issue_json" | jq -r '.latest_commenter // ""')
              COMMENT=$(echo "$issue_json" | jq -r '.latest_comment // ""')
              
              # Build the issue text
              ISSUE_TEXT="‚Ä¢ <$URL|#$NUMBER>: *$TITLE*"
              
              # Add comment content if available
              if [ -n "$COMMENT" ] && [ "$COMMENT" != "" ]; then
                ISSUE_TEXT="${ISSUE_TEXT}\n  üí¨ _${COMMENTER}: ${COMMENT}..._"
              else
                ISSUE_TEXT="${ISSUE_TEXT}\n  üí¨ _comment by ${COMMENTER}_"
              fi
              
              BLOCKS=$(echo "$BLOCKS" | jq --arg text "$ISSUE_TEXT" \
                '. + [{
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": $text
                  }
                }]')
              
              COMMENTED_COUNT_DISPLAY=$((COMMENTED_COUNT_DISPLAY + 1))
            done < <(cat /tmp/commented_issues.json | jq -c '.[]')
            
            # Show if truncated
            if [ "$COMMENTED_COUNT" -gt 5 ]; then
              REMAINING=$((COMMENTED_COUNT - 5))
              BLOCKS=$(echo "$BLOCKS" | jq --arg remaining "$REMAINING" \
                '. + [{
                  "type": "context",
                  "elements": [{
                    "type": "mrkdwn",
                    "text": "_...and \($remaining) more_"
                  }]
                }]')
            fi
          fi
          
          # Footer with link to all issues
          BLOCKS=$(echo "$BLOCKS" | jq --arg url "https://github.com/${{ github.repository }}/issues" \
            '. + [{
              "type": "context",
              "elements": [{
                "type": "mrkdwn",
                "text": "<\($url)|View all issues ‚Üí>"
              }]
            }]')
          
          # Save the blocks JSON
          echo "$BLOCKS" > /tmp/slack_blocks.json
          
          # Create the full payload
          PAYLOAD=$(jq -n \
            --arg text "üìä Daily Issues Digest for ${{ github.repository }}" \
            --argjson blocks "$(cat /tmp/slack_blocks.json)" \
            '{text: $text, blocks: $blocks}')
          
          echo "$PAYLOAD" > /tmp/slack_payload.json
          echo "Slack payload built successfully"

      - name: Send to Slack
        if: steps.message.outputs.skip != 'true'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL_ISSUES }}
        run: |
          curl --fail -X POST \
            -H 'Content-type: application/json' \
            --data @/tmp/slack_payload.json \
            "$SLACK_WEBHOOK_URL"
          
          echo "‚úÖ Digest sent to Slack!"

      - name: No updates to report
        if: steps.message.outputs.skip == 'true'
        run: |
          echo "‚ÑπÔ∏è No new or reopened issues in the last ${{ env.HOURS_LOOKBACK }} hours. Skipping Slack notification."
