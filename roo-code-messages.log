[2025-06-16T20:26:40.328Z] {
  "ts": 1750105600326,
  "type": "say",
  "say": "text",
  "text": "Fix the following GitHub issue:\n\nRepository: RooCodeInc/Roo-Code\nIssue #4747: Context Overflow Contingency in Subtask: Browser Focused\n\nDescription:\n### What specific problem does this solve?\n\nI am using the a custom mode called \"MCP Expert\" to handle browser interactions using PlayWright. What often happens is that the mode would navigate to a page and get stuck there because the returned page had too many tokens, overflowing the window.\n\nWhat happens is that the context condensation does not work because the stuff from the browser is brand new, not a chat.\n\n### How should this be solved?\n\nInclude a feature that can be enabled for a certain mode that if the token window exceeds, exit the subtask with an `attempt_completion` comment that is customizable. In my case, this comment would be \"Task failed because of a context overflow, possibly because webpage returned from the browser was too big\". This can also be customised by the AI before everytime it accesses a particular tool, obviously, predefined.\n\nI understand that though it might not be a complex feature, it is way too specific but I think it could help a lot of people because the browser thing happens very often.\n\nAnother effective idea could be that we backtrack the step and tell the same mode that 'oh the context exceeded because you did something and was not condensable, please refrain from doing that.' however, I like the first approach more because for non reasoning models, this could be problematic.\n\n### How will we know it works? (Acceptance Criteria)\n\nGiven I had a task that was divided and a subtask was given to a mode\nWhen the particular mode (predefined for contingency) exceeds the content window\nthen, we exit the subtask and tell the orchestrator that the context exceeded.\nExtra: we can maybe add a message that is predefined by the user or created everytime by the AI when it is about to use a known problematic tool (flagged by the user)\n\n\n### Estimated effort and complexity\n\nSize: A few days\nReasoning: To be honest, I don't know enough about Roo Code's code, but it feels that it should be of mediocre difficulty to include a togglable feature like this.\n\n### Technical considerations (optional but helpful)\n\n_No response_\n\n### Trade-offs and risks (optional)\n\nMaybe the context overflowed because of some other reason than a tool use and the mode still exits subtask. This could be annoying, hence particular tool use maybe helpful. However, this is particularly my use case.\n\n### Additional context (optional)\n\nI apologize that I will probably not be able to help implement this issue. i would love to, but I do not have the expertise yet.\n\n### Proposal checklist\n\n- [x] I've searched existing Issues and Discussions for duplicates\n- [x] This is a specific, actionable proposal with clear problem and solution\n- [x] I've included concrete acceptance criteria\n- [x] I understand this needs approval before implementation begins\n\n### Interested in implementing this?\n\n- [ ] Yes, I'd like to help implement this feature\n\nLabels: enhancement, feature request, Issue/PR - Triage, proposal\n\nPlease analyze the issue, understand what needs to be fixed, and implement a solution.\n\nWhen you're finished:\n- Create a git branch to store your work\n- Commit your changes to this branch\n- Submit a pull request using the \"gh\" command line tool (gh pr create --title \"Fixes #4747\n\n[Your PR description here.]\" --fill --template \"pull_request_template.md\")\n\nYour job isn't done until you've created a pull request. Try to solve any git issues that arise while creating your branch and submitting your pull request."
}
[2025-06-16T20:26:40.335Z] taskStarted -> 97c7a33b-dad2-44a8-817f-cd1f541fe4fb
[2025-06-16T20:26:40.337Z] {
  "ts": 1750105600335,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"<task>\\nFix the following GitHub issue:\\n\\nRepository: RooCodeInc/Roo-Code\\nIssue #4747: Context Overflow Contingency in Subtask: Browser Focused\\n\\nDescription:\\n### What specific problem does this solve?\\n\\nI am using the a custom mode called \\\"MCP Expert\\\" to handle browser interactions using PlayWright. What often happens is that the mode would navigate to a page and get stuck there because the returned page had too many tokens, overflowing the window.\\n\\nWhat happens is that the context condensation does not work because the stuff from the browser is brand new, not a chat.\\n\\n### How should this be solved?\\n\\nInclude a feature that can be enabled for a certain mode that if the token window exceeds, exit the subtask with an `attempt_completion` comment that is customizable. In my case, this comment would be \\\"Task failed because of a context overflow, possibly because webpage returned from the browser was too big\\\". This can also be customised by the AI before everytime it accesses a particular tool, obviously, predefined.\\n\\nI understand that though it might not be a complex feature, it is way too specific but I think it could help a lot of people because the browser thing happens very often.\\n\\nAnother effective idea could be that we backtrack the step and tell the same mode that 'oh the context exceeded because you did something and was not condensable, please refrain from doing that.' however, I like the first approach more because for non reasoning models, this could be problematic.\\n\\n### How will we know it works? (Acceptance Criteria)\\n\\nGiven I had a task that was divided and a subtask was given to a mode\\nWhen the particular mode (predefined for contingency) exceeds the content window\\nthen, we exit the subtask and tell the orchestrator that the context exceeded.\\nExtra: we can maybe add a message that is predefined by the user or created everytime by the AI when it is about to use a known problematic tool (flagged by the user)\\n\\n\\n### Estimated effort and complexity\\n\\nSize: A few days\\nReasoning: To be honest, I don't know enough about Roo Code's code, but it feels that it should be of mediocre difficulty to include a togglable feature like this.\\n\\n### Technical considerations (optional but helpful)\\n\\n_No response_\\n\\n### Trade-offs and risks (optional)\\n\\nMaybe the context overflowed because of some other reason than a tool use and the mode still exits subtask. This could be annoying, hence particular tool use maybe helpful. However, this is particularly my use case.\\n\\n### Additional context (optional)\\n\\nI apologize that I will probably not be able to help implement this issue. i would love to, but I do not have the expertise yet.\\n\\n### Proposal checklist\\n\\n- [x] I've searched existing Issues and Discussions for duplicates\\n- [x] This is a specific, actionable proposal with clear problem and solution\\n- [x] I've included concrete acceptance criteria\\n- [x] I understand this needs approval before implementation begins\\n\\n### Interested in implementing this?\\n\\n- [ ] Yes, I'd like to help implement this feature\\n\\nLabels: enhancement, feature request, Issue/PR - Triage, proposal\\n\\nPlease analyze the issue, understand what needs to be fixed, and implement a solution.\\n\\nWhen you're finished:\\n- Create a git branch to store your work\\n- Commit your changes to this branch\\n- Submit a pull request using the \\\"gh\\\" command line tool (gh pr create --title \\\"Fixes #4747\\n\\n[Your PR description here.]\\\" --fill --template \\\"pull_request_template.md\\\")\\n\\nYour job isn't done until you've created a pull request. Try to solve any git issues that arise while creating your branch and submitting your pull request.\\n</task>\\n\\nLoading...\"}"
}
[2025-06-16T20:26:47.324Z] {
  "ts": 1750105602817,
  "type": "say",
  "say": "text",
  "text": "I'll analyze this GitHub issue and implement a solution for context overflow contingency in subtasks. Let me start by understanding the codebase structure and the current implementation.\n\nThe issue is about implementing a context overflow contingency feature for modes that might exceed the token window, particularly when using browser interactions with PlayWright. The user wants:\n\n1. A feature that can be enabled for certain modes\n2. When token window exceeds, exit the subtask with a customizable `attempt_completion` message\n3. The message should be customizable and could be predefined or created by AI before using problematic tools\n\nLet me first explore the codebase to understand:\n1. How modes are implemented\n2. How subtasks work\n3. How context/token management is handled\n4. Where I should implement this feature\n\nI should start by looking at the types and mode-related files.",
  "partial": false
}
[2025-06-16T20:26:48.330Z] {
  "ts": 1750105607323,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"readFile\",\"batchFiles\":[{\"path\":\"packages/types/src/mode.ts\",\"lineSnippet\":\"\",\"isOutsideWorkspace\":false,\"key\":\"packages/types/src/mode.ts\",\"content\":\"/roo/repos/Roo-Code/packages/types/src/mode.ts\"},{\"path\":\"packages/types/src/api.ts\",\"lineSnippet\":\"\",\"isOutsideWorkspace\":false,\"key\":\"packages/types/src/api.ts\",\"content\":\"/roo/repos/Roo-Code/packages/types/src/api.ts\"},{\"path\":\"src/shared/modes.ts\",\"lineSnippet\":\"\",\"isOutsideWorkspace\":false,\"key\":\"src/shared/modes.ts\",\"content\":\"/roo/repos/Roo-Code/src/shared/modes.ts\"}]}",
  "partial": false
}
[2025-06-16T20:26:48.590Z] {
  "ts": 1750105608587,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[read_file for 'packages/types/src/mode.ts', 'packages/types/src/api.ts', 'src/shared/modes.ts'] Result:\\n\\n<files>\\n<file><path>packages/types/src/mode.ts</path>\\n<content lines=\\\"1-128\\\">\\n  1 | import { z } from \\\"zod\\\"\\n  2 | \\n  3 | import { toolGroupsSchema } from \\\"./tool.js\\\"\\n  4 | \\n  5 | /**\\n  6 |  * GroupOptions\\n  7 |  */\\n  8 | \\n  9 | export const groupOptionsSchema = z.object({\\n 10 | \\tfileRegex: z\\n 11 | \\t\\t.string()\\n 12 | \\t\\t.optional()\\n 13 | \\t\\t.refine(\\n 14 | \\t\\t\\t(pattern) => {\\n 15 | \\t\\t\\t\\tif (!pattern) {\\n 16 | \\t\\t\\t\\t\\treturn true // Optional, so empty is valid.\\n 17 | \\t\\t\\t\\t}\\n 18 | \\n 19 | \\t\\t\\t\\ttry {\\n 20 | \\t\\t\\t\\t\\tnew RegExp(pattern)\\n 21 | \\t\\t\\t\\t\\treturn true\\n 22 | \\t\\t\\t\\t} catch {\\n 23 | \\t\\t\\t\\t\\treturn false\\n 24 | \\t\\t\\t\\t}\\n 25 | \\t\\t\\t},\\n 26 | \\t\\t\\t{ message: \\\"Invalid regular expression pattern\\\" },\\n 27 | \\t\\t),\\n 28 | \\tdescription: z.string().optional(),\\n 29 | })\\n 30 | \\n 31 | export type GroupOptions = z.infer<typeof groupOptionsSchema>\\n 32 | \\n 33 | /**\\n 34 |  * GroupEntry\\n 35 |  */\\n 36 | \\n 37 | export const groupEntrySchema = z.union([toolGroupsSchema, z.tuple([toolGroupsSchema, groupOptionsSchema])])\\n 38 | \\n 39 | export type GroupEntry = z.infer<typeof groupEntrySchema>\\n 40 | \\n 41 | /**\\n 42 |  * ModeConfig\\n 43 |  */\\n 44 | \\n 45 | const groupEntryArraySchema = z.array(groupEntrySchema).refine(\\n 46 | \\t(groups) => {\\n 47 | \\t\\tconst seen = new Set()\\n 48 | \\n 49 | \\t\\treturn groups.every((group) => {\\n 50 | \\t\\t\\t// For tuples, check the group name (first element).\\n 51 | \\t\\t\\tconst groupName = Array.isArray(group) ? group[0] : group\\n 52 | \\n 53 | \\t\\t\\tif (seen.has(groupName)) {\\n 54 | \\t\\t\\t\\treturn false\\n 55 | \\t\\t\\t}\\n 56 | \\n 57 | \\t\\t\\tseen.add(groupName)\\n 58 | \\t\\t\\treturn true\\n 59 | \\t\\t})\\n 60 | \\t},\\n 61 | \\t{ message: \\\"Duplicate groups are not allowed\\\" },\\n 62 | )\\n 63 | \\n 64 | export const modeConfigSchema = z.object({\\n 65 | \\tslug: z.string().regex(/^[a-zA-Z0-9-]+$/, \\\"Slug must contain only letters numbers and dashes\\\"),\\n 66 | \\tname: z.string().min(1, \\\"Name is required\\\"),\\n 67 | \\troleDefinition: z.string().min(1, \\\"Role definition is required\\\"),\\n 68 | \\twhenToUse: z.string().optional(),\\n 69 | \\tcustomInstructions: z.string().optional(),\\n 70 | \\tgroups: groupEntryArraySchema,\\n 71 | \\tsource: z.enum([\\\"global\\\", \\\"project\\\"]).optional(),\\n 72 | })\\n 73 | \\n 74 | export type ModeConfig = z.infer<typeof modeConfigSchema>\\n 75 | \\n 76 | /**\\n 77 |  * CustomModesSettings\\n 78 |  */\\n 79 | \\n 80 | export const customModesSettingsSchema = z.object({\\n 81 | \\tcustomModes: z.array(modeConfigSchema).refine(\\n 82 | \\t\\t(modes) => {\\n 83 | \\t\\t\\tconst slugs = new Set()\\n 84 | \\n 85 | \\t\\t\\treturn modes.every((mode) => {\\n 86 | \\t\\t\\t\\tif (slugs.has(mode.slug)) {\\n 87 | \\t\\t\\t\\t\\treturn false\\n 88 | \\t\\t\\t\\t}\\n 89 | \\n 90 | \\t\\t\\t\\tslugs.add(mode.slug)\\n 91 | \\t\\t\\t\\treturn true\\n 92 | \\t\\t\\t})\\n 93 | \\t\\t},\\n 94 | \\t\\t{\\n 95 | \\t\\t\\tmessage: \\\"Duplicate mode slugs are not allowed\\\",\\n 96 | \\t\\t},\\n 97 | \\t),\\n 98 | })\\n 99 | \\n100 | export type CustomModesSettings = z.infer<typeof customModesSettingsSchema>\\n101 | \\n102 | /**\\n103 |  * PromptComponent\\n104 |  */\\n105 | \\n106 | export const promptComponentSchema = z.object({\\n107 | \\troleDefinition: z.string().optional(),\\n108 | \\twhenToUse: z.string().optional(),\\n109 | \\tcustomInstructions: z.string().optional(),\\n110 | })\\n111 | \\n112 | export type PromptComponent = z.infer<typeof promptComponentSchema>\\n113 | \\n114 | /**\\n115 |  * CustomModePrompts\\n116 |  */\\n117 | \\n118 | export const customModePromptsSchema = z.record(z.string(), promptComponentSchema.optional())\\n119 | \\n120 | export type CustomModePrompts = z.infer<typeof customModePromptsSchema>\\n121 | \\n122 | /**\\n123 |  * CustomSupportPrompts\\n124 |  */\\n125 | \\n126 | export const customSupportPromptsSchema = z.record(z.string(), z.string().optional())\\n127 | \\n128 | export type CustomSupportPrompts = z.infer<typeof customSupportPromptsSchema>\\n</content>\\n</file>\\n<file><path>packages/types/src/api.ts</path>\\n<content lines=\\\"1-159\\\">\\n  1 | import type { EventEmitter } from \\\"events\\\"\\n  2 | import type { Socket } from \\\"net\\\"\\n  3 | \\n  4 | import type { RooCodeSettings } from \\\"./global-settings.js\\\"\\n  5 | import type { ProviderSettingsEntry, ProviderSettings } from \\\"./provider-settings.js\\\"\\n  6 | import type { ClineMessage, TokenUsage } from \\\"./message.js\\\"\\n  7 | import type { ToolUsage, ToolName } from \\\"./tool.js\\\"\\n  8 | import type { IpcMessage, IpcServerEvents } from \\\"./ipc.js\\\"\\n  9 | \\n 10 | // TODO: Make sure this matches `RooCodeEvents` from `@roo-code/types`.\\n 11 | export interface RooCodeAPIEvents {\\n 12 | \\tmessage: [data: { taskId: string; action: \\\"created\\\" | \\\"updated\\\"; message: ClineMessage }]\\n 13 | \\ttaskCreated: [taskId: string]\\n 14 | \\ttaskStarted: [taskId: string]\\n 15 | \\ttaskModeSwitched: [taskId: string, mode: string]\\n 16 | \\ttaskPaused: [taskId: string]\\n 17 | \\ttaskUnpaused: [taskId: string]\\n 18 | \\ttaskAskResponded: [taskId: string]\\n 19 | \\ttaskAborted: [taskId: string]\\n 20 | \\ttaskSpawned: [parentTaskId: string, childTaskId: string]\\n 21 | \\ttaskCompleted: [taskId: string, tokenUsage: TokenUsage, toolUsage: ToolUsage]\\n 22 | \\ttaskTokenUsageUpdated: [taskId: string, tokenUsage: TokenUsage]\\n 23 | \\ttaskToolFailed: [taskId: string, toolName: ToolName, error: string]\\n 24 | }\\n 25 | \\n 26 | export interface RooCodeAPI extends EventEmitter<RooCodeAPIEvents> {\\n 27 | \\t/**\\n 28 | \\t * Starts a new task with an optional initial message and images.\\n 29 | \\t * @param task Optional initial task message.\\n 30 | \\t * @param images Optional array of image data URIs (e.g., \\\"data:image/webp;base64,...\\\").\\n 31 | \\t * @returns The ID of the new task.\\n 32 | \\t */\\n 33 | \\tstartNewTask({\\n 34 | \\t\\tconfiguration,\\n 35 | \\t\\ttext,\\n 36 | \\t\\timages,\\n 37 | \\t\\tnewTab,\\n 38 | \\t}: {\\n 39 | \\t\\tconfiguration?: RooCodeSettings\\n 40 | \\t\\ttext?: string\\n 41 | \\t\\timages?: string[]\\n 42 | \\t\\tnewTab?: boolean\\n 43 | \\t}): Promise<string>\\n 44 | \\t/**\\n 45 | \\t * Resumes a task with the given ID.\\n 46 | \\t * @param taskId The ID of the task to resume.\\n 47 | \\t * @throws Error if the task is not found in the task history.\\n 48 | \\t */\\n 49 | \\tresumeTask(taskId: string): Promise<void>\\n 50 | \\t/**\\n 51 | \\t * Checks if a task with the given ID is in the task history.\\n 52 | \\t * @param taskId The ID of the task to check.\\n 53 | \\t * @returns True if the task is in the task history, false otherwise.\\n 54 | \\t */\\n 55 | \\tisTaskInHistory(taskId: string): Promise<boolean>\\n 56 | \\t/**\\n 57 | \\t * Returns the current task stack.\\n 58 | \\t * @returns An array of task IDs.\\n 59 | \\t */\\n 60 | \\tgetCurrentTaskStack(): string[]\\n 61 | \\t/**\\n 62 | \\t * Clears the current task.\\n 63 | \\t */\\n 64 | \\tclearCurrentTask(lastMessage?: string): Promise<void>\\n 65 | \\t/**\\n 66 | \\t * Cancels the current task.\\n 67 | \\t */\\n 68 | \\tcancelCurrentTask(): Promise<void>\\n 69 | \\t/**\\n 70 | \\t * Sends a message to the current task.\\n 71 | \\t * @param message Optional message to send.\\n 72 | \\t * @param images Optional array of image data URIs (e.g., \\\"data:image/webp;base64,...\\\").\\n 73 | \\t */\\n 74 | \\tsendMessage(message?: string, images?: string[]): Promise<void>\\n 75 | \\t/**\\n 76 | \\t * Simulates pressing the primary button in the chat interface.\\n 77 | \\t */\\n 78 | \\tpressPrimaryButton(): Promise<void>\\n 79 | \\t/**\\n 80 | \\t * Simulates pressing the secondary button in the chat interface.\\n 81 | \\t */\\n 82 | \\tpressSecondaryButton(): Promise<void>\\n 83 | \\t/**\\n 84 | \\t * Returns true if the API is ready to use.\\n 85 | \\t */\\n 86 | \\tisReady(): boolean\\n 87 | \\t/**\\n 88 | \\t * Returns the current configuration.\\n 89 | \\t * @returns The current configuration.\\n 90 | \\t */\\n 91 | \\tgetConfiguration(): RooCodeSettings\\n 92 | \\t/**\\n 93 | \\t * Sets the configuration for the current task.\\n 94 | \\t * @param values An object containing key-value pairs to set.\\n 95 | \\t */\\n 96 | \\tsetConfiguration(values: RooCodeSettings): Promise<void>\\n 97 | \\t/**\\n 98 | \\t * Returns a list of all configured profile names\\n 99 | \\t * @returns Array of profile names\\n100 | \\t */\\n101 | \\tgetProfiles(): string[]\\n102 | \\t/**\\n103 | \\t * Returns the profile entry for a given name\\n104 | \\t * @param name The name of the profile\\n105 | \\t * @returns The profile entry, or undefined if the profile does not exist\\n106 | \\t */\\n107 | \\tgetProfileEntry(name: string): ProviderSettingsEntry | undefined\\n108 | \\t/**\\n109 | \\t * Creates a new API configuration profile\\n110 | \\t * @param name The name of the profile\\n111 | \\t * @param profile The profile to create; defaults to an empty object\\n112 | \\t * @param activate Whether to activate the profile after creation; defaults to true\\n113 | \\t * @returns The ID of the created profile\\n114 | \\t * @throws Error if the profile already exists\\n115 | \\t */\\n116 | \\tcreateProfile(name: string, profile?: ProviderSettings, activate?: boolean): Promise<string>\\n117 | \\t/**\\n118 | \\t * Updates an existing API configuration profile\\n119 | \\t * @param name The name of the profile\\n120 | \\t * @param profile The profile to update\\n121 | \\t * @param activate Whether to activate the profile after update; defaults to true\\n122 | \\t * @returns The ID of the updated profile\\n123 | \\t * @throws Error if the profile does not exist\\n124 | \\t */\\n125 | \\tupdateProfile(name: string, profile: ProviderSettings, activate?: boolean): Promise<string | undefined>\\n126 | \\t/**\\n127 | \\t * Creates a new API configuration profile or updates an existing one\\n128 | \\t * @param name The name of the profile\\n129 | \\t * @param profile The profile to create or update; defaults to an empty object\\n130 | \\t * @param activate Whether to activate the profile after upsert; defaults to true\\n131 | \\t * @returns The ID of the upserted profile\\n132 | \\t */\\n133 | \\tupsertProfile(name: string, profile: ProviderSettings, activate?: boolean): Promise<string | undefined>\\n134 | \\t/**\\n135 | \\t * Deletes a profile by name\\n136 | \\t * @param name The name of the profile to delete\\n137 | \\t * @throws Error if the profile does not exist\\n138 | \\t */\\n139 | \\tdeleteProfile(name: string): Promise<void>\\n140 | \\t/**\\n141 | \\t * Returns the name of the currently active profile\\n142 | \\t * @returns The profile name, or undefined if no profile is active\\n143 | \\t */\\n144 | \\tgetActiveProfile(): string | undefined\\n145 | \\t/**\\n146 | \\t * Changes the active API configuration profile\\n147 | \\t * @param name The name of the profile to activate\\n148 | \\t * @throws Error if the profile does not exist\\n149 | \\t */\\n150 | \\tsetActiveProfile(name: string): Promise<string | undefined>\\n151 | }\\n152 | \\n153 | export interface RooCodeIpcServer extends EventEmitter<IpcServerEvents> {\\n154 | \\tlisten(): void\\n155 | \\tbroadcast(message: IpcMessage): void\\n156 | \\tsend(client: string | Socket, message: IpcMessage): void\\n157 | \\tget socketPath(): string\\n158 | \\tget isListening(): boolean\\n159 | }\\n</content>\\n</file>\\n<file><path>src/shared/modes.ts</path>\\n<content lines=\\\"1-374\\\">\\n  1 | import * as vscode from \\\"vscode\\\"\\n  2 | \\n  3 | import type {\\n  4 | \\tGroupOptions,\\n  5 | \\tGroupEntry,\\n  6 | \\tModeConfig,\\n  7 | \\tCustomModePrompts,\\n  8 | \\tExperimentId,\\n  9 | \\tToolGroup,\\n 10 | \\tPromptComponent,\\n 11 | } from \\\"@roo-code/types\\\"\\n 12 | \\n 13 | import { addCustomInstructions } from \\\"../core/prompts/sections/custom-instructions\\\"\\n 14 | \\n 15 | import { EXPERIMENT_IDS } from \\\"./experiments\\\"\\n 16 | import { TOOL_GROUPS, ALWAYS_AVAILABLE_TOOLS } from \\\"./tools\\\"\\n 17 | \\n 18 | export type Mode = string\\n 19 | \\n 20 | // Helper to extract group name regardless of format\\n 21 | export function getGroupName(group: GroupEntry): ToolGroup {\\n 22 | \\tif (typeof group === \\\"string\\\") {\\n 23 | \\t\\treturn group\\n 24 | \\t}\\n 25 | \\n 26 | \\treturn group[0]\\n 27 | }\\n 28 | \\n 29 | // Helper to get group options if they exist\\n 30 | function getGroupOptions(group: GroupEntry): GroupOptions | undefined {\\n 31 | \\treturn Array.isArray(group) ? group[1] : undefined\\n 32 | }\\n 33 | \\n 34 | // Helper to check if a file path matches a regex pattern\\n 35 | export function doesFileMatchRegex(filePath: string, pattern: string): boolean {\\n 36 | \\ttry {\\n 37 | \\t\\tconst regex = new RegExp(pattern)\\n 38 | \\t\\treturn regex.test(filePath)\\n 39 | \\t} catch (error) {\\n 40 | \\t\\tconsole.error(`Invalid regex pattern: ${pattern}`, error)\\n 41 | \\t\\treturn false\\n 42 | \\t}\\n 43 | }\\n 44 | \\n 45 | // Helper to get all tools for a mode\\n 46 | export function getToolsForMode(groups: readonly GroupEntry[]): string[] {\\n 47 | \\tconst tools = new Set<string>()\\n 48 | \\n 49 | \\t// Add tools from each group\\n 50 | \\tgroups.forEach((group) => {\\n 51 | \\t\\tconst groupName = getGroupName(group)\\n 52 | \\t\\tconst groupConfig = TOOL_GROUPS[groupName]\\n 53 | \\t\\tgroupConfig.tools.forEach((tool: string) => tools.add(tool))\\n 54 | \\t})\\n 55 | \\n 56 | \\t// Always add required tools\\n 57 | \\tALWAYS_AVAILABLE_TOOLS.forEach((tool) => tools.add(tool))\\n 58 | \\n 59 | \\treturn Array.from(tools)\\n 60 | }\\n 61 | \\n 62 | // Main modes configuration as an ordered array\\n 63 | export const modes: readonly ModeConfig[] = [\\n 64 | \\t{\\n 65 | \\t\\tslug: \\\"code\\\",\\n 66 | \\t\\tname: \\\"💻 Code\\\",\\n 67 | \\t\\troleDefinition:\\n 68 | \\t\\t\\t\\\"You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.\\\",\\n 69 | \\t\\twhenToUse:\\n 70 | \\t\\t\\t\\\"Use this mode when you need to write, modify, or refactor code. Ideal for implementing features, fixing bugs, creating new files, or making code improvements across any programming language or framework.\\\",\\n 71 | \\t\\tgroups: [\\\"read\\\", \\\"edit\\\", \\\"browser\\\", \\\"command\\\", \\\"mcp\\\"],\\n 72 | \\t},\\n 73 | \\t{\\n 74 | \\t\\tslug: \\\"architect\\\",\\n 75 | \\t\\tname: \\\"🏗️ Architect\\\",\\n 76 | \\t\\troleDefinition:\\n 77 | \\t\\t\\t\\\"You are Roo, an experienced technical leader who is inquisitive and an excellent planner. Your goal is to gather information and get context to create a detailed plan for accomplishing the user's task, which the user will review and approve before they switch into another mode to implement the solution.\\\",\\n 78 | \\t\\twhenToUse:\\n 79 | \\t\\t\\t\\\"Use this mode when you need to plan, design, or strategize before implementation. Perfect for breaking down complex problems, creating technical specifications, designing system architecture, or brainstorming solutions before coding.\\\",\\n 80 | \\t\\tgroups: [\\\"read\\\", [\\\"edit\\\", { fileRegex: \\\"\\\\\\\\.md$\\\", description: \\\"Markdown files only\\\" }], \\\"browser\\\", \\\"mcp\\\"],\\n 81 | \\t\\tcustomInstructions:\\n 82 | \\t\\t\\t\\\"1. Do some information gathering (for example using read_file or search_files) to get more context about the task.\\\\n\\\\n2. You should also ask the user clarifying questions to get a better understanding of the task.\\\\n\\\\n3. Once you've gained more context about the user's request, you should create a detailed plan for how to accomplish the task. Include Mermaid diagrams if they help make your plan clearer.\\\\n\\\\n4. Ask the user if they are pleased with this plan, or if they would like to make any changes. Think of this as a brainstorming session where you can discuss the task and plan the best way to accomplish it.\\\\n\\\\n5. Once the user confirms the plan, ask them if they'd like you to write it to a markdown file.\\\\n\\\\n6. Use the switch_mode tool to request that the user switch to another mode to implement the solution.\\\",\\n 83 | \\t},\\n 84 | \\t{\\n 85 | \\t\\tslug: \\\"ask\\\",\\n 86 | \\t\\tname: \\\"❓ Ask\\\",\\n 87 | \\t\\troleDefinition:\\n 88 | \\t\\t\\t\\\"You are Roo, a knowledgeable technical assistant focused on answering questions and providing information about software development, technology, and related topics.\\\",\\n 89 | \\t\\twhenToUse:\\n 90 | \\t\\t\\t\\\"Use this mode when you need explanations, documentation, or answers to technical questions. Best for understanding concepts, analyzing existing code, getting recommendations, or learning about technologies without making changes.\\\",\\n 91 | \\t\\tgroups: [\\\"read\\\", \\\"browser\\\", \\\"mcp\\\"],\\n 92 | \\t\\tcustomInstructions:\\n 93 | \\t\\t\\t\\\"You can analyze code, explain concepts, and access external resources. Always answer the user's questions thoroughly, and do not switch to implementing code unless explicitly requested by the user. Include Mermaid diagrams when they clarify your response.\\\",\\n 94 | \\t},\\n 95 | \\t{\\n 96 | \\t\\tslug: \\\"debug\\\",\\n 97 | \\t\\tname: \\\"🪲 Debug\\\",\\n 98 | \\t\\troleDefinition:\\n 99 | \\t\\t\\t\\\"You are Roo, an expert software debugger specializing in systematic problem diagnosis and resolution.\\\",\\n100 | \\t\\twhenToUse:\\n101 | \\t\\t\\t\\\"Use this mode when you're troubleshooting issues, investigating errors, or diagnosing problems. Specialized in systematic debugging, adding logging, analyzing stack traces, and identifying root causes before applying fixes.\\\",\\n102 | \\t\\tgroups: [\\\"read\\\", \\\"edit\\\", \\\"browser\\\", \\\"command\\\", \\\"mcp\\\"],\\n103 | \\t\\tcustomInstructions:\\n104 | \\t\\t\\t\\\"Reflect on 5-7 different possible sources of the problem, distill those down to 1-2 most likely sources, and then add logs to validate your assumptions. Explicitly ask the user to confirm the diagnosis before fixing the problem.\\\",\\n105 | \\t},\\n106 | \\t{\\n107 | \\t\\tslug: \\\"orchestrator\\\",\\n108 | \\t\\tname: \\\"🪃 Orchestrator\\\",\\n109 | \\t\\troleDefinition:\\n110 | \\t\\t\\t\\\"You are Roo, a strategic workflow orchestrator who coordinates complex tasks by delegating them to appropriate specialized modes. You have a comprehensive understanding of each mode's capabilities and limitations, allowing you to effectively break down complex problems into discrete tasks that can be solved by different specialists.\\\",\\n111 | \\t\\twhenToUse:\\n112 | \\t\\t\\t\\\"Use this mode for complex, multi-step projects that require coordination across different specialties. Ideal when you need to break down large tasks into subtasks, manage workflows, or coordinate work that spans multiple domains or expertise areas.\\\",\\n113 | \\t\\tgroups: [],\\n114 | \\t\\tcustomInstructions:\\n115 | \\t\\t\\t\\\"Your role is to coordinate complex workflows by delegating tasks to specialized modes. As an orchestrator, you should:\\\\n\\\\n1. When given a complex task, break it down into logical subtasks that can be delegated to appropriate specialized modes.\\\\n\\\\n2. For each subtask, use the `new_task` tool to delegate. Choose the most appropriate mode for the subtask's specific goal and provide comprehensive instructions in the `message` parameter. These instructions must include:\\\\n    *   All necessary context from the parent task or previous subtasks required to complete the work.\\\\n    *   A clearly defined scope, specifying exactly what the subtask should accomplish.\\\\n    *   An explicit statement that the subtask should *only* perform the work outlined in these instructions and not deviate.\\\\n    *   An instruction for the subtask to signal completion by using the `attempt_completion` tool, providing a concise yet thorough summary of the outcome in the `result` parameter, keeping in mind that this summary will be the source of truth used to keep track of what was completed on this project.\\\\n    *   A statement that these specific instructions supersede any conflicting general instructions the subtask's mode might have.\\\\n\\\\n3. Track and manage the progress of all subtasks. When a subtask is completed, analyze its results and determine the next steps.\\\\n\\\\n4. Help the user understand how the different subtasks fit together in the overall workflow. Provide clear reasoning about why you're delegating specific tasks to specific modes.\\\\n\\\\n5. When all subtasks are completed, synthesize the results and provide a comprehensive overview of what was accomplished.\\\\n\\\\n6. Ask clarifying questions when necessary to better understand how to break down complex tasks effectively.\\\\n\\\\n7. Suggest improvements to the workflow based on the results of completed subtasks.\\\\n\\\\nUse subtasks to maintain clarity. If a request significantly shifts focus or requires a different expertise (mode), consider creating a subtask rather than overloading the current one.\\\",\\n116 | \\t},\\n117 | ] as const\\n118 | \\n119 | // Export the default mode slug\\n120 | export const defaultModeSlug = modes[0].slug\\n121 | \\n122 | // Helper functions\\n123 | export function getModeBySlug(slug: string, customModes?: ModeConfig[]): ModeConfig | undefined {\\n124 | \\t// Check custom modes first\\n125 | \\tconst customMode = customModes?.find((mode) => mode.slug === slug)\\n126 | \\tif (customMode) {\\n127 | \\t\\treturn customMode\\n128 | \\t}\\n129 | \\t// Then check built-in modes\\n130 | \\treturn modes.find((mode) => mode.slug === slug)\\n131 | }\\n132 | \\n133 | export function getModeConfig(slug: string, customModes?: ModeConfig[]): ModeConfig {\\n134 | \\tconst mode = getModeBySlug(slug, customModes)\\n135 | \\tif (!mode) {\\n136 | \\t\\tthrow new Error(`No mode found for slug: ${slug}`)\\n137 | \\t}\\n138 | \\treturn mode\\n139 | }\\n140 | \\n141 | // Get all available modes, with custom modes overriding built-in modes\\n142 | export function getAllModes(customModes?: ModeConfig[]): ModeConfig[] {\\n143 | \\tif (!customModes?.length) {\\n144 | \\t\\treturn [...modes]\\n145 | \\t}\\n146 | \\n147 | \\t// Start with built-in modes\\n148 | \\tconst allModes = [...modes]\\n149 | \\n150 | \\t// Process custom modes\\n151 | \\tcustomModes.forEach((customMode) => {\\n152 | \\t\\tconst index = allModes.findIndex((mode) => mode.slug === customMode.slug)\\n153 | \\t\\tif (index !== -1) {\\n154 | \\t\\t\\t// Override existing mode\\n155 | \\t\\t\\tallModes[index] = customMode\\n156 | \\t\\t} else {\\n157 | \\t\\t\\t// Add new mode\\n158 | \\t\\t\\tallModes.push(customMode)\\n159 | \\t\\t}\\n160 | \\t})\\n161 | \\n162 | \\treturn allModes\\n163 | }\\n164 | \\n165 | // Check if a mode is custom or an override\\n166 | export function isCustomMode(slug: string, customModes?: ModeConfig[]): boolean {\\n167 | \\treturn !!customModes?.some((mode) => mode.slug === slug)\\n168 | }\\n169 | \\n170 | /**\\n171 |  * Find a mode by its slug, don't fall back to built-in modes\\n172 |  */\\n173 | export function findModeBySlug(slug: string, modes: readonly ModeConfig[] | undefined): ModeConfig | undefined {\\n174 | \\treturn modes?.find((mode) => mode.slug === slug)\\n175 | }\\n176 | \\n177 | /**\\n178 |  * Get the mode selection based on the provided mode slug, prompt component, and custom modes.\\n179 |  * If a custom mode is found, it takes precedence over the built-in modes.\\n180 |  * If no custom mode is found, the built-in mode is used.\\n181 |  * If neither is found, the default mode is used.\\n182 |  */\\n183 | export function getModeSelection(mode: string, promptComponent?: PromptComponent, customModes?: ModeConfig[]) {\\n184 | \\tconst customMode = findModeBySlug(mode, customModes)\\n185 | \\tconst builtInMode = findModeBySlug(mode, modes)\\n186 | \\n187 | \\tconst modeToUse = customMode || promptComponent || builtInMode\\n188 | \\n189 | \\tconst roleDefinition = modeToUse?.roleDefinition || \\\"\\\"\\n190 | \\tconst baseInstructions = modeToUse?.customInstructions || \\\"\\\"\\n191 | \\n192 | \\treturn {\\n193 | \\t\\troleDefinition,\\n194 | \\t\\tbaseInstructions,\\n195 | \\t}\\n196 | }\\n197 | \\n198 | // Custom error class for file restrictions\\n199 | export class FileRestrictionError extends Error {\\n200 | \\tconstructor(mode: string, pattern: string, description: string | undefined, filePath: string) {\\n201 | \\t\\tsuper(\\n202 | \\t\\t\\t`This mode (${mode}) can only edit files matching pattern: ${pattern}${description ? ` (${description})` : \\\"\\\"}. Got: ${filePath}`,\\n203 | \\t\\t)\\n204 | \\t\\tthis.name = \\\"FileRestrictionError\\\"\\n205 | \\t}\\n206 | }\\n207 | \\n208 | export function isToolAllowedForMode(\\n209 | \\ttool: string,\\n210 | \\tmodeSlug: string,\\n211 | \\tcustomModes: ModeConfig[],\\n212 | \\ttoolRequirements?: Record<string, boolean>,\\n213 | \\ttoolParams?: Record<string, any>, // All tool parameters\\n214 | \\texperiments?: Record<string, boolean>,\\n215 | ): boolean {\\n216 | \\t// Always allow these tools\\n217 | \\tif (ALWAYS_AVAILABLE_TOOLS.includes(tool as any)) {\\n218 | \\t\\treturn true\\n219 | \\t}\\n220 | \\tif (experiments && Object.values(EXPERIMENT_IDS).includes(tool as ExperimentId)) {\\n221 | \\t\\tif (!experiments[tool]) {\\n222 | \\t\\t\\treturn false\\n223 | \\t\\t}\\n224 | \\t}\\n225 | \\n226 | \\t// Check tool requirements if any exist\\n227 | \\tif (toolRequirements && typeof toolRequirements === \\\"object\\\") {\\n228 | \\t\\tif (tool in toolRequirements && !toolRequirements[tool]) {\\n229 | \\t\\t\\treturn false\\n230 | \\t\\t}\\n231 | \\t} else if (toolRequirements === false) {\\n232 | \\t\\t// If toolRequirements is a boolean false, all tools are disabled\\n233 | \\t\\treturn false\\n234 | \\t}\\n235 | \\n236 | \\tconst mode = getModeBySlug(modeSlug, customModes)\\n237 | \\tif (!mode) {\\n238 | \\t\\treturn false\\n239 | \\t}\\n240 | \\n241 | \\t// Check if tool is in any of the mode's groups and respects any group options\\n242 | \\tfor (const group of mode.groups) {\\n243 | \\t\\tconst groupName = getGroupName(group)\\n244 | \\t\\tconst options = getGroupOptions(group)\\n245 | \\n246 | \\t\\tconst groupConfig = TOOL_GROUPS[groupName]\\n247 | \\n248 | \\t\\t// If the tool isn't in this group's tools, continue to next group\\n249 | \\t\\tif (!groupConfig.tools.includes(tool)) {\\n250 | \\t\\t\\tcontinue\\n251 | \\t\\t}\\n252 | \\n253 | \\t\\t// If there are no options, allow the tool\\n254 | \\t\\tif (!options) {\\n255 | \\t\\t\\treturn true\\n256 | \\t\\t}\\n257 | \\n258 | \\t\\t// For the edit group, check file regex if specified\\n259 | \\t\\tif (groupName === \\\"edit\\\" && options.fileRegex) {\\n260 | \\t\\t\\tconst filePath = toolParams?.path\\n261 | \\t\\t\\tif (\\n262 | \\t\\t\\t\\tfilePath &&\\n263 | \\t\\t\\t\\t(toolParams.diff || toolParams.content || toolParams.operations) &&\\n264 | \\t\\t\\t\\t!doesFileMatchRegex(filePath, options.fileRegex)\\n265 | \\t\\t\\t) {\\n266 | \\t\\t\\t\\tthrow new FileRestrictionError(mode.name, options.fileRegex, options.description, filePath)\\n267 | \\t\\t\\t}\\n268 | \\t\\t}\\n269 | \\n270 | \\t\\treturn true\\n271 | \\t}\\n272 | \\n273 | \\treturn false\\n274 | }\\n275 | \\n276 | // Create the mode-specific default prompts\\n277 | export const defaultPrompts: Readonly<CustomModePrompts> = Object.freeze(\\n278 | \\tObject.fromEntries(\\n279 | \\t\\tmodes.map((mode) => [\\n280 | \\t\\t\\tmode.slug,\\n281 | \\t\\t\\t{\\n282 | \\t\\t\\t\\troleDefinition: mode.roleDefinition,\\n283 | \\t\\t\\t\\twhenToUse: mode.whenToUse,\\n284 | \\t\\t\\t\\tcustomInstructions: mode.customInstructions,\\n285 | \\t\\t\\t},\\n286 | \\t\\t]),\\n287 | \\t),\\n288 | )\\n289 | \\n290 | // Helper function to get all modes with their prompt overrides from extension state\\n291 | export async function getAllModesWithPrompts(context: vscode.ExtensionContext): Promise<ModeConfig[]> {\\n292 | \\tconst customModes = (await context.globalState.get<ModeConfig[]>(\\\"customModes\\\")) || []\\n293 | \\tconst customModePrompts = (await context.globalState.get<CustomModePrompts>(\\\"customModePrompts\\\")) || {}\\n294 | \\n295 | \\tconst allModes = getAllModes(customModes)\\n296 | \\treturn allModes.map((mode) => ({\\n297 | \\t\\t...mode,\\n298 | \\t\\troleDefinition: customModePrompts[mode.slug]?.roleDefinition ?? mode.roleDefinition,\\n299 | \\t\\twhenToUse: customModePrompts[mode.slug]?.whenToUse ?? mode.whenToUse,\\n300 | \\t\\tcustomInstructions: customModePrompts[mode.slug]?.customInstructions ?? mode.customInstructions,\\n301 | \\t}))\\n302 | }\\n303 | \\n304 | // Helper function to get complete mode details with all overrides\\n305 | export async function getFullModeDetails(\\n306 | \\tmodeSlug: string,\\n307 | \\tcustomModes?: ModeConfig[],\\n308 | \\tcustomModePrompts?: CustomModePrompts,\\n309 | \\toptions?: {\\n310 | \\t\\tcwd?: string\\n311 | \\t\\tglobalCustomInstructions?: string\\n312 | \\t\\tlanguage?: string\\n313 | \\t},\\n314 | ): Promise<ModeConfig> {\\n315 | \\t// First get the base mode config from custom modes or built-in modes\\n316 | \\tconst baseMode = getModeBySlug(modeSlug, customModes) || modes.find((m) => m.slug === modeSlug) || modes[0]\\n317 | \\n318 | \\t// Check for any prompt component overrides\\n319 | \\tconst promptComponent = customModePrompts?.[modeSlug]\\n320 | \\n321 | \\t// Get the base custom instructions\\n322 | \\tconst baseCustomInstructions = promptComponent?.customInstructions || baseMode.customInstructions || \\\"\\\"\\n323 | \\tconst baseWhenToUse = promptComponent?.whenToUse || baseMode.whenToUse || \\\"\\\"\\n324 | \\n325 | \\t// If we have cwd, load and combine all custom instructions\\n326 | \\tlet fullCustomInstructions = baseCustomInstructions\\n327 | \\tif (options?.cwd) {\\n328 | \\t\\tfullCustomInstructions = await addCustomInstructions(\\n329 | \\t\\t\\tbaseCustomInstructions,\\n330 | \\t\\t\\toptions.globalCustomInstructions || \\\"\\\",\\n331 | \\t\\t\\toptions.cwd,\\n332 | \\t\\t\\tmodeSlug,\\n333 | \\t\\t\\t{ language: options.language },\\n334 | \\t\\t)\\n335 | \\t}\\n336 | \\n337 | \\t// Return mode with any overrides applied\\n338 | \\treturn {\\n339 | \\t\\t...baseMode,\\n340 | \\t\\troleDefinition: promptComponent?.roleDefinition || baseMode.roleDefinition,\\n341 | \\t\\twhenToUse: baseWhenToUse,\\n342 | \\t\\tcustomInstructions: fullCustomInstructions,\\n343 | \\t}\\n344 | }\\n345 | \\n346 | // Helper function to safely get role definition\\n347 | export function getRoleDefinition(modeSlug: string, customModes?: ModeConfig[]): string {\\n348 | \\tconst mode = getModeBySlug(modeSlug, customModes)\\n349 | \\tif (!mode) {\\n350 | \\t\\tconsole.warn(`No mode found for slug: ${modeSlug}`)\\n351 | \\t\\treturn \\\"\\\"\\n352 | \\t}\\n353 | \\treturn mode.roleDefinition\\n354 | }\\n355 | \\n356 | // Helper function to safely get whenToUse\\n357 | export function getWhenToUse(modeSlug: string, customModes?: ModeConfig[]): string {\\n358 | \\tconst mode = getModeBySlug(modeSlug, customModes)\\n359 | \\tif (!mode) {\\n360 | \\t\\tconsole.warn(`No mode found for slug: ${modeSlug}`)\\n361 | \\t\\treturn \\\"\\\"\\n362 | \\t}\\n363 | \\treturn mode.whenToUse ?? \\\"\\\"\\n364 | }\\n365 | \\n366 | // Helper function to safely get custom instructions\\n367 | export function getCustomInstructions(modeSlug: string, customModes?: ModeConfig[]): string {\\n368 | \\tconst mode = getModeBySlug(modeSlug, customModes)\\n369 | \\tif (!mode) {\\n370 | \\t\\tconsole.warn(`No mode found for slug: ${modeSlug}`)\\n371 | \\t\\treturn \\\"\\\"\\n372 | \\t}\\n373 | \\treturn mode.customInstructions ?? \\\"\\\"\\n374 | }\\n</content>\\n</file>\\n</files>\\n\\nLoading...\"}"
}
[2025-06-16T20:26:51.978Z] {
  "ts": 1750105611196,
  "type": "say",
  "say": "text",
  "text": "Now let me explore the core implementation to understand how tasks and subtasks work, and where context management happens.",
  "partial": false
}
[2025-06-16T20:26:51.998Z] {
  "ts": 1750105611196,
  "type": "say",
  "say": "text",
  "text": "Now let me explore the core implementation to understand how tasks and subtasks work, and where context management happens.",
  "partial": false
}
[2025-06-16T20:26:52.335Z] {
  "ts": 1750105611998,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"readFile\",\"path\":\"src/extension.ts\",\"isOutsideWorkspace\":false,\"content\":\"/roo/repos/Roo-Code/src/extension.ts\",\"reason\":\"\"}",
  "partial": false
}
[2025-06-16T20:26:52.473Z] {
  "ts": 1750105612470,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[read_file for 'src/extension.ts'. Reading multiple files at once is more efficient for the LLM. If other files are relevant to your current task, please read them simultaneously.] Result:\\n\\n<files>\\n<file><path>src/extension.ts</path>\\n<content lines=\\\"1-202\\\">\\n  1 | import * as vscode from \\\"vscode\\\"\\n  2 | import * as dotenvx from \\\"@dotenvx/dotenvx\\\"\\n  3 | import * as path from \\\"path\\\"\\n  4 | \\n  5 | // Load environment variables from .env file\\n  6 | try {\\n  7 | \\t// Specify path to .env file in the project root directory\\n  8 | \\tconst envPath = path.join(__dirname, \\\"..\\\", \\\".env\\\")\\n  9 | \\tdotenvx.config({ path: envPath })\\n 10 | } catch (e) {\\n 11 | \\t// Silently handle environment loading errors\\n 12 | \\tconsole.warn(\\\"Failed to load environment variables:\\\", e)\\n 13 | }\\n 14 | \\n 15 | import { CloudService } from \\\"@roo-code/cloud\\\"\\n 16 | import { TelemetryService, PostHogTelemetryClient } from \\\"@roo-code/telemetry\\\"\\n 17 | \\n 18 | import \\\"./utils/path\\\" // Necessary to have access to String.prototype.toPosix.\\n 19 | import { createOutputChannelLogger, createDualLogger } from \\\"./utils/outputChannelLogger\\\"\\n 20 | \\n 21 | import { Package } from \\\"./shared/package\\\"\\n 22 | import { formatLanguage } from \\\"./shared/language\\\"\\n 23 | import { ContextProxy } from \\\"./core/config/ContextProxy\\\"\\n 24 | import { ClineProvider } from \\\"./core/webview/ClineProvider\\\"\\n 25 | import { DIFF_VIEW_URI_SCHEME } from \\\"./integrations/editor/DiffViewProvider\\\"\\n 26 | import { TerminalRegistry } from \\\"./integrations/terminal/TerminalRegistry\\\"\\n 27 | import { McpServerManager } from \\\"./services/mcp/McpServerManager\\\"\\n 28 | import { CodeIndexManager } from \\\"./services/code-index/manager\\\"\\n 29 | import { migrateSettings } from \\\"./utils/migrateSettings\\\"\\n 30 | import { API } from \\\"./extension/api\\\"\\n 31 | \\n 32 | import {\\n 33 | \\thandleUri,\\n 34 | \\tregisterCommands,\\n 35 | \\tregisterCodeActions,\\n 36 | \\tregisterTerminalActions,\\n 37 | \\tCodeActionProvider,\\n 38 | } from \\\"./activate\\\"\\n 39 | import { initializeI18n } from \\\"./i18n\\\"\\n 40 | \\n 41 | /**\\n 42 |  * Built using https://github.com/microsoft/vscode-webview-ui-toolkit\\n 43 |  *\\n 44 |  * Inspired by:\\n 45 |  *  - https://github.com/microsoft/vscode-webview-ui-toolkit-samples/tree/main/default/weather-webview\\n 46 |  *  - https://github.com/microsoft/vscode-webview-ui-toolkit-samples/tree/main/frameworks/hello-world-react-cra\\n 47 |  */\\n 48 | \\n 49 | let outputChannel: vscode.OutputChannel\\n 50 | let extensionContext: vscode.ExtensionContext\\n 51 | \\n 52 | // This method is called when your extension is activated.\\n 53 | // Your extension is activated the very first time the command is executed.\\n 54 | export async function activate(context: vscode.ExtensionContext) {\\n 55 | \\textensionContext = context\\n 56 | \\toutputChannel = vscode.window.createOutputChannel(Package.outputChannel)\\n 57 | \\tcontext.subscriptions.push(outputChannel)\\n 58 | \\toutputChannel.appendLine(`${Package.name} extension activated - ${JSON.stringify(Package)}`)\\n 59 | \\n 60 | \\t// Migrate old settings to new\\n 61 | \\tawait migrateSettings(context, outputChannel)\\n 62 | \\n 63 | \\t// Initialize telemetry service.\\n 64 | \\tconst telemetryService = TelemetryService.createInstance()\\n 65 | \\n 66 | \\ttry {\\n 67 | \\t\\ttelemetryService.register(new PostHogTelemetryClient())\\n 68 | \\t} catch (error) {\\n 69 | \\t\\tconsole.warn(\\\"Failed to register PostHogTelemetryClient:\\\", error)\\n 70 | \\t}\\n 71 | \\n 72 | \\t// Create logger for cloud services\\n 73 | \\tconst cloudLogger = createDualLogger(createOutputChannelLogger(outputChannel))\\n 74 | \\n 75 | \\t// Initialize Roo Code Cloud service.\\n 76 | \\tawait CloudService.createInstance(context, {\\n 77 | \\t\\tstateChanged: () => ClineProvider.getVisibleInstance()?.postStateToWebview(),\\n 78 | \\t\\tlog: cloudLogger,\\n 79 | \\t})\\n 80 | \\n 81 | \\t// Initialize i18n for internationalization support\\n 82 | \\tinitializeI18n(context.globalState.get(\\\"language\\\") ?? formatLanguage(vscode.env.language))\\n 83 | \\n 84 | \\t// Initialize terminal shell execution handlers.\\n 85 | \\tTerminalRegistry.initialize()\\n 86 | \\n 87 | \\t// Get default commands from configuration.\\n 88 | \\tconst defaultCommands = vscode.workspace.getConfiguration(Package.name).get<string[]>(\\\"allowedCommands\\\") || []\\n 89 | \\n 90 | \\t// Initialize global state if not already set.\\n 91 | \\tif (!context.globalState.get(\\\"allowedCommands\\\")) {\\n 92 | \\t\\tcontext.globalState.update(\\\"allowedCommands\\\", defaultCommands)\\n 93 | \\t}\\n 94 | \\n 95 | \\tconst contextProxy = await ContextProxy.getInstance(context)\\n 96 | \\tconst codeIndexManager = CodeIndexManager.getInstance(context)\\n 97 | \\n 98 | \\ttry {\\n 99 | \\t\\tawait codeIndexManager?.initialize(contextProxy)\\n100 | \\t} catch (error) {\\n101 | \\t\\toutputChannel.appendLine(\\n102 | \\t\\t\\t`[CodeIndexManager] Error during background CodeIndexManager configuration/indexing: ${error.message || error}`,\\n103 | \\t\\t)\\n104 | \\t}\\n105 | \\n106 | \\tconst provider = new ClineProvider(context, outputChannel, \\\"sidebar\\\", contextProxy, codeIndexManager)\\n107 | \\tTelemetryService.instance.setProvider(provider)\\n108 | \\n109 | \\tif (codeIndexManager) {\\n110 | \\t\\tcontext.subscriptions.push(codeIndexManager)\\n111 | \\t}\\n112 | \\n113 | \\tcontext.subscriptions.push(\\n114 | \\t\\tvscode.window.registerWebviewViewProvider(ClineProvider.sideBarId, provider, {\\n115 | \\t\\t\\twebviewOptions: { retainContextWhenHidden: true },\\n116 | \\t\\t}),\\n117 | \\t)\\n118 | \\n119 | \\tregisterCommands({ context, outputChannel, provider })\\n120 | \\n121 | \\t/**\\n122 | \\t * We use the text document content provider API to show the left side for diff\\n123 | \\t * view by creating a virtual document for the original content. This makes it\\n124 | \\t * readonly so users know to edit the right side if they want to keep their changes.\\n125 | \\t *\\n126 | \\t * This API allows you to create readonly documents in VSCode from arbitrary\\n127 | \\t * sources, and works by claiming an uri-scheme for which your provider then\\n128 | \\t * returns text contents. The scheme must be provided when registering a\\n129 | \\t * provider and cannot change afterwards.\\n130 | \\t *\\n131 | \\t * Note how the provider doesn't create uris for virtual documents - its role\\n132 | \\t * is to provide contents given such an uri. In return, content providers are\\n133 | \\t * wired into the open document logic so that providers are always considered.\\n134 | \\t *\\n135 | \\t * https://code.visualstudio.com/api/extension-guides/virtual-documents\\n136 | \\t */\\n137 | \\tconst diffContentProvider = new (class implements vscode.TextDocumentContentProvider {\\n138 | \\t\\tprovideTextDocumentContent(uri: vscode.Uri): string {\\n139 | \\t\\t\\treturn Buffer.from(uri.query, \\\"base64\\\").toString(\\\"utf-8\\\")\\n140 | \\t\\t}\\n141 | \\t})()\\n142 | \\n143 | \\tcontext.subscriptions.push(\\n144 | \\t\\tvscode.workspace.registerTextDocumentContentProvider(DIFF_VIEW_URI_SCHEME, diffContentProvider),\\n145 | \\t)\\n146 | \\n147 | \\tcontext.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))\\n148 | \\n149 | \\t// Register code actions provider.\\n150 | \\tcontext.subscriptions.push(\\n151 | \\t\\tvscode.languages.registerCodeActionsProvider({ pattern: \\\"**/*\\\" }, new CodeActionProvider(), {\\n152 | \\t\\t\\tprovidedCodeActionKinds: CodeActionProvider.providedCodeActionKinds,\\n153 | \\t\\t}),\\n154 | \\t)\\n155 | \\n156 | \\tregisterCodeActions(context)\\n157 | \\tregisterTerminalActions(context)\\n158 | \\n159 | \\t// Allows other extensions to activate once Roo is ready.\\n160 | \\tvscode.commands.executeCommand(`${Package.name}.activationCompleted`)\\n161 | \\n162 | \\t// Implements the `RooCodeAPI` interface.\\n163 | \\tconst socketPath = process.env.ROO_CODE_IPC_SOCKET_PATH\\n164 | \\tconst enableLogging = typeof socketPath === \\\"string\\\"\\n165 | \\n166 | \\t// Watch the core files and automatically reload the extension host.\\n167 | \\tif (process.env.NODE_ENV === \\\"development\\\") {\\n168 | \\t\\tconst pattern = \\\"**/*.ts\\\"\\n169 | \\n170 | \\t\\tconst watchPaths = [\\n171 | \\t\\t\\t{ path: context.extensionPath, name: \\\"extension\\\" },\\n172 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/types\\\"), name: \\\"types\\\" },\\n173 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/telemetry\\\"), name: \\\"telemetry\\\" },\\n174 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/cloud\\\"), name: \\\"cloud\\\" },\\n175 | \\t\\t]\\n176 | \\n177 | \\t\\tconsole.log(\\n178 | \\t\\t\\t`♻️♻️♻️ Core auto-reloading is ENABLED. Watching for changes in: ${watchPaths.map(({ name }) => name).join(\\\", \\\")}`,\\n179 | \\t\\t)\\n180 | \\n181 | \\t\\twatchPaths.forEach(({ path: watchPath, name }) => {\\n182 | \\t\\t\\tconst watcher = vscode.workspace.createFileSystemWatcher(new vscode.RelativePattern(watchPath, pattern))\\n183 | \\n184 | \\t\\t\\twatcher.onDidChange((uri) => {\\n185 | \\t\\t\\t\\tconsole.log(`♻️ ${name} file changed: ${uri.fsPath}. Reloading host…`)\\n186 | \\t\\t\\t\\tvscode.commands.executeCommand(\\\"workbench.action.reloadWindow\\\")\\n187 | \\t\\t\\t})\\n188 | \\n189 | \\t\\t\\tcontext.subscriptions.push(watcher)\\n190 | \\t\\t})\\n191 | \\t}\\n192 | \\n193 | \\treturn new API(outputChannel, provider, socketPath, enableLogging)\\n194 | }\\n195 | \\n196 | // This method is called when your extension is deactivated.\\n197 | export async function deactivate() {\\n198 | \\toutputChannel.appendLine(`${Package.name} extension deactivated`)\\n199 | \\tawait McpServerManager.cleanup(extensionContext)\\n200 | \\tTelemetryService.instance.shutdown()\\n201 | \\tTerminalRegistry.cleanup()\\n202 | }\\n</content>\\n</file>\\n</files>\\n\\nTool [search_files] was not executed because a tool has already been used in this message. Only one tool may be used per message. You must assess the first tool's result before proceeding to use the next tool.\\n\\nLoading...\"}"
}
[2025-06-16T20:26:55.352Z] {
  "ts": 1750105614873,
  "type": "say",
  "say": "text",
  "text": "Now let me search for files related to task management, context handling, and subtasks to understand the current implementation.",
  "partial": false
}
[2025-06-16T20:26:55.971Z] {
  "ts": 1750105615351,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"searchFiles\",\"path\":\"src\",\"regex\":\"task|subtask|context|token\",\"filePattern\":\"*.ts\",\"isOutsideWorkspace\":false,\"content\":\"Showing first 300 of 300+ results. Use a more specific search if necessary.\\n\\n# src/workers/countTokens.ts\\n  4 | \\n  5 | import { tiktoken } from \\\"../utils/tiktoken\\\"\\n  6 | \\n----\\n 10 | \\ttry {\\n 11 | \\t\\tconst count = await tiktoken(content)\\n 12 | \\t\\treturn { success: true, count }\\n----\\n\\n# src/integrations/editor/DiffViewProvider.ts\\n 12 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n 13 | import { Task } from \\\"../../core/task/Task\\\"\\n 14 | \\n----\\n204 | \\t\\t// directly related to the work he's doing. This eliminates the risk of Roo\\n205 | \\t\\t// going off-task or getting distracted by unrelated issues, which was a problem\\n206 | \\t\\t// with the previous auto-debug approach. Some users' machines may be slow to\\n----\\n268 | \\t */\\n269 | \\tasync pushToolWriteResult(task: Task, cwd: string, isNewFile: boolean): Promise<string> {\\n270 | \\t\\tif (!this.relPath) {\\n----\\n283 | \\t\\t\\t// Send the user feedback\\n284 | \\t\\t\\tawait task.say(\\\"user_feedback_diff\\\", JSON.stringify(say))\\n285 | \\t\\t}\\n----\\n296 | \\t\\t\\t\\t\\t\\t\\\"You do not need to re-read the file, as you have seen all changes\\\",\\n297 | \\t\\t\\t\\t\\t\\t\\\"Proceed with the task using these changes as the new baseline.\\\",\\n298 | \\t\\t\\t\\t\\t\\t...(this.userEdits\\n299 | \\t\\t\\t\\t\\t\\t\\t? [\\n300 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.\\\",\\n301 | \\t\\t\\t\\t\\t\\t\\t\\t]\\n----\\n\\n# src/integrations/terminal/types.ts\\n  9 | \\trunning: boolean\\n 10 | \\ttaskId?: string\\n 11 | \\tprocess?: RooTerminalProcess\\n----\\n\\n# src/integrations/editor/EditorUtils.ts\\n168 | \\t/**\\n169 | \\t * Builds the editor context from the provided text editor or from the active text editor.\\n170 | \\t * The context includes file path, effective selected text, and any diagnostics that intersect with the effective range.\\n171 | \\t *\\n----\\n205 | \\t\\t} catch (error) {\\n206 | \\t\\t\\tconsole.error(\\\"Error getting editor context:\\\", error)\\n207 | \\t\\t\\treturn null\\n----\\n\\n# src/integrations/workspace/WorkspaceTracker.ts\\n  9 | \\n 10 | // Note: this is not a drop-in replacement for listFiles at the start of tasks, since that will be done for Desktops when there is no workspace selected\\n 11 | class WorkspaceTracker {\\n----\\n136 | \\tprivate async addFilePath(filePath: string): Promise<string> {\\n137 | \\t\\t// Allow for some buffer to account for files being created/deleted during a task\\n138 | \\t\\tif (this.filePaths.size >= MAX_INITIAL_FILES * 2) {\\n----\\n\\n# src/integrations/terminal/BaseTerminal.ts\\n 20 | \\n 21 | \\tpublic taskId?: string\\n 22 | \\tpublic process?: RooTerminalProcess\\n----\\n107 | \\t * Cleans the process queue by removing processes that no longer have unretrieved output\\n108 | \\t * or don't belong to the current task\\n109 | \\t */\\n----\\n\\n# src/integrations/misc/extract-text.ts\\n131 | /**\\n132 |  * Truncates multi-line output while preserving context from both the beginning and end.\\n133 |  * When truncation is needed, it keeps 20% of the lines from the start and 80% from the end,\\n----\\n\\n# src/integrations/misc/export-markdown.ts\\n 17 | \\thours = hours ? hours : 12 // the hour '0' should be '12'\\n 18 | \\tconst fileName = `roo_task_${month}-${day}-${year}_${hours}-${minutes}-${seconds}-${ampm}.md`\\n 19 | \\n----\\n\\n# src/integrations/terminal/TerminalRegistry.ts\\n 14 | // too many terminals, we need to keep track of terminals through the life of\\n 15 | // the extension, as well as session specific terminals for the life of a task\\n 16 | // (to get latest unretrieved output).\\n 17 | // Since we have promises keeping track of terminal processes, we get the added\\n 18 | // benefit of keep track of busy terminals even after a task is closed.\\n 19 | \\n----\\n149 | \\t * @param requiredCwd Whether the working directory is required (if false, may reuse any non-busy terminal)\\n150 | \\t * @param taskId Optional task ID to associate with the terminal\\n151 | \\t * @returns A Terminal instance\\n----\\n155 | \\t\\trequiredCwd: boolean = false,\\n156 | \\t\\ttaskId?: string,\\n157 | \\t\\tprovider: RooTerminalProvider = \\\"vscode\\\",\\n----\\n161 | \\n162 | \\t\\t// First priority: Find a terminal already assigned to this task with\\n163 | \\t\\t// matching directory.\\n164 | \\t\\tif (taskId) {\\n165 | \\t\\t\\tterminal = terminals.find((t) => {\\n166 | \\t\\t\\t\\tif (t.busy || t.taskId !== taskId || t.provider !== provider) {\\n167 | \\t\\t\\t\\t\\treturn false\\n----\\n207 | \\n208 | \\t\\tterminal.taskId = taskId\\n209 | \\n----\\n233 | \\t/**\\n234 | \\t * Gets terminals filtered by busy state and optionally by task id.\\n235 | \\t *\\n236 | \\t * @param busy Whether to get busy or non-busy terminals\\n237 | \\t * @param taskId Optional task ID to filter terminals by\\n238 | \\t * @returns Array of Terminal objects\\n239 | \\t */\\n240 | \\tpublic static getTerminals(busy: boolean, taskId?: string): RooTerminal[] {\\n241 | \\t\\treturn this.getAllTerminals().filter((t) => {\\n----\\n246 | \\n247 | \\t\\t\\t// If taskId is provided, also filter by taskId.\\n248 | \\t\\t\\tif (taskId !== undefined && t.taskId !== taskId) {\\n249 | \\t\\t\\t\\treturn false\\n----\\n256 | \\t/**\\n257 | \\t * Gets background terminals (taskId undefined) that have unretrieved output\\n258 | \\t * or are still running.\\n----\\n264 | \\t\\treturn this.getAllTerminals().filter((t) => {\\n265 | \\t\\t\\t// Only get background terminals (taskId undefined).\\n266 | \\t\\t\\tif (t.taskId !== undefined) {\\n267 | \\t\\t\\t\\treturn false\\n----\\n287 | \\t/**\\n288 | \\t * Releases all terminals associated with a task.\\n289 | \\t *\\n290 | \\t * @param taskId The task ID\\n291 | \\t */\\n292 | \\tpublic static releaseTerminalsForTask(taskId: string): void {\\n293 | \\t\\tthis.terminals.forEach((terminal) => {\\n294 | \\t\\t\\tif (terminal.taskId === taskId) {\\n295 | \\t\\t\\t\\tterminal.taskId = undefined\\n296 | \\t\\t\\t}\\n----\\n\\n# src/extension.ts\\n 53 | // Your extension is activated the very first time the command is executed.\\n 54 | export async function activate(context: vscode.ExtensionContext) {\\n 55 | \\textensionContext = context\\n 56 | \\toutputChannel = vscode.window.createOutputChannel(Package.outputChannel)\\n 57 | \\tcontext.subscriptions.push(outputChannel)\\n 58 | \\toutputChannel.appendLine(`${Package.name} extension activated - ${JSON.stringify(Package)}`)\\n----\\n 60 | \\t// Migrate old settings to new\\n 61 | \\tawait migrateSettings(context, outputChannel)\\n 62 | \\n----\\n 75 | \\t// Initialize Roo Code Cloud service.\\n 76 | \\tawait CloudService.createInstance(context, {\\n 77 | \\t\\tstateChanged: () => ClineProvider.getVisibleInstance()?.postStateToWebview(),\\n----\\n 81 | \\t// Initialize i18n for internationalization support\\n 82 | \\tinitializeI18n(context.globalState.get(\\\"language\\\") ?? formatLanguage(vscode.env.language))\\n 83 | \\n----\\n 90 | \\t// Initialize global state if not already set.\\n 91 | \\tif (!context.globalState.get(\\\"allowedCommands\\\")) {\\n 92 | \\t\\tcontext.globalState.update(\\\"allowedCommands\\\", defaultCommands)\\n 93 | \\t}\\n 94 | \\n 95 | \\tconst contextProxy = await ContextProxy.getInstance(context)\\n 96 | \\tconst codeIndexManager = CodeIndexManager.getInstance(context)\\n 97 | \\n 98 | \\ttry {\\n 99 | \\t\\tawait codeIndexManager?.initialize(contextProxy)\\n100 | \\t} catch (error) {\\n----\\n105 | \\n106 | \\tconst provider = new ClineProvider(context, outputChannel, \\\"sidebar\\\", contextProxy, codeIndexManager)\\n107 | \\tTelemetryService.instance.setProvider(provider)\\n----\\n109 | \\tif (codeIndexManager) {\\n110 | \\t\\tcontext.subscriptions.push(codeIndexManager)\\n111 | \\t}\\n112 | \\n113 | \\tcontext.subscriptions.push(\\n114 | \\t\\tvscode.window.registerWebviewViewProvider(ClineProvider.sideBarId, provider, {\\n----\\n118 | \\n119 | \\tregisterCommands({ context, outputChannel, provider })\\n120 | \\n----\\n142 | \\n143 | \\tcontext.subscriptions.push(\\n144 | \\t\\tvscode.workspace.registerTextDocumentContentProvider(DIFF_VIEW_URI_SCHEME, diffContentProvider),\\n----\\n146 | \\n147 | \\tcontext.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))\\n148 | \\n149 | \\t// Register code actions provider.\\n150 | \\tcontext.subscriptions.push(\\n151 | \\t\\tvscode.languages.registerCodeActionsProvider({ pattern: \\\"**/*\\\" }, new CodeActionProvider(), {\\n----\\n155 | \\n156 | \\tregisterCodeActions(context)\\n157 | \\tregisterTerminalActions(context)\\n158 | \\n----\\n170 | \\t\\tconst watchPaths = [\\n171 | \\t\\t\\t{ path: context.extensionPath, name: \\\"extension\\\" },\\n172 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/types\\\"), name: \\\"types\\\" },\\n173 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/telemetry\\\"), name: \\\"telemetry\\\" },\\n174 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/cloud\\\"), name: \\\"cloud\\\" },\\n175 | \\t\\t]\\n----\\n188 | \\n189 | \\t\\t\\tcontext.subscriptions.push(watcher)\\n190 | \\t\\t})\\n----\\n\\n# src/utils/tiktoken.ts\\n  1 | import { Anthropic } from \\\"@anthropic-ai/sdk\\\"\\n  2 | import { Tiktoken } from \\\"tiktoken/lite\\\"\\n  3 | import o200kBase from \\\"tiktoken/encoders/o200k_base\\\"\\n  4 | \\n----\\n  6 | \\n  7 | let encoder: Tiktoken | null = null\\n  8 | \\n  9 | export async function tiktoken(content: Anthropic.Messages.ContentBlockParam[]): Promise<number> {\\n 10 | \\tif (content.length === 0) {\\n----\\n 17 | \\tif (!encoder) {\\n 18 | \\t\\tencoder = new Tiktoken(o200kBase.bpe_ranks, o200kBase.special_tokens, o200kBase.pat_str)\\n 19 | \\t}\\n----\\n 26 | \\t\\t\\tif (text.length > 0) {\\n 27 | \\t\\t\\t\\tconst tokens = encoder.encode(text)\\n 28 | \\t\\t\\t\\ttotalTokens += tokens.length\\n 29 | \\t\\t\\t}\\n----\\n 42 | \\n 43 | \\t// Add a fudge factor to account for the fact that tiktoken is not always\\n 44 | \\t// accurate.\\n----\\n\\n# src/utils/single-completion-handler.ts\\n  5 | /**\\n  6 |  * Enhances a prompt using the configured API without creating a full Cline instance or task history.\\n  7 |  * This is a lightweight alternative that only uses the API's completion functionality.\\n----\\n\\n# src/utils/logging/CompactLogger.ts\\n112 | \\t/**\\n113 | \\t * Combines parent and current metadata with proper context handling\\n114 | \\t * @private\\n----\\n\\n# src/utils/migrateSettings.ts\\n 15 | export async function migrateSettings(\\n 16 | \\tcontext: vscode.ExtensionContext,\\n 17 | \\toutputChannel: vscode.OutputChannel,\\n----\\n 26 | \\ttry {\\n 27 | \\t\\tconst settingsDir = path.join(context.globalStorageUri.fsPath, \\\"settings\\\")\\n 28 | \\n----\\n\\n# src/utils/logging/types.ts\\n 14 | \\tm: string\\n 15 | \\t/** Optional context identifier */\\n 16 | \\tc?: string\\n----\\n 29 | export interface LogMeta {\\n 30 | \\t/** Optional context identifier */\\n 31 | \\tctx?: string\\n----\\n\\n# src/utils/logging/__tests__/CompactLogger.spec.ts\\n147 | \\n148 | \\t\\ttest(\\\"child logger respects parent context when not overridden\\\", () => {\\n149 | \\t\\t\\tconst parentLogger = new CompactLogger(transport, { ctx: \\\"parent\\\" })\\n----\\n\\n# src/api/index.ts\\n 37 | \\tmode?: string\\n 38 | \\ttaskId: string\\n 39 | }\\n----\\n 50 | \\t/**\\n 51 | \\t * Counts tokens for content blocks\\n 52 | \\t * All providers extend BaseProvider which provides a default tiktoken implementation,\\n 53 | \\t * but they can override this to use their native token counting endpoints\\n 54 | \\t *\\n 55 | \\t * @param content The content to count tokens for\\n 56 | \\t * @returns A promise resolving to the token count\\n 57 | \\t */\\n----\\n\\n# src/utils/storage.ts\\n 51 | /**\\n 52 |  * Gets the storage directory path for a task\\n 53 |  */\\n 54 | export async function getTaskDirectoryPath(globalStoragePath: string, taskId: string): Promise<string> {\\n 55 | \\tconst basePath = await getStorageBasePath(globalStoragePath)\\n 56 | \\tconst taskDir = path.join(basePath, \\\"tasks\\\", taskId)\\n 57 | \\tawait fs.mkdir(taskDir, { recursive: true })\\n 58 | \\treturn taskDir\\n 59 | }\\n----\\n\\n# src/api/providers/anthropic-vertex.ts\\n 83 | \\t\\t * This ensures we stay under the 4-block limit while maintaining effective caching\\n 84 | \\t\\t * for the most relevant context.\\n 85 | \\t\\t */\\n----\\n 87 | \\t\\t\\tmodel: id,\\n 88 | \\t\\t\\tmax_tokens: maxTokens ?? ANTHROPIC_DEFAULT_MAX_TOKENS,\\n 89 | \\t\\t\\ttemperature,\\n----\\n107 | \\t\\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n108 | \\t\\t\\t\\t\\t\\tinputTokens: usage.input_tokens || 0,\\n109 | \\t\\t\\t\\t\\t\\toutputTokens: usage.output_tokens || 0,\\n110 | \\t\\t\\t\\t\\t\\tcacheWriteTokens: usage.cache_creation_input_tokens || undefined,\\n111 | \\t\\t\\t\\t\\t\\tcacheReadTokens: usage.cache_read_input_tokens || undefined,\\n112 | \\t\\t\\t\\t\\t}\\n----\\n119 | \\t\\t\\t\\t\\t\\tinputTokens: 0,\\n120 | \\t\\t\\t\\t\\t\\toutputTokens: chunk.usage!.output_tokens || 0,\\n121 | \\t\\t\\t\\t\\t}\\n----\\n189 | \\t\\t\\t\\tmodel: id,\\n190 | \\t\\t\\t\\tmax_tokens: maxTokens,\\n191 | \\t\\t\\t\\ttemperature,\\n----\\n\\n# src/utils/__tests__/enhance-prompt.spec.ts\\n 33 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n 34 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n 35 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n 88 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n 89 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n 90 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n115 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n116 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n117 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n135 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n136 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n137 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n\\n# src/core/prompts/system.ts\\n 29 | async function generatePrompt(\\n 30 | \\tcontext: vscode.ExtensionContext,\\n 31 | \\tcwd: string,\\n----\\n 47 | ): Promise<string> {\\n 48 | \\tif (!context) {\\n 49 | \\t\\tthrow new Error(\\\"Extension context is required for generating system prompt\\\")\\n 50 | \\t}\\n----\\n 59 | \\tconst [modesSection, mcpServersSection] = await Promise.all([\\n 60 | \\t\\tgetModesSection(context),\\n 61 | \\t\\tmodeConfig.groups.some((groupEntry) => getGroupName(groupEntry) === \\\"mcp\\\")\\n----\\n 65 | \\n 66 | \\tconst codeIndexManager = CodeIndexManager.getInstance(context)\\n 67 | \\n----\\n107 | export const SYSTEM_PROMPT = async (\\n108 | \\tcontext: vscode.ExtensionContext,\\n109 | \\tcwd: string,\\n----\\n125 | ): Promise<string> => {\\n126 | \\tif (!context) {\\n127 | \\t\\tthrow new Error(\\\"Extension context is required for generating system prompt\\\")\\n128 | \\t}\\n----\\n180 | \\treturn generatePrompt(\\n181 | \\t\\tcontext,\\n182 | \\t\\tcwd,\\n----\\n\\n# src/core/tools/writeToFileTool.ts\\n  4 | \\n  5 | import { Task } from \\\"../task/Task\\\"\\n  6 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n  8 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  9 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 10 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n----\\n\\n# src/core/prompts/instructions/instructions.ts\\n  9 | \\tdiffStrategy?: DiffStrategy\\n 10 | \\tcontext?: vscode.ExtensionContext\\n 11 | }\\n----\\n 18 | \\t\\tcase \\\"create_mode\\\": {\\n 19 | \\t\\t\\treturn await createModeInstructions(detail.context)\\n 20 | \\t\\t}\\n----\\n\\n# src/core/tools/fetchInstructionsTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { fetchInstructions } from \\\"../prompts/instructions/instructions\\\"\\n----\\n 13 | ) {\\n 14 | \\tconst task: string | undefined = block.params.task\\n 15 | \\tconst sharedMessageProps: ClineSayTool = { tool: \\\"fetchInstructions\\\", content: task }\\n 16 | \\n----\\n 22 | \\t\\t} else {\\n 23 | \\t\\t\\tif (!task) {\\n 24 | \\t\\t\\t\\tcline.consecutiveMistakeCount++\\n 25 | \\t\\t\\t\\tcline.recordToolError(\\\"fetch_instructions\\\")\\n 26 | \\t\\t\\t\\tpushToolResult(await cline.sayAndCreateMissingParamError(\\\"fetch_instructions\\\", \\\"task\\\"))\\n 27 | \\t\\t\\t\\treturn\\n----\\n 31 | \\n 32 | \\t\\t\\tconst completeMessage = JSON.stringify({ ...sharedMessageProps, content: task } satisfies ClineSayTool)\\n 33 | \\t\\t\\tconst didApprove = await askApproval(\\\"tool\\\", completeMessage)\\n----\\n 47 | \\t\\t\\tconst diffStrategy = cline.diffStrategy\\n 48 | \\t\\t\\tconst context = provider?.context\\n 49 | \\t\\t\\tconst content = await fetchInstructions(task, { mcpHub, diffStrategy, context })\\n 50 | \\n 51 | \\t\\t\\tif (!content) {\\n 52 | \\t\\t\\t\\tpushToolResult(formatResponse.toolError(`Invalid instructions request: ${task}`))\\n 53 | \\t\\t\\t\\treturn\\n----\\n\\n# src/core/tools/searchAndReplaceTool.ts\\n  6 | // Internal imports\\n  7 | import { Task } from \\\"../task/Task\\\"\\n  8 | import { AskApproval, HandleError, PushToolResult, RemoveClosingTag, ToolUse } from \\\"../../shared/tools\\\"\\n----\\n 12 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n 13 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 14 | \\n----\\n\\n# src/core/tools/attemptCompletionTool.ts\\n  4 | \\n  5 | import { Task } from \\\"../task/Task\\\"\\n  6 | import {\\n----\\n 49 | \\n 50 | \\t\\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n 51 | \\t\\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n 52 | \\n----\\n 83 | \\t\\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", result, undefined, false)\\n 84 | \\t\\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n 85 | \\t\\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n 86 | \\t\\t\\t\\t}\\n----\\n108 | \\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", result, undefined, false)\\n109 | \\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n110 | \\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n111 | \\t\\t\\t}\\n----\\n119 | \\n120 | \\t\\t\\t\\t// tell the provider to remove the current subtask and resume the previous task in the stack\\n121 | \\t\\t\\t\\tawait cline.providerRef.deref()?.finishSubTask(result)\\n----\\n131 | \\t\\t\\t// cline never happens since yesButtonClicked\\n132 | \\t\\t\\t// will trigger a new task).\\n133 | \\t\\t\\tif (response === \\\"yesButtonClicked\\\") {\\n----\\n150 | \\t\\t\\t\\ttype: \\\"text\\\",\\n151 | \\t\\t\\t\\ttext: `The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.\\\\n<feedback>\\\\n${text}\\\\n</feedback>`,\\n152 | \\t\\t\\t})\\n----\\n\\n# src/core/tools/listCodeDefinitionNamesTool.ts\\n  4 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  5 | import { Task } from \\\"../task/Task\\\"\\n  6 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n  9 | import { parseSourceCodeForDefinitionsTopLevel, parseSourceCodeDefinitionsForFile } from \\\"../../services/tree-sitter\\\"\\n 10 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 11 | \\n----\\n\\n# src/core/tools/searchFilesTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/useMcpToolTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/applyDiffTool.ts\\n  7 | import { getReadablePath } from \\\"../../utils/path\\\"\\n  8 | import { Task } from \\\"../task/Task\\\"\\n  9 | import { ToolUse, RemoveClosingTag, AskApproval, HandleError, PushToolResult } from \\\"../../shared/tools\\\"\\n----\\n 11 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n 12 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 13 | import { unescapeHtmlEntities } from \\\"../../utils/text-normalization\\\"\\n----\\n108 | \\t\\t\\t\\tlet formattedError = \\\"\\\"\\n109 | \\t\\t\\t\\tTelemetryService.instance.captureDiffApplicationError(cline.taskId, currentCount)\\n110 | \\n----\\n\\n# src/core/tools/askFollowupQuestionTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/prompts/instructions/create-mode.ts\\n  5 | \\n  6 | export async function createModeInstructions(context: vscode.ExtensionContext | undefined): Promise<string> {\\n  7 | \\tif (!context) throw new Error(\\\"Missing VSCode Extension Context\\\")\\n  8 | \\n  9 | \\tconst settingsDir = path.join(context.globalStorageUri.fsPath, \\\"settings\\\")\\n 10 | \\tconst customModesPath = path.join(settingsDir, GlobalFileNames.customModes)\\n----\\n 28 | - The following fields are optional but highly recommended:\\n 29 |   * whenToUse: A clear description of when this mode should be selected and what types of tasks it's best suited for. This helps the Orchestrator mode make better decisions.\\n 30 |   * customInstructions: Additional instructions for how the mode should operate\\n----\\n\\n# src/core/tools/browserActionTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/readFileTool.ts\\n  3 | \\n  4 | import { Task } from \\\"../task/Task\\\"\\n  5 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n  8 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  9 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 10 | import { isPathOutsideWorkspace } from \\\"../../utils/pathUtils\\\"\\n----\\n 29 | \\t\\t\\t\\t// Modified part for single file\\n 30 | \\t\\t\\t\\treturn `[${blockName} for '${paths[0]}'. Reading multiple files at once is more efficient for the LLM. If other files are relevant to your current task, please read them simultaneously.]`\\n 31 | \\t\\t\\t} else if (paths.length <= 3) {\\n----\\n 43 | \\t\\t// Modified part for single file (legacy)\\n 44 | \\t\\treturn `[${blockName} for '${blockParams.path}'. Reading multiple files at once is more efficient for the LLM. If other files are relevant to your current task, please read them simultaneously.]`\\n 45 | \\t} else {\\n----\\n\\n# src/core/tools/newTaskTool.ts\\n  3 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  4 | import { Task } from \\\"../task/Task\\\"\\n  5 | import { defaultModeSlug, getModeBySlug } from \\\"../../shared/modes\\\"\\n----\\n 31 | \\t\\t\\t\\tcline.consecutiveMistakeCount++\\n 32 | \\t\\t\\t\\tcline.recordToolError(\\\"new_task\\\")\\n 33 | \\t\\t\\t\\tpushToolResult(await cline.sayAndCreateMissingParamError(\\\"new_task\\\", \\\"mode\\\"))\\n 34 | \\t\\t\\t\\treturn\\n----\\n 38 | \\t\\t\\t\\tcline.consecutiveMistakeCount++\\n 39 | \\t\\t\\t\\tcline.recordToolError(\\\"new_task\\\")\\n 40 | \\t\\t\\t\\tpushToolResult(await cline.sayAndCreateMissingParamError(\\\"new_task\\\", \\\"message\\\"))\\n 41 | \\t\\t\\t\\treturn\\n----\\n 44 | \\t\\t\\tcline.consecutiveMistakeCount = 0\\n 45 | \\t\\t\\t// Un-escape one level of backslashes before '@' for hierarchical subtasks\\n 46 | // Un-escape one level: \\\\\\\\@ -> \\\\@ (removes one backslash for hierarchical subtasks)\\n 47 | \\t\\t\\tconst unescapedMessage = message.replace(/\\\\\\\\\\\\\\\\@/g, \\\"\\\\\\\\@\\\")\\n----\\n 81 | \\n 82 | \\t\\t\\t// Switch mode first, then create new task instance.\\n 83 | \\t\\t\\tawait provider.handleModeSwitch(mode)\\n----\\n 88 | \\t\\t\\tconst newCline = await provider.initClineWithTask(unescapedMessage, undefined, cline)\\n 89 | \\t\\t\\tcline.emit(\\\"taskSpawned\\\", newCline.taskId)\\n 90 | \\n 91 | \\t\\t\\tpushToolResult(`Successfully created new task in ${targetMode.name} mode with message: ${unescapedMessage}`)\\n 92 | \\n 93 | \\t\\t\\t// Set the isPaused flag to true so the parent\\n 94 | \\t\\t\\t// task can wait for the sub-task to finish.\\n 95 | \\t\\t\\tcline.isPaused = true\\n 96 | \\t\\t\\tcline.emit(\\\"taskPaused\\\")\\n 97 | \\n----\\n100 | \\t} catch (error) {\\n101 | \\t\\tawait handleError(\\\"creating new task\\\", error)\\n102 | \\t\\treturn\\n----\\n\\n# src/core/tools/multiApplyDiffTool.ts\\n  7 | import { getReadablePath } from \\\"../../utils/path\\\"\\n  8 | import { Task } from \\\"../task/Task\\\"\\n  9 | import { ToolUse, RemoveClosingTag, AskApproval, HandleError, PushToolResult } from \\\"../../shared/tools\\\"\\n----\\n 11 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n 12 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 13 | import { unescapeHtmlEntities } from \\\"../../utils/text-normalization\\\"\\n----\\n429 | \\n430 | \\t\\t\\t\\t\\tTelemetryService.instance.captureDiffApplicationError(cline.taskId, currentCount)\\n431 | \\n----\\n\\n# src/core/tools/accessMcpResourceTool.ts\\n  2 | import { ToolUse, RemoveClosingTag, AskApproval, HandleError, PushToolResult } from \\\"../../shared/tools\\\"\\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { formatResponse } from \\\"../prompts/responses\\\"\\n----\\n\\n# src/core/prompts/instructions/create-mcp-server.ts\\n 11 | \\n 12 | When creating MCP servers, it's important to understand that they operate in a non-interactive environment. The server cannot initiate OAuth flows, open browser windows, or prompt for user input during runtime. All credentials and authentication tokens must be provided upfront through environment variables in the MCP settings configuration. For example, Spotify's API uses OAuth to get a refresh token for the user, but the MCP server cannot initiate this flow. While you can walk the user through  [truncated...]\\n 13 | \\n----\\n 63 | cd ${await mcpHub.getMcpServersPath()}\\n 64 | npx @modelcontextprotocol/create-server weather-server\\n 65 | cd weather-server\\n 66 | # Install dependencies\\n 67 | npm install axios zod @modelcontextprotocol/sdk\\n 68 | \\\\`\\\\`\\\\`\\n----\\n 76 | \\t\\t\\t\\t...\\n 77 | \\t\\t\\t\\t\\\"type\\\": \\\"module\\\", // added by default, uses ES module syntax (import/export) rather than CommonJS (require/module.exports) (Important to know if you create additional scripts in this server repository like a get-refresh-token.js script)\\n 78 | \\t\\t\\t\\t\\\"scripts\\\": {\\n----\\n 92 | #!/usr/bin/env node\\n 93 | import { McpServer, ResourceTemplate } from \\\"@modelcontextprotocol/sdk/server/mcp.js\\\";\\n 94 | import { StdioServerTransport } from \\\"@modelcontextprotocol/sdk/server/stdio.js\\\";\\n 95 | import { z } from \\\"zod\\\";\\n----\\n316 | \\n317 | The user may not always request the use or creation of MCP servers. Instead, they might provide tasks that can be completed with existing tools. While using the MCP SDK to extend your capabilities can be useful, it's important to understand that this is just one specialized type of task you can accomplish. You should only implement MCP servers when the user explicitly requests it (e.g., \\\"add a tool that...\\\").\\n318 | \\n319 | Remember: The MCP documentation and example provided above are to help you understand and work with existing MCP servers or create new ones when requested by the user. You already have access to tools and capabilities that can be used to accomplish a wide range of tasks.`\\n320 | }\\n----\\n\\n# src/core/tools/switchModeTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/insertContentTool.ts\\n  5 | import { getReadablePath } from \\\"../../utils/path\\\"\\n  6 | import { Task } from \\\"../task/Task\\\"\\n  7 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n  9 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n 10 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 11 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n----\\n\\n# src/core/tools/executeCommandTool.ts\\n  8 | \\n  9 | import { Task } from \\\"../task/Task\\\"\\n 10 | \\n----\\n194 | \\t\\tcallbacks.onNoShellIntegration = async (error: string) => {\\n195 | \\t\\t\\tTelemetryService.instance.captureShellIntegrationError(cline.taskId)\\n196 | \\t\\t\\tshellIntegrationError = error\\n----\\n199 | \\n200 | \\tconst terminal = await TerminalRegistry.getOrCreateTerminal(workingDir, !!customCwd, cline.taskId, terminalProvider)\\n201 | \\n----\\n\\n# src/core/prompts/sections/mcp-servers.ts\\n 74 | <fetch_instructions>\\n 75 | <task>create_mcp_server</task>\\n 76 | </fetch_instructions>`\\n----\\n\\n# src/core/prompts/responses.ts\\n 13 | \\ttoolApprovedWithFeedback: (feedback?: string) =>\\n 14 | \\t\\t`The user approved this operation and provided the following context:\\\\n<feedback>\\\\n${feedback}\\\\n</feedback>`,\\n 15 | \\n----\\n 18 | \\trooIgnoreError: (path: string) =>\\n 19 | \\t\\t`Access to ${path} is blocked by the .rooignore file settings. You must try to continue in the task without using this file, or ask the user to update the .rooignore file.`,\\n 20 | \\n----\\n 27 | \\n 28 | If you have completed the user's task, use the attempt_completion tool.\\n 29 | If you require additional information from the user, use the ask_followup_question tool.\\n 30 | Otherwise, if you have not completed the task and do not need additional information, then proceed with the next step of the task.\\n 31 | (This is an automated message, so do not respond to it conversationally.)`,\\n----\\n206 | <result>\\n207 | I have completed the task...\\n208 | </result>\\n----\\n\\n# src/core/prompts/sections/capabilities.ts\\n 17 | \\t\\tsupportsComputerUse ? \\\", use the browser\\\" : \\\"\\\"\\n 18 | \\t}, read and write files, and ask follow-up questions. These tools help you effectively accomplish a wide range of tasks, such as writing code, making edits or improvements to existing files, understanding the current state of a project, performing system operations, and much more.\\n 19 | - When the user initially gives you a task, a recursive list of all filepaths in the current workspace directory ('${cwd}') will be included in environment_details. This provides an overview of the project's file structure, offering key insights into the project from directory/file names (how developers conceptualize and organize their code) and file extensions (the language used). This can also guide decision-making on which files to explore further. If you need to further explore directories s [truncated...]\\n 20 | \\t\\tcodeIndexManager &&\\n----\\n 27 | \\t}\\n 28 | - You can use search_files to perform regex searches across files in a specified directory, outputting context-rich results that include surrounding lines. This is particularly useful for understanding code patterns, finding specific implementations, or identifying areas that need refactoring.\\n 29 | - You can use the list_code_definition_names tool to get an overview of source code definitions for all files at the top level of a specified directory. This can be particularly useful when you need to understand the broader context and relationships between certain parts of the code. You may need to call this tool multiple times to understand various parts of the codebase related to the task.\\n 30 |     - For example, when asked to make edits or improvements you might analyze the file structure in the initial environment_details to get an overview of the project, then use list_code_definition_names to get further insight using source code definitions for files located in relevant directories, then read_file to examine the contents of relevant files, analyze the code and suggest improvements or make necessary edits, then use ${diffStrategy ? \\\"the apply_diff or write_to_file\\\" : \\\"the write_to_ [truncated...]\\n 31 | - You can use the execute_command tool to run commands on the user's computer whenever you feel it can help accomplish the user's task. When you need to execute a CLI command, you must provide a clear explanation of what the command does. Prefer to execute complex CLI commands over creating executable scripts, since they are more flexible and easier to run. Interactive and long-running commands are allowed, since the commands are run in the user's VSCode terminal. The user may keep commands runn [truncated...]\\n 32 | \\t\\tsupportsComputerUse\\n 33 | \\t\\t\\t? \\\"\\\\n- You can use the browser_action tool to interact with websites (including html files and locally running development servers) through a Puppeteer-controlled browser when you feel it is necessary in accomplishing the user's task. This tool is particularly useful for web development tasks as it allows you to launch a browser, navigate to pages, interact with elements through clicks and keyboard input, and capture the results through screenshots and console logs. This tool may be useful at [truncated...]\\n 34 | \\t\\t\\t: \\\"\\\"\\n----\\n 37 | \\t\\t\\t? `\\n 38 | - You have access to MCP servers that may provide additional tools and resources. Each server may provide different capabilities that you can use to accomplish tasks more effectively.\\n 39 | `\\n----\\n\\n# src/core/tools/__tests__/newTaskTool.test.ts\\n 11 | // Define a minimal type for the resolved value\\n 12 | type MockClineInstance = { taskId: string }\\n 13 | // Make initClineWithTask return a mock Cline-like object with taskId, providing type hint\\n 14 | const mockInitClineWithTask = jest\\n 15 | \\t.fn<() => Promise<MockClineInstance>>()\\n 16 | \\t.mockResolvedValue({ taskId: \\\"mock-subtask-id\\\" })\\n 17 | const mockEmit = jest.fn()\\n----\\n 66 | \\n 67 | \\tit(\\\"should correctly un-escape \\\\\\\\\\\\\\\\@ to \\\\\\\\@ in the message passed to the new task\\\", async () => {\\n 68 | \\t\\tconst block: ToolUse = {\\n 69 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n 70 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n 71 | \\t\\t\\tparams: {\\n----\\n 97 | \\t\\t// Verify side effects\\n 98 | \\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\\"taskSpawned\\\", expect.any(String)) // Assuming initCline returns a mock task ID\\n 99 | \\t\\texpect(mockCline.isPaused).toBe(true)\\n100 | \\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\\"taskPaused\\\")\\n101 | \\t\\texpect(mockPushToolResult).toHaveBeenCalledWith(expect.stringContaining(\\\"Successfully created new task\\\"))\\n102 | \\t})\\n----\\n106 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n107 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n108 | \\t\\t\\tparams: {\\n----\\n133 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n134 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n135 | \\t\\t\\tparams: {\\n----\\n160 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n161 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n162 | \\t\\t\\tparams: {\\n----\\n\\n# src/core/tools/__tests__/writeToFileTool.test.ts\\n145 | \\t\\t\\t\\tthis: any,\\n146 | \\t\\t\\t\\ttask: any,\\n147 | \\t\\t\\t\\tcwd: string,\\n----\\n151 | \\t\\t\\t\\tif (this.userEdits) {\\n152 | \\t\\t\\t\\t\\tawait task.say(\\n153 | \\t\\t\\t\\t\\t\\t\\\"user_feedback_diff\\\",\\n----\\n\\n# src/core/tools/__tests__/useMcpToolTool.test.ts\\n  1 | import { useMcpToolTool } from \\\"../useMcpToolTool\\\"\\n  2 | import { Task } from \\\"../../task/Task\\\"\\n  3 | import { ToolUse } from \\\"../../../shared/tools\\\"\\n----\\n\\n# src/core/tools/__tests__/executeCommandTool.spec.ts\\n  6 | \\n  7 | import { Task } from \\\"../../task/Task\\\"\\n  8 | import { formatResponse } from \\\"../../prompts/responses\\\"\\n----\\n 16 | \\n 17 | vitest.mock(\\\"../../task/Task\\\")\\n 18 | vitest.mock(\\\"../../prompts/responses\\\")\\n----\\n\\n# src/core/prompts/sections/modes.ts\\n  8 | \\n  9 | export async function getModesSection(context: vscode.ExtensionContext): Promise<string> {\\n 10 | \\tconst settingsDir = path.join(context.globalStorageUri.fsPath, \\\"settings\\\")\\n 11 | \\tawait fs.mkdir(settingsDir, { recursive: true })\\n----\\n 13 | \\t// Get all modes with their overrides from extension state\\n 14 | \\tconst allModes = await getAllModesWithPrompts(context)\\n 15 | \\n----\\n 37 | <fetch_instructions>\\n 38 | <task>create_mode</task>\\n 39 | </fetch_instructions>\\n----\\n\\n# src/core/tools/__tests__/attemptCompletionTool.experiment.test.ts\\n  1 | import { Task } from \\\"../../task/Task\\\"\\n  2 | import { attemptCompletionTool } from \\\"../attemptCompletionTool\\\"\\n----\\n 49 | \\t\\t\\tuserMessageContent: [],\\n 50 | \\t\\t\\ttaskId: \\\"test-task-id\\\",\\n 51 | \\t\\t\\tproviderRef: {\\n----\\n103 | \\t\\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\n104 | \\t\\t\\t\\t\\\"taskCompleted\\\",\\n105 | \\t\\t\\t\\tmockCline.taskId,\\n106 | \\t\\t\\t\\texpect.any(Object),\\n----\\n146 | \\t\\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\n147 | \\t\\t\\t\\t\\\"taskCompleted\\\",\\n148 | \\t\\t\\t\\tmockCline.taskId,\\n149 | \\t\\t\\t\\texpect.any(Object),\\n----\\n224 | \\t\\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\n225 | \\t\\t\\t\\t\\\"taskCompleted\\\",\\n226 | \\t\\t\\t\\tmockCline.taskId,\\n227 | \\t\\t\\t\\texpect.any(Object),\\n----\\n\\n# src/core/prompts/sections/tool-use.ts\\n  5 | \\n  6 | You have access to a set of tools that are executed upon the user's approval. You can use one tool per message, and will receive the result of that tool use in the user's response. You use tools step-by-step to accomplish a given task, with each tool use informed by the result of the previous tool use.\\n  7 | \\n----\\n 17 | \\n 18 | For example, to use the new_task tool:\\n 19 | \\n 20 | <new_task>\\n 21 | <mode>code</mode>\\n 22 | <message>Implement a new feature for the application.</message>\\n 23 | </new_task>\\n 24 | \\n----\\n\\n# src/core/prompts/sections/system-info.ts\\n 15 | \\n 16 | The Current Workspace Directory is the active VS Code project directory, and is therefore the default directory for all tool operations. New terminals will be created in the current workspace directory, however if you change directories in a terminal it will then have a different working directory; changing directories in a terminal does not modify the workspace directory, because you do not have access to change the workspace directory. When the user initially gives you a task, a recursive list [truncated...]\\n 17 | \\n----\\n\\n# src/core/prompts/sections/__tests__/tool-use-guidelines.test.ts\\n 24 | \\t\\t\\texpect(guidelines).toContain(\\n 25 | \\t\\t\\t\\t\\\"IMPORTANT: When starting a new task or when you need to understand existing code/functionality, you MUST use the `codebase_search` tool FIRST\\\",\\n 26 | \\t\\t\\t)\\n----\\n 52 | \\t\\t\\texpect(guidelines).not.toContain(\\n 53 | \\t\\t\\t\\t\\\"IMPORTANT: When starting a new task or when you need to understand existing code/functionality, you MUST use the `codebase_search` tool FIRST\\\",\\n 54 | \\t\\t\\t)\\n----\\n\\n# src/core/prompts/sections/rules.ts\\n 69 | - All file paths must be relative to this directory. However, commands may change directories in terminals, so respect working directory specified by the response to <execute_command>.\\n 70 | - You cannot \\\\`cd\\\\` into a different directory to complete a task. You are stuck operating from '${cwd.toPosix()}', so be sure to pass in the correct 'path' parameter when using tools that require a path.\\n 71 | - Do not use the ~ character or $HOME to refer to the home directory.\\n 72 | - Before using the execute_command tool, you must first think about the SYSTEM INFORMATION context provided to understand the user's environment and tailor your commands to ensure they are compatible with their system. You must also consider if the command you need to run should be executed in a specific directory outside of the current working directory '${cwd.toPosix()}', and if so prepend with \\\\`cd\\\\`'ing into that directory && then executing the command (as one command since you are stuck ope [truncated...]\\n 73 | ${codebaseSearchRule}- When using the search_files tool${isCodebaseSearchAvailable ? \\\" (after codebase_search)\\\" : \\\"\\\"}, craft your regex patterns carefully to balance specificity and flexibility. Based on the user's task you may use it to find code patterns, TODO comments, function definitions, or any text-based information across the project. The results include context, so analyze the surrounding code to better understand the matches. Leverage the search_files tool in combination with other too [truncated...]\\n 74 | - When creating a new project (such as an app, website, or any software project), organize all new files within a dedicated project directory unless the user specifies otherwise. Use appropriate file paths when writing files, as the write_to_file tool will automatically create any necessary directories. Structure the project logically, adhering to best practices for the specific type of project being created. Unless otherwise specified, new projects should be easily run without additional setup, [truncated...]\\n----\\n 76 | - Some modes have restrictions on which files they can edit. If you attempt to edit a restricted file, the operation will be rejected with a FileRestrictionError that will specify which file patterns are allowed for the current mode.\\n 77 | - Be sure to consider the type of project (e.g. Python, JavaScript, web application) when determining the appropriate structure and files to include. Also consider what files may be most relevant to accomplishing the task, for example looking at a project's manifest file would help you understand the project's dependencies, which you could incorporate into any code you write.\\n 78 |   * For example, in architect mode trying to edit app.js would be rejected because architect mode can only edit files matching \\\"\\\\\\\\.md$\\\"\\n 79 | - When making changes to code, always consider the context in which the code is being used. Ensure that your changes are compatible with the existing codebase and that they follow the project's coding standards and best practices.\\n 80 | - Do not ask for more information than necessary. Use the tools provided to accomplish the user's request efficiently and effectively. When you've completed your task, you must use the attempt_completion tool to present the result to the user. The user may provide feedback, which you can use to make improvements and try again.\\n 81 | - You are only allowed to ask the user questions using the ask_followup_question tool. Use this tool only when you need additional details to complete a task, and be sure to use a clear and concise question that will help you move forward with the task. When you ask a question, provide the user with 2-4 suggested answers based on your question so they don't need to do so much typing. The suggestions should be specific, actionable, and directly related to the completed task. They should be ordere [truncated...]\\n 82 | - When executing commands, if you don't see the expected output, assume the terminal executed the command successfully and proceed with the task. The user's terminal may be unable to stream the output back properly. If you absolutely need to see the actual terminal output, use the ask_followup_question tool to request the user to copy and paste it back to you.\\n 83 | - The user may provide a file's contents directly in their message, in which case you shouldn't use the read_file tool to get the file contents again since you already have it.\\n 84 | - Your goal is to try to accomplish the user's task, NOT engage in a back and forth conversation.${\\n 85 | \\t\\tsupportsComputerUse\\n 86 | \\t\\t\\t? '\\\\n- The user may ask generic non-development tasks, such as \\\"what\\\\'s the latest news\\\" or \\\"look up the weather in San Diego\\\", in which case you might use the browser_action tool to complete the task if it makes sense to do so, rather than trying to create a website or using curl to answer the question. However, if an available MCP server tool or resource can be used instead, you should prefer to use it over browser_action.'\\n 87 | \\t\\t\\t: \\\"\\\"\\n----\\n 90 | - You are STRICTLY FORBIDDEN from starting your messages with \\\"Great\\\", \\\"Certainly\\\", \\\"Okay\\\", \\\"Sure\\\". You should NOT be conversational in your responses, but rather direct and to the point. For example you should NOT say \\\"Great, I've updated the CSS\\\" but instead something like \\\"I've updated the CSS\\\". It is important you be clear and technical in your messages.\\n 91 | - When presented with images, utilize your vision capabilities to thoroughly examine them and extract meaningful information. Incorporate these insights into your thought process as you accomplish the user's task.\\n 92 | - At the end of each user message, you will automatically receive environment_details. This information is not written by the user themselves, but is auto-generated to provide potentially relevant context about the project structure and environment. While this information can be valuable for understanding the project context, do not treat it as a direct part of the user's request or response. Use it to inform your actions and decisions, but don't assume the user is explicitly asking about or ref [truncated...]\\n 93 | - Before executing commands, check the \\\"Actively Running Terminals\\\" section in environment_details. If present, consider how these active processes might impact your task. For example, if a local development server is already running, you wouldn't need to start it again. If no active terminals are listed, proceed with command execution as normal.\\n 94 | - MCP operations should be used one at a time, similar to other tool usage. Wait for confirmation of success before proceeding with additional operations.\\n----\\n\\n# src/core/prompts/sections/__tests__/objective.test.ts\\n 24 | \\t\\t\\texpect(objective).toContain(\\n 25 | \\t\\t\\t\\t\\\"if the task involves understanding existing code or functionality, you MUST use the `codebase_search` tool\\\",\\n 26 | \\t\\t\\t)\\n----\\n 46 | \\t\\tfor (const objective of [objectiveEnabled, objectiveDisabled]) {\\n 47 | \\t\\t\\texpect(objective).toContain(\\\"1. Analyze the user's task\\\")\\n 48 | \\t\\t\\texpect(objective).toContain(\\\"2. Work through these goals sequentially\\\")\\n 49 | \\t\\t\\texpect(objective).toContain(\\\"3. Remember, you have extensive capabilities\\\")\\n 50 | \\t\\t\\texpect(objective).toContain(\\\"4. Once you've completed the user's task\\\")\\n 51 | \\t\\t\\texpect(objective).toContain(\\\"5. The user may provide feedback\\\")\\n----\\n\\n# src/core/tools/codebaseSearchTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { CodeIndexManager } from \\\"../../services/code-index/manager\\\"\\n----\\n 66 | \\ttry {\\n 67 | \\t\\tconst context = cline.providerRef.deref()?.context\\n 68 | \\t\\tif (!context) {\\n 69 | \\t\\t\\tthrow new Error(\\\"Extension context is not available.\\\")\\n 70 | \\t\\t}\\n 71 | \\n 72 | \\t\\tconst manager = CodeIndexManager.getInstance(context)\\n 73 | \\n----\\n\\n# src/core/tools/listFilesTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n\\n# src/core/prompts/sections/tool-use-guidelines.ts\\n 15 | \\tguidelinesList.push(\\n 16 | \\t\\t`${itemNumber++}. In <thinking> tags, assess what information you already have and what information you need to proceed with the task.`,\\n 17 | \\t)\\n----\\n 21 | \\t\\tguidelinesList.push(\\n 22 | \\t\\t\\t`${itemNumber++}. **IMPORTANT: When starting a new task or when you need to understand existing code/functionality, you MUST use the \\\\`codebase_search\\\\` tool FIRST before any other search tools.** This semantic search tool helps you find relevant code based on meaning rather than just keywords. Only after using codebase_search should you use other tools like search_files, list_files, or read_file for more specific exploration.`,\\n 23 | \\t\\t)\\n 24 | \\t\\tguidelinesList.push(\\n 25 | \\t\\t\\t`${itemNumber++}. Choose the most appropriate tool based on the task and the tool descriptions provided. Assess if you need additional information to proceed, and which of the available tools would be most effective for gathering this information. For example using the list_files tool is more effective than running a command like \\\\`ls\\\\` in the terminal. It's critical that you think about each available tool and use the one that best fits the current step in the task.`,\\n 26 | \\t\\t)\\n----\\n 28 | \\t\\tguidelinesList.push(\\n 29 | \\t\\t\\t`${itemNumber++}. Choose the most appropriate tool based on the task and the tool descriptions provided. Assess if you need additional information to proceed, and which of the available tools would be most effective for gathering this information. For example using the list_files tool is more effective than running a command like \\\\`ls\\\\` in the terminal. It's critical that you think about each available tool and use the one that best fits the current step in the task.`,\\n 30 | \\t\\t)\\n----\\n 34 | \\tguidelinesList.push(\\n 35 | \\t\\t`${itemNumber++}. If multiple actions are needed, use one tool at a time per message to accomplish the task iteratively, with each tool use being informed by the result of the previous tool use. Do not assume the outcome of any tool use. Each step must be informed by the previous step's result.`,\\n 36 | \\t)\\n 37 | \\tguidelinesList.push(`${itemNumber++}. Formulate your tool use using the XML format specified for each tool.`)\\n 38 | \\tguidelinesList.push(`${itemNumber++}. After each tool use, the user will respond with the result of that tool use. This result will provide you with the necessary information to continue your task or make further decisions. This response may include:\\n 39 |   - Information about whether the tool succeeded or failed, along with any reasons for failure.\\n----\\n 51 | \\n 52 | It is crucial to proceed step-by-step, waiting for the user's message after each tool use before moving forward with the task. This approach allows you to:\\n 53 | 1. Confirm the success of each step before proceeding.\\n----\\n 57 | \\n 58 | By waiting for and carefully considering the user's response after each tool use, you can react accordingly and make informed decisions about how to proceed with the task. This iterative process helps ensure the overall success and accuracy of your work.`\\n 59 | }\\n----\\n\\n# src/core/prompts/sections/objective.ts\\n 14 | \\tconst codebaseSearchInstruction = isCodebaseSearchAvailable\\n 15 | \\t\\t? \\\"First, if the task involves understanding existing code or functionality, you MUST use the `codebase_search` tool to search for relevant code based on the task's intent BEFORE using any other search or file exploration tools. Then, \\\"\\n 16 | \\t\\t: \\\"First, \\\"\\n----\\n 21 | \\tconst commandInstruction = !isCommandDisabled\\n 22 | \\t\\t? \\\" You may also provide a CLI command to showcase the result of your task; this can be particularly useful for web development tasks, where you can run e.g. \\\\`open index.html\\\\` to show the website you've built.\\\"\\n 23 | \\t\\t: \\\"\\\"\\n----\\n 28 | \\n 29 | You accomplish a given task iteratively, breaking it down into clear steps and working through them methodically.\\n 30 | \\n 31 | 1. Analyze the user's task and set clear, achievable goals to accomplish it. Prioritize these goals in a logical order.\\n 32 | 2. Work through these goals sequentially, utilizing available tools one at a time as necessary. Each goal should correspond to a distinct step in your problem-solving process. You will be informed on the work completed and what's remaining as you go.\\n 33 | 3. Remember, you have extensive capabilities with access to a wide range of tools that can be used in powerful and clever ways as necessary to accomplish each goal. Before calling a tool, do some analysis within <thinking></thinking> tags. ${codebaseSearchInstruction}analyze the file structure provided in environment_details to gain context and insights for proceeding effectively. Next, think about which of the provided tools is the most relevant tool to accomplish the user's task. Go through ea [truncated...]\\n 34 | 4. Once you've completed the user's task, you must use the attempt_completion tool to present the result of the task to the user.${commandInstruction}\\n 35 | 5. The user may provide feedback, which you can use to make improvements and try again. But DO NOT continue in pointless back and forth conversations, i.e. don't end your responses with questions or offers for further assistance.`\\n----\\n\\n# src/api/providers/human-relay.ts\\n 69 | \\t\\t\\t\\tmaxTokens: 16384,\\n 70 | \\t\\t\\t\\tcontextWindow: 100000,\\n 71 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n\\n# src/core/prompts/tools/read-file.ts\\n 73 | - ${isMultipleReadsEnabled ? `You MUST read all related files and implementations together in a single operation (up to ${maxConcurrentReads} files at once)` : \\\"You MUST read files one at a time, as multiple file reads are currently disabled\\\"}\\n 74 | - You MUST obtain all necessary context before proceeding with changes\\n 75 | ${\\n----\\n 79 | - You MUST use multiple ranges for content separated by >10 lines\\n 80 | - You MUST include sufficient line context for planned modifications while keeping ranges minimal\\n 81 | `\\n----\\n\\n# src/core/tools/__tests__/readFileTool.test.ts\\n120 | \\t\\tmockCline.cwd = \\\"/\\\"\\n121 | \\t\\tmockCline.task = \\\"Test\\\"\\n122 | \\t\\tmockCline.providerRef = mockProvider\\n----\\n429 | \\t\\tmockCline.cwd = \\\"/\\\"\\n430 | \\t\\tmockCline.task = \\\"Test\\\"\\n431 | \\t\\tmockCline.providerRef = mockProvider\\n----\\n961 | \\t\\t\\texpect(result).toBe(\\n962 | \\t\\t\\t\\t`<files>\\\\n<file><path>${testFilePath}</path><error>Access to ${testFilePath} is blocked by the .rooignore file settings. You must try to continue in the task without using this file, or ask the user to update the .rooignore file.</error></file>\\\\n</files>`,\\n963 | \\t\\t\\t)\\n----\\n\\n# src/api/providers/base-provider.ts\\n 21 | \\t/**\\n 22 | \\t * Default token counting implementation using tiktoken.\\n 23 | \\t * Providers can override this to use their native token counting endpoints.\\n 24 | \\t *\\n 25 | \\t * @param content The content to count tokens for\\n 26 | \\t * @returns A promise resolving to the token count\\n 27 | \\t */\\n----\\n\\n# src/core/prompts/tools/attempt-completion.ts\\n  9 | \\tconst baseDescription = `## attempt_completion\\n 10 | Description: After each tool use, the user will respond with the result of that tool use, i.e. if it succeeded or failed, along with any reasons for failure. Once you've received the results of tool uses and can confirm that the task is complete, use this tool to present the result of your work to the user.${!isCommandDisabled ? \\\" Optionally you may provide a CLI command to showcase the result of your work.\\\" : \\\"\\\"} The user may respond with feedback if they are not satisfied with the result, whic [truncated...]\\n 11 | IMPORTANT NOTE: This tool CANNOT be used until you've confirmed from the user that any previous tool uses were successful. Failure to do so will result in code corruption and system failure. Before using this tool, you must ask yourself in <thinking></thinking> tags if you've confirmed from the user that any previous tool uses were successful. If not, then DO NOT use this tool.\\n 12 | Parameters:\\n 13 | - result: (required) The result of the task. Formulate this result in a way that is final and does not require further input from the user. Don't end your result with questions or offers for further assistance.`\\n 14 | \\n----\\n\\n# src/core/assistant-message/__tests__/parseAssistantMessage.test.ts\\n294 | \\t\\t\\tit(\\\"should handle a complex message with multiple content types\\\", () => {\\n295 | \\t\\t\\t\\tconst message = `I'll help you with that task.\\n296 | \\n----\\n315 | \\t\\t\\t\\texpect(result[0].type).toBe(\\\"text\\\")\\n316 | \\t\\t\\t\\texpect((result[0] as TextContent).content).toBe(\\\"I'll help you with that task.\\\")\\n317 | \\n----\\n\\n# src/core/assistant-message/presentAssistantMessage.ts\\n 31 | import { validateToolUse } from \\\"../tools/validateToolUse\\\"\\n 32 | import { Task } from \\\"../task/Task\\\"\\n 33 | import { codebaseSearchTool } from \\\"../tools/codebaseSearchTool\\\"\\n----\\n 55 | \\tif (cline.abort) {\\n 56 | \\t\\tthrow new Error(`[Task#presentAssistantMessage] task ${cline.taskId}.${cline.instanceId} aborted`)\\n 57 | \\t}\\n----\\n159 | \\t\\t\\t\\t\\tcase \\\"fetch_instructions\\\":\\n160 | \\t\\t\\t\\t\\t\\treturn `[${block.name} for '${block.params.task}']`\\n161 | \\t\\t\\t\\t\\tcase \\\"write_to_file\\\":\\n----\\n207 | \\t\\t\\t\\t\\t\\treturn `[${block.name} for '${block.params.query}']`\\n208 | \\t\\t\\t\\t\\tcase \\\"new_task\\\": {\\n209 | \\t\\t\\t\\t\\t\\tconst mode = block.params.mode ?? defaultModeSlug\\n----\\n295 | \\t\\t\\tconst askFinishSubTaskApproval = async () => {\\n296 | \\t\\t\\t\\t// Ask the user to approve this task has completed, and he has\\n297 | \\t\\t\\t\\t// reviewed it, and we can declare task is finished and return\\n298 | \\t\\t\\t\\t// control to the parent task to continue running the rest of\\n299 | \\t\\t\\t\\t// the sub-tasks.\\n300 | \\t\\t\\t\\tconst toolMessage = JSON.stringify({ tool: \\\"finishTask\\\" })\\n----\\n347 | \\t\\t\\t\\tcline.recordToolUsage(block.name)\\n348 | \\t\\t\\t\\tTelemetryService.instance.captureToolUsage(cline.taskId, block.name)\\n349 | \\t\\t\\t}\\n----\\n395 | \\t\\t\\t\\t\\t\\t// Track tool repetition in telemetry.\\n396 | \\t\\t\\t\\t\\t\\tTelemetryService.instance.captureConsecutiveMistakeError(cline.taskId)\\n397 | \\t\\t\\t\\t\\t}\\n----\\n503 | \\t\\t\\t\\t\\tbreak\\n504 | \\t\\t\\t\\tcase \\\"new_task\\\":\\n505 | \\t\\t\\t\\t\\tawait newTaskTool(cline, block, askApproval, handleError, pushToolResult, removeClosingTag)\\n----\\n\\n# src/api/providers/deepseek.ts\\n 32 | \\t\\t\\ttype: \\\"usage\\\",\\n 33 | \\t\\t\\tinputTokens: usage?.prompt_tokens || 0,\\n 34 | \\t\\t\\toutputTokens: usage?.completion_tokens || 0,\\n 35 | \\t\\t\\tcacheWriteTokens: usage?.prompt_tokens_details?.cache_miss_tokens,\\n 36 | \\t\\t\\tcacheReadTokens: usage?.prompt_tokens_details?.cached_tokens,\\n 37 | \\t\\t}\\n----\\n\\n# src/core/prompts/tools/fetch-instructions.ts\\n  2 | \\treturn `## fetch_instructions\\n  3 | Description: Request to fetch instructions to perform a task\\n  4 | Parameters:\\n  5 | - task: (required) The task to get instructions for.  This can take the following values:\\n  6 |   create_mcp_server\\n----\\n 11 | <fetch_instructions>\\n 12 | <task>create_mcp_server</task>\\n 13 | </fetch_instructions>`\\n----\\n\\n# src/api/providers/ollama.ts\\n 79 | \\t\\t\\t\\ttype: \\\"usage\\\",\\n 80 | \\t\\t\\t\\tinputTokens: lastUsage?.prompt_tokens || 0,\\n 81 | \\t\\t\\t\\toutputTokens: lastUsage?.completion_tokens || 0,\\n 82 | \\t\\t\\t}\\n----\\n\\n# src/core/prompts/tools/ask-followup-question.ts\\n  2 | \\treturn `## ask_followup_question\\n  3 | Description: Ask the user a question to gather additional information needed to complete the task. This tool should be used when you encounter ambiguities, need clarification, or require more details to proceed effectively. It allows for interactive problem-solving by enabling direct communication with the user. Use this tool judiciously to maintain a balance between gathering necessary information and avoiding excessive back-and-forth.\\n  4 | Parameters:\\n----\\n  7 |   1. Be provided in its own <suggest> tag\\n  8 |   2. Be specific, actionable, and directly related to the completed task\\n  9 |   3. Be a complete answer to the question - the user should not need to provide additional information or fill in any missing details. DO NOT include placeholders with brackets or parentheses.\\n----\\n\\n# src/utils/__tests__/cost.spec.ts\\n 11 | \\t\\t\\tmaxTokens: 8192,\\n 12 | \\t\\t\\tcontextWindow: 200_000,\\n 13 | \\t\\t\\tsupportsPromptCache: true,\\n 14 | \\t\\t\\tinputPrice: 3.0, // $3 per million tokens\\n 15 | \\t\\t\\toutputPrice: 15.0, // $15 per million tokens\\n 16 | \\t\\t\\tcacheWritesPrice: 3.75, // $3.75 per million tokens\\n 17 | \\t\\t\\tcacheReadsPrice: 0.3, // $0.30 per million tokens\\n 18 | \\t\\t}\\n----\\n 62 | \\t\\t\\t\\tmaxTokens: 8192,\\n 63 | \\t\\t\\t\\tcontextWindow: 200_000,\\n 64 | \\t\\t\\t\\tsupportsPromptCache: true,\\n----\\n 70 | \\n 71 | \\t\\tit(\\\"should handle zero tokens\\\", () => {\\n 72 | \\t\\t\\tconst cost = calculateApiCostAnthropic(mockModelInfo, 0, 0, 0, 0)\\n----\\n104 | \\t\\t\\tmaxTokens: 8192,\\n105 | \\t\\t\\tcontextWindow: 200_000,\\n106 | \\t\\t\\tsupportsPromptCache: true,\\n107 | \\t\\t\\tinputPrice: 3.0, // $3 per million tokens\\n108 | \\t\\t\\toutputPrice: 15.0, // $15 per million tokens\\n109 | \\t\\t\\tcacheWritesPrice: 3.75, // $3.75 per million tokens\\n110 | \\t\\t\\tcacheReadsPrice: 0.3, // $0.30 per million tokens\\n111 | \\t\\t}\\n----\\n155 | \\t\\t\\t\\tmaxTokens: 8192,\\n156 | \\t\\t\\t\\tcontextWindow: 200_000,\\n157 | \\t\\t\\t\\tsupportsPromptCache: true,\\n----\\n163 | \\n164 | \\t\\tit(\\\"should handle zero tokens\\\", () => {\\n165 | \\t\\t\\tconst cost = calculateApiCostOpenAI(mockModelInfo, 0, 0, 0, 0)\\n----\\n\\n# src/api/providers/openai-native.ts\\n146 | \\tprivate async *yieldUsage(info: ModelInfo, usage: OpenAI.Completions.CompletionUsage | undefined): ApiStream {\\n147 | \\t\\tconst inputTokens = usage?.prompt_tokens || 0 // sum of cache hits and misses\\n148 | \\t\\tconst outputTokens = usage?.completion_tokens || 0\\n149 | \\t\\tconst cacheReadTokens = usage?.prompt_tokens_details?.cached_tokens || 0\\n150 | \\t\\tconst cacheWriteTokens = 0\\n----\\n\\n# src/core/prompts/tools/index.ts\\n 22 | import { getSwitchModeDescription } from \\\"./switch-mode\\\"\\n 23 | import { getNewTaskDescription } from \\\"./new-task\\\"\\n 24 | import { getCodebaseSearchDescription } from \\\"./codebase-search\\\"\\n----\\n 42 | \\tswitch_mode: () => getSwitchModeDescription(),\\n 43 | \\tnew_task: (args) => getNewTaskDescription(args),\\n 44 | \\tinsert_content: (args) => getInsertContentDescription(args),\\n----\\n\\n# src/core/prompts/tools/new-task.ts\\n  3 | export function getNewTaskDescription(_args: ToolArgs): string {\\n  4 | \\treturn `## new_task\\n  5 | Description: This will let you create a new task instance in the chosen mode using your provided message.\\n  6 | \\n  7 | Parameters:\\n  8 | - mode: (required) The slug of the mode to start the new task in (e.g., \\\"code\\\", \\\"debug\\\", \\\"architect\\\").\\n  9 | - message: (required) The initial user message or instructions for this new task.\\n 10 | \\n 11 | Usage:\\n 12 | <new_task>\\n 13 | <mode>your-mode-slug-here</mode>\\n 14 | <message>Your initial instructions here</message>\\n 15 | </new_task>\\n 16 | \\n 17 | Example:\\n 18 | <new_task>\\n 19 | <mode>code</mode>\\n 20 | <message>Implement a new feature for the application.</message>\\n 21 | </new_task>\\n 22 | `\\n----\\n\\n# src/api/providers/xai.ts\\n 52 | \\t\\t\\tmodel: modelId,\\n 53 | \\t\\t\\tmax_tokens: modelInfo.maxTokens,\\n 54 | \\t\\t\\ttemperature: this.options.modelTemperature ?? XAI_DEFAULT_TEMPERATURE,\\n----\\n 78 | \\t\\t\\tif (chunk.usage) {\\n 79 | \\t\\t\\t\\t// Extract detailed token information if available\\n 80 | \\t\\t\\t\\t// First check for prompt_tokens_details structure (real API response)\\n 81 | \\t\\t\\t\\tconst promptDetails = \\\"prompt_tokens_details\\\" in chunk.usage ? chunk.usage.prompt_tokens_details : null;\\n 82 | \\t\\t\\t\\tconst cachedTokens = promptDetails && \\\"cached_tokens\\\" in promptDetails ? promptDetails.cached_tokens : 0;\\n 83 | \\n 84 | \\t\\t\\t\\t// Fall back to direct fields in usage (used in test mocks)\\n 85 | \\t\\t\\t\\tconst readTokens = cachedTokens || (\\\"cache_read_input_tokens\\\" in chunk.usage ? (chunk.usage as any).cache_read_input_tokens : 0);\\n 86 | \\t\\t\\t\\tconst writeTokens = \\\"cache_creation_input_tokens\\\" in chunk.usage ? (chunk.usage as any).cache_creation_input_tokens : 0;\\n 87 | \\n----\\n 89 | \\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n 90 | \\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n 91 | \\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n 92 | \\t\\t\\t\\t\\tcacheReadTokens: readTokens,\\n----\\n\\n# src/core/prompts/tools/search-files.ts\\n  4 | \\treturn `## search_files\\n  5 | Description: Request to perform a regex search across files in a specified directory, providing context-rich results. This tool searches for patterns or specific content across multiple files, displaying each match with encapsulating context.\\n  6 | Parameters:\\n----\\n\\n# src/api/providers/openrouter.ts\\n 32 | \\tinclude_reasoning?: boolean\\n 33 | \\t// https://openrouter.ai/docs/use-cases/reasoning-tokens\\n 34 | \\treasoning?: OpenRouterReasoningParams\\n----\\n 40 | interface CompletionUsage {\\n 41 | \\tcompletion_tokens?: number\\n 42 | \\tcompletion_tokens_details?: {\\n 43 | \\t\\treasoning_tokens?: number\\n 44 | \\t}\\n 45 | \\tprompt_tokens?: number\\n 46 | \\tprompt_tokens_details?: {\\n 47 | \\t\\tcached_tokens?: number\\n 48 | \\t}\\n 49 | \\ttotal_tokens?: number\\n 50 | \\tcost?: number\\n----\\n 81 | \\n 82 | \\t\\t// OpenRouter sends reasoning tokens by default for Gemini 2.5 Pro\\n 83 | \\t\\t// Preview even if you don't request them. This is not the default for\\n----\\n116 | \\t\\t\\tmodel: modelId,\\n117 | \\t\\t\\t...(maxTokens && maxTokens > 0 && { max_tokens: maxTokens }),\\n118 | \\t\\t\\ttemperature,\\n----\\n165 | \\t\\t\\t\\ttype: \\\"usage\\\",\\n166 | \\t\\t\\t\\tinputTokens: lastUsage.prompt_tokens || 0,\\n167 | \\t\\t\\t\\toutputTokens: lastUsage.completion_tokens || 0,\\n168 | \\t\\t\\t\\t// Waiting on OpenRouter to figure out what this represents in the Gemini case\\n169 | \\t\\t\\t\\t// and how to best support it.\\n170 | \\t\\t\\t\\t// cacheReadTokens: lastUsage.prompt_tokens_details?.cached_tokens,\\n171 | \\t\\t\\t\\treasoningTokens: lastUsage.completion_tokens_details?.reasoning_tokens,\\n172 | \\t\\t\\t\\ttotalCost: (lastUsage.is_byok ? BYOK_COST_MULTIPLIER : 1) * (lastUsage.cost || 0),\\n----\\n219 | \\t\\t\\tmodel: modelId,\\n220 | \\t\\t\\tmax_tokens: maxTokens,\\n221 | \\t\\t\\ttemperature,\\n----\\n\\n# src/api/providers/anthropic.ts\\n 75 | \\t\\t\\t\\t\\t\\tmodel: modelId,\\n 76 | \\t\\t\\t\\t\\t\\tmax_tokens: maxTokens ?? ANTHROPIC_DEFAULT_MAX_TOKENS,\\n 77 | \\t\\t\\t\\t\\t\\ttemperature,\\n 78 | \\t\\t\\t\\t\\t\\tthinking,\\n 79 | \\t\\t\\t\\t\\t\\t// Setting cache breakpoint for system prompt so new tasks can reuse it.\\n 80 | \\t\\t\\t\\t\\t\\tsystem: [{ text: systemPrompt, type: \\\"text\\\", cache_control: cacheControl }],\\n----\\n124 | \\t\\t\\t\\t\\tmodel: modelId,\\n125 | \\t\\t\\t\\t\\tmax_tokens: maxTokens ?? ANTHROPIC_DEFAULT_MAX_TOKENS,\\n126 | \\t\\t\\t\\t\\ttemperature,\\n----\\n142 | \\t\\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n143 | \\t\\t\\t\\t\\t\\tinputTokens: usage.input_tokens || 0,\\n144 | \\t\\t\\t\\t\\t\\toutputTokens: usage.output_tokens || 0,\\n145 | \\t\\t\\t\\t\\t\\tcacheWriteTokens: usage.cache_creation_input_tokens || undefined,\\n146 | \\t\\t\\t\\t\\t\\tcacheReadTokens: usage.cache_read_input_tokens || undefined,\\n147 | \\t\\t\\t\\t\\t}\\n----\\n151 | \\t\\t\\t\\tcase \\\"message_delta\\\":\\n152 | \\t\\t\\t\\t\\t// Tells us stop_reason, stop_sequence, and output tokens\\n153 | \\t\\t\\t\\t\\t// along the way and at the end of the message.\\n----\\n156 | \\t\\t\\t\\t\\t\\tinputTokens: 0,\\n157 | \\t\\t\\t\\t\\t\\toutputTokens: chunk.usage.output_tokens || 0,\\n158 | \\t\\t\\t\\t\\t}\\n----\\n231 | \\t\\t\\tmodel,\\n232 | \\t\\t\\tmax_tokens: ANTHROPIC_DEFAULT_MAX_TOKENS,\\n233 | \\t\\t\\tthinking: undefined,\\n----\\n243 | \\t/**\\n244 | \\t * Counts tokens for the given content using Anthropic's API\\n245 | \\t *\\n246 | \\t * @param content The content blocks to count tokens for\\n247 | \\t * @returns A promise resolving to the token count\\n248 | \\t */\\n----\\n258 | \\n259 | \\t\\t\\treturn response.input_tokens\\n260 | \\t\\t} catch (error) {\\n261 | \\t\\t\\t// Log error but fallback to tiktoken estimation\\n262 | \\t\\t\\tconsole.warn(\\\"Anthropic token counting failed, using fallback\\\", error)\\n263 | \\n----\\n\\n# src/core/prompts/tools/execute-command.ts\\n  4 | \\treturn `## execute_command\\n  5 | Description: Request to execute a CLI command on the system. Use this when you need to perform system operations or run specific commands to accomplish any step in the user's task. You must tailor your command to the user's system and provide a clear explanation of what the command does. For command chaining, use the appropriate chaining syntax for the user's shell. Prefer to execute complex CLI commands over creating executable scripts, as they are more flexible and easier to run. Prefer relati [truncated...]\\n  6 | Parameters:\\n----\\n\\n# src/core/prompts/tools/access-mcp-resource.ts\\n  7 | \\treturn `## access_mcp_resource\\n  8 | Description: Request to access a resource provided by a connected MCP server. Resources represent data sources that can be used as context, such as files, API responses, or system information.\\n  9 | Parameters:\\n----\\n\\n# src/api/providers/gemini.ts\\n179 | \\t\\t\\tif (response.totalTokens === undefined) {\\n180 | \\t\\t\\t\\tconsole.warn(\\\"Gemini token counting returned undefined, using fallback\\\")\\n181 | \\t\\t\\t\\treturn super.countTokens(content)\\n----\\n185 | \\t\\t} catch (error) {\\n186 | \\t\\t\\tconsole.warn(\\\"Gemini token counting failed, using fallback\\\", error)\\n187 | \\t\\t\\treturn super.countTokens(content)\\n----\\n209 | \\n210 | \\t\\t// If there's tiered pricing then adjust the input and output token prices\\n211 | \\t\\t// based on the input tokens used.\\n212 | \\t\\tif (info.tiers) {\\n213 | \\t\\t\\tconst tier = info.tiers.find((tier) => inputTokens <= tier.contextWindow)\\n214 | \\n----\\n221 | \\n222 | \\t\\t// Subtract the cached input tokens from the total input tokens.\\n223 | \\t\\tconst uncachedInputTokens = inputTokens - cacheReadTokens\\n----\\n230 | \\n231 | \\t\\tconst trace: Record<string, { price: number; tokens: number; cost: number }> = {\\n232 | \\t\\t\\tinput: { price: inputPrice, tokens: uncachedInputTokens, cost: inputTokensCost },\\n233 | \\t\\t\\toutput: { price: outputPrice, tokens: outputTokens, cost: outputTokensCost },\\n234 | \\t\\t}\\n----\\n236 | \\t\\tif (cacheReadTokens > 0) {\\n237 | \\t\\t\\ttrace.cacheRead = { price: cacheReadsPrice, tokens: cacheReadTokens, cost: cacheReadCost }\\n238 | \\t\\t}\\n----\\n\\n# src/api/providers/requesty.ts\\n 19 | // Requesty usage includes an extra field for Anthropic use cases.\\n 20 | // Safely cast the prompt token details section to the appropriate structure.\\n 21 | interface RequestyUsage extends OpenAI.CompletionUsage {\\n 22 | \\tprompt_tokens_details?: {\\n 23 | \\t\\tcaching_tokens?: number\\n 24 | \\t\\tcached_tokens?: number\\n 25 | \\t}\\n----\\n 76 | \\t\\tconst requestyUsage = usage as RequestyUsage\\n 77 | \\t\\tconst inputTokens = requestyUsage?.prompt_tokens || 0\\n 78 | \\t\\tconst outputTokens = requestyUsage?.completion_tokens || 0\\n 79 | \\t\\tconst cacheWriteTokens = requestyUsage?.prompt_tokens_details?.caching_tokens || 0\\n 80 | \\t\\tconst cacheReadTokens = requestyUsage?.prompt_tokens_details?.cached_tokens || 0\\n 81 | \\t\\tconst totalCost = modelInfo\\n----\\n102 | \\t\\t\\tinfo,\\n103 | \\t\\t\\tmaxTokens: max_tokens,\\n104 | \\t\\t\\ttemperature,\\n----\\n116 | \\t\\t\\tmodel,\\n117 | \\t\\t\\tmax_tokens,\\n118 | \\t\\t\\ttemperature,\\n----\\n122 | \\t\\t\\tstream_options: { include_usage: true },\\n123 | \\t\\t\\trequesty: { trace_id: metadata?.taskId, extra: { mode: metadata?.mode } },\\n124 | \\t\\t}\\n----\\n150 | \\tasync completePrompt(prompt: string): Promise<string> {\\n151 | \\t\\tconst { id: model, maxTokens: max_tokens, temperature } = await this.fetchModel()\\n152 | \\n----\\n156 | \\t\\t\\tmodel,\\n157 | \\t\\t\\tmax_tokens,\\n158 | \\t\\t\\tmessages: openAiMessages,\\n----\\n\\n# src/api/providers/openai.ts\\n160 | \\n161 | \\t\\t\\t// Add max_tokens if needed\\n162 | \\t\\t\\tthis.addMaxTokensIfNeeded(requestOptions, modelInfo)\\n----\\n222 | \\n223 | \\t\\t\\t// Add max_tokens if needed\\n224 | \\t\\t\\tthis.addMaxTokensIfNeeded(requestOptions, modelInfo)\\n----\\n242 | \\t\\t\\ttype: \\\"usage\\\",\\n243 | \\t\\t\\tinputTokens: usage?.prompt_tokens || 0,\\n244 | \\t\\t\\toutputTokens: usage?.completion_tokens || 0,\\n245 | \\t\\t\\tcacheWriteTokens: usage?.cache_creation_input_tokens || undefined,\\n246 | \\t\\t\\tcacheReadTokens: usage?.cache_read_input_tokens || undefined,\\n247 | \\t\\t}\\n----\\n267 | \\n268 | \\t\\t\\t// Add max_tokens if needed\\n269 | \\t\\t\\tthis.addMaxTokensIfNeeded(requestOptions, modelInfo)\\n----\\n311 | \\n312 | \\t\\t\\t// O3 family models do not support the deprecated max_tokens parameter\\n313 | \\t\\t\\t// but they do support max_completion_tokens (the modern OpenAI parameter)\\n314 | \\t\\t\\t// This allows O3 models to limit response length when includeMaxTokens is enabled\\n----\\n336 | \\n337 | \\t\\t\\t// O3 family models do not support the deprecated max_tokens parameter\\n338 | \\t\\t\\t// but they do support max_completion_tokens (the modern OpenAI parameter)\\n339 | \\t\\t\\t// This allows O3 models to limit response length when includeMaxTokens is enabled\\n----\\n367 | \\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n368 | \\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n369 | \\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n370 | \\t\\t\\t\\t}\\n----\\n393 | \\t/**\\n394 | \\t * Adds max_completion_tokens to the request body if needed based on provider configuration\\n395 | \\t * Note: max_tokens is deprecated in favor of max_completion_tokens as per OpenAI documentation\\n396 | \\t * O3 family models handle max_tokens separately in handleO3FamilyMessage\\n397 | \\t */\\n----\\n403 | \\t): void {\\n404 | \\t\\t// Only add max_completion_tokens if includeMaxTokens is true\\n405 | \\t\\tif (this.options.includeMaxTokens === true) {\\n406 | \\t\\t\\t// Use user-configured modelMaxTokens if available, otherwise fall back to model's default maxTokens\\n407 | \\t\\t\\t// Using max_completion_tokens as max_tokens is deprecated\\n408 | \\t\\t\\trequestOptions.max_completion_tokens = this.options.modelMaxTokens || modelInfo.maxTokens\\n409 | \\t\\t}\\n----\\n\\n# src/core/prompts/__tests__/responses-rooignore.test.ts\\n 53 | \\t\\t\\texpect(errorMessage).toContain(\\\"Access to secrets/api-keys.json is blocked by the .rooignore file settings\\\")\\n 54 | \\t\\t\\texpect(errorMessage).toContain(\\\"continue in the task without using this file\\\")\\n 55 | \\t\\t\\texpect(errorMessage).toContain(\\\"ask the user to update the .rooignore file\\\")\\n----\\n\\n# src/api/providers/__tests__/bedrock-custom-arn.spec.ts\\n215 | \\t\\t\\texpect(model.info).toHaveProperty(\\\"maxTokens\\\")\\n216 | \\t\\t\\texpect(model.info).toHaveProperty(\\\"contextWindow\\\")\\n217 | \\t\\t\\texpect(model.info).toHaveProperty(\\\"supportsPromptCache\\\")\\n----\\n\\n# src/api/providers/__tests__/ollama.spec.ts\\n 28 | \\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 29 | \\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 30 | \\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 31 | \\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 32 | \\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n 54 | \\t\\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 55 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 56 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 57 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 58 | \\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n164 | \\t\\t\\texpect(modelInfo.info.maxTokens).toBe(-1)\\n165 | \\t\\t\\texpect(modelInfo.info.contextWindow).toBe(128_000)\\n166 | \\t\\t})\\n----\\n\\n# src/api/providers/__tests__/lmstudio.test.ts\\n 25 | \\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 26 | \\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 27 | \\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 28 | \\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 29 | \\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n 51 | \\t\\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 52 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 53 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 54 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 55 | \\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n163 | \\t\\t\\texpect(modelInfo.info.maxTokens).toBe(-1)\\n164 | \\t\\t\\texpect(modelInfo.info.contextWindow).toBe(128_000)\\n165 | \\t\\t})\\n----\\n\\n# src/api/providers/__tests__/bedrock-reasoning.test.ts\\n 94 | \\t\\t\\t\\ttype: \\\"enabled\\\",\\n 95 | \\t\\t\\t\\tbudget_tokens: 4096, // Uses the full modelMaxThinkingTokens value\\n 96 | \\t\\t\\t})\\n----\\n123 | \\t\\t\\tconst metadata = {\\n124 | \\t\\t\\t\\ttaskId: \\\"test-task\\\",\\n125 | \\t\\t\\t\\tthinking: {\\n----\\n143 | \\t\\t\\t\\ttype: \\\"enabled\\\",\\n144 | \\t\\t\\t\\tbudget_tokens: 8192,\\n145 | \\t\\t\\t})\\n----\\n266 | \\t\\t\\t\\ttype: \\\"enabled\\\",\\n267 | \\t\\t\\t\\tbudget_tokens: 4096,\\n268 | \\t\\t\\t})\\n----\\n\\n# src/api/providers/__tests__/openai-native.spec.ts\\n 29 | \\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 30 | \\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 31 | \\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 32 | \\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 33 | \\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n 55 | \\t\\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 56 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 57 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 58 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 59 | \\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n145 | \\t\\t\\t\\t\\t\\tusage: {\\n146 | \\t\\t\\t\\t\\t\\t\\tprompt_tokens: 0,\\n147 | \\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 0,\\n148 | \\t\\t\\t\\t\\t\\t\\ttotal_tokens: 0,\\n149 | \\t\\t\\t\\t\\t\\t},\\n----\\n215 | \\t\\t\\t\\t{ choices: [{ delta: { content: \\\" there\\\" } }], usage: null },\\n216 | \\t\\t\\t\\t{ choices: [{ delta: { content: \\\"!\\\" } }], usage: { prompt_tokens: 10, completion_tokens: 5 } },\\n217 | \\t\\t\\t]\\n----\\n261 | \\t\\t\\t\\t{ choices: [{ delta: { content: null } }], usage: null },\\n262 | \\t\\t\\t\\t{ choices: [{ delta: { content: \\\"Hello\\\" } }], usage: { prompt_tokens: 10, completion_tokens: 5 } },\\n263 | \\t\\t\\t]\\n----\\n450 | \\t\\t\\texpect(modelInfo.info.maxTokens).toBe(32768)\\n451 | \\t\\t\\texpect(modelInfo.info.contextWindow).toBe(1047576)\\n452 | \\t\\t})\\n----\\n\\n# src/api/providers/base-openai-compatible-provider.ts\\n 71 | \\t\\t\\tid: model,\\n 72 | \\t\\t\\tinfo: { maxTokens: max_tokens },\\n 73 | \\t\\t} = this.getModel()\\n----\\n 78 | \\t\\t\\tmodel,\\n 79 | \\t\\t\\tmax_tokens,\\n 80 | \\t\\t\\ttemperature,\\n----\\n100 | \\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n101 | \\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n102 | \\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n103 | \\t\\t\\t\\t}\\n----\\n\\n# src/core/webview/getNonce.ts\\n  4 |  * @remarks This function is primarily used to help enforce content security\\n  5 |  * policies for resources/scripts being executed in a webview context.\\n  6 |  *\\n----\\n\\n# src/api/providers/bedrock.ts\\n 52 | \\t\\ttype: \\\"enabled\\\"\\n 53 | \\t\\tbudget_tokens: number\\n 54 | \\t}\\n----\\n109 | \\tmessageStop?: {\\n110 | \\t\\tstopReason?: \\\"end_turn\\\" | \\\"tool_use\\\" | \\\"max_tokens\\\" | \\\"stop_sequence\\\"\\n111 | \\t\\tadditionalModelResponseFields?: Record<string, unknown>\\n----\\n248 | \\t\\t\\t\\tmaxTokens: 8192,\\n249 | \\t\\t\\t\\tcontextWindow: 200_000,\\n250 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n254 | \\t\\t\\t\\tmaxTokens: 8192,\\n255 | \\t\\t\\t\\tcontextWindow: 200_000,\\n256 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n260 | \\t\\t\\t\\tmaxTokens: 8192,\\n261 | \\t\\t\\t\\tcontextWindow: 200_000,\\n262 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n266 | \\t\\t\\t\\tmaxTokens: 4096,\\n267 | \\t\\t\\t\\tcontextWindow: 200_000,\\n268 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n272 | \\t\\t\\t\\tmaxTokens: 4096,\\n273 | \\t\\t\\t\\tcontextWindow: 200_000,\\n274 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n278 | \\t\\t\\t\\tmaxTokens: 4096,\\n279 | \\t\\t\\t\\tcontextWindow: 200_000,\\n280 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n295 | \\t\\t\\tmaxTokens: BEDROCK_MAX_TOKENS,\\n296 | \\t\\t\\tcontextWindow: BEDROCK_DEFAULT_CONTEXT,\\n297 | \\t\\t\\tsupportsImages: false,\\n----\\n349 | \\t\\t\\t\\t\\ttype: \\\"enabled\\\",\\n350 | \\t\\t\\t\\t\\tbudget_tokens: metadata?.thinking?.maxThinkingTokens || modelConfig.reasoningBudget || 4096,\\n351 | \\t\\t\\t\\t},\\n----\\n418 | \\n419 | \\t\\t\\t\\t\\t// Check both field naming conventions for cache tokens\\n420 | \\t\\t\\t\\t\\tconst cacheReadTokens = usage.cacheReadInputTokens || usage.cacheReadInputTokenCount || 0\\n----\\n422 | \\n423 | \\t\\t\\t\\t\\t// Always include all available token information\\n424 | \\t\\t\\t\\t\\tyield {\\n----\\n436 | \\t\\t\\t\\t\\t\\t//update the in-use model info to be based on the invoked Model Id for the router\\n437 | \\t\\t\\t\\t\\t\\t//so that pricing, context window, caching etc have values that can be used\\n438 | \\t\\t\\t\\t\\t\\t//However, we want to keep the id of the model to be the ID for the router for\\n----\\n450 | \\n451 | \\t\\t\\t\\t\\t\\t\\t// Check both field naming conventions for cache tokens\\n452 | \\t\\t\\t\\t\\t\\t\\tconst cacheReadTokens =\\n----\\n564 | \\t\\t\\t// Use the extracted error handling method for all errors\\n565 | \\t\\t\\tconst errorChunks = this.handleBedrockError(error, true) // true for streaming context\\n566 | \\t\\t\\t// Yield each chunk individually to ensure type compatibility\\n----\\n637 | \\t\\t\\t// Use the extracted error handling method for all errors\\n638 | \\t\\t\\tconst errorResult = this.handleBedrockError(error, false) // false for non-streaming context\\n639 | \\t\\t\\t// Since we're in a non-streaming context, we know the result is a string\\n640 | \\t\\t\\tconst errorMessage = errorResult as string\\n----\\n668 | \\t\\t\\tmaxTokens: modelInfo?.maxTokens || 8192,\\n669 | \\t\\t\\tcontextWindow: modelInfo?.contextWindow || 200_000,\\n670 | \\t\\t\\tsupportsPromptCache: modelInfo?.supportsPromptCache || false,\\n----\\n725 | \\t\\tid: \\\"\\\",\\n726 | \\t\\tinfo: { maxTokens: 0, contextWindow: 0, supportsPromptCache: false, supportsImages: false },\\n727 | \\t}\\n----\\n857 | \\n858 | \\t\\t// Always allow user to override detected/guessed maxTokens and contextWindow\\n859 | \\t\\tif (this.options.modelMaxTokens && this.options.modelMaxTokens > 0) {\\n----\\n862 | \\t\\tif (this.options.awsModelContextWindow && this.options.awsModelContextWindow > 0) {\\n863 | \\t\\t\\tmodel.info.contextWindow = this.options.awsModelContextWindow\\n864 | \\t\\t}\\n----\\n922 | \\n923 | \\t\\t// Don't override maxTokens/contextWindow here; handled in getModelById (and includes user overrides)\\n924 | \\t\\treturn { ...modelConfig, ...params } as {\\n----\\n1049 | \\t\\tTOO_MANY_TOKENS: {\\n1050 | \\t\\t\\tpatterns: [\\\"too many tokens\\\"],\\n1051 | \\t\\t\\tmessageTemplate: `\\\"Too many tokens\\\" error detected.\\n1052 | Possible Causes:\\n1053 | 1. Input exceeds model's context window limit\\n1054 | 2. Rate limiting (too many tokens per minute)\\n1055 | 3. Quota exceeded for token usage\\n1056 | 4. Other token-related service limitations\\n1057 | \\n----\\n1060 | 2. Split your request into smaller chunks\\n1061 | 3. Use a model with a larger context window\\n1062 | 4. If rate limited, reduce request frequency\\n----\\n1139 | \\t/**\\n1140 | \\t * Formats an error message based on the error type and context\\n1141 | \\t */\\n----\\n1154 | \\t\\t\\ttemplateVars.modelId = modelConfig.id\\n1155 | \\t\\t\\ttemplateVars.contextWindow = String(modelConfig.info.contextWindow || \\\"unknown\\\")\\n1156 | \\n----\\n1188 | \\n1189 | \\t\\t// Add context-specific template variables\\n1190 | \\t\\tconst region =\\n----\\n1206 | \\t * @param error The error that occurred\\n1207 | \\t * @param isStreamContext Whether the error occurred in a streaming context (true) or not (false)\\n1208 | \\t * @returns Error message string for non-streaming context or array of stream chunks for streaming context\\n1209 | \\t */\\n----\\n1222 | \\t\\tconst logMethod = definition.logLevel\\n1223 | \\t\\tconst contextName = isStreamContext ? \\\"createMessage\\\" : \\\"completePrompt\\\"\\n1224 | \\t\\tlogger[logMethod](`${errorType} error in ${contextName}`, {\\n1225 | \\t\\t\\tctx: \\\"bedrock\\\",\\n----\\n1239 | \\t\\t} else {\\n1240 | \\t\\t\\t// For non-streaming context, add the expected prefix\\n1241 | \\t\\t\\treturn `Bedrock completion error: ${errorMessage}`\\n----\\n\\n# src/api/providers/chutes.ts\\n 31 | \\t\\t\\tid: model,\\n 32 | \\t\\t\\tinfo: { maxTokens: max_tokens },\\n 33 | \\t\\t} = this.getModel()\\n----\\n 38 | \\t\\t\\tmodel,\\n 39 | \\t\\t\\tmax_tokens,\\n 40 | \\t\\t\\ttemperature,\\n----\\n 76 | \\t\\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n 77 | \\t\\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n 78 | \\t\\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n 79 | \\t\\t\\t\\t\\t}\\n----\\n\\n# src/core/webview/__tests__/webviewMessageHandler.test.ts\\n 34 | \\t\\t\\t\\tmaxTokens: 4096,\\n 35 | \\t\\t\\t\\tcontextWindow: 8192,\\n 36 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n 40 | \\t\\t\\t\\tmaxTokens: 8192,\\n 41 | \\t\\t\\t\\tcontextWindow: 16384,\\n 42 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n 90 | \\t\\t\\t\\tmaxTokens: 4096,\\n 91 | \\t\\t\\t\\tcontextWindow: 8192,\\n 92 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n128 | \\t\\t\\t\\tmaxTokens: 4096,\\n129 | \\t\\t\\t\\tcontextWindow: 8192,\\n130 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n165 | \\t\\t\\t\\tmaxTokens: 4096,\\n166 | \\t\\t\\t\\tcontextWindow: 8192,\\n167 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n\\n# src/api/providers/__tests__/bedrock-invokedModelId.spec.ts\\n176 | \\n177 | \\t\\t// The last usage event should have the token counts from the metadata\\n178 | \\t\\tconst lastUsageEvent = usageEvents[usageEvents.length - 1]\\n179 | \\t\\t// Expect the usage event to include all token information\\n180 | \\t\\texpect(lastUsageEvent).toMatchObject({\\n----\\n183 | \\t\\t\\toutputTokens: 200,\\n184 | \\t\\t\\t// Cache tokens may be present with default values\\n185 | \\t\\t\\tcacheReadTokens: expect.any(Number),\\n----\\n331 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n332 | \\t\\t\\t\\t\\tcontextWindow: 128_000,\\n333 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n\\n# src/utils/__tests__/tiktoken.spec.ts\\n  1 | // npx vitest utils/__tests__/tiktoken.spec.ts\\n  2 | \\n  3 | import { describe, it, expect } from \\\"vitest\\\"\\n  4 | import { tiktoken } from \\\"../tiktoken\\\"\\n  5 | import { Anthropic } from \\\"@anthropic-ai/sdk\\\"\\n  6 | \\n  7 | describe(\\\"tiktoken\\\", () => {\\n  8 | \\tit(\\\"should return 0 for empty content array\\\", async () => {\\n  9 | \\t\\tconst result = await tiktoken([])\\n 10 | \\t\\texpect(result).toBe(0)\\n----\\n 12 | \\n 13 | \\tit(\\\"should correctly count tokens for text content\\\", async () => {\\n 14 | \\t\\tconst content: Anthropic.Messages.ContentBlockParam[] = [{ type: \\\"text\\\", text: \\\"Hello world\\\" }]\\n 15 | \\n 16 | \\t\\tconst result = await tiktoken(content)\\n 17 | \\t\\t// We can't predict the exact token count without mocking,\\n 18 | \\t\\t// but we can verify it's a positive number\\n----\\n 24 | \\n 25 | \\t\\tconst result = await tiktoken(content)\\n 26 | \\t\\texpect(result).toBe(0)\\n----\\n 33 | \\n 34 | \\t\\tconst result = await tiktoken(content)\\n 35 | \\t\\texpect(result).toBe(0)\\n----\\n 37 | \\n 38 | \\tit(\\\"should correctly count tokens for image content with data\\\", async () => {\\n 39 | \\t\\tconst base64Data =\\n----\\n 51 | \\n 52 | \\t\\tconst result = await tiktoken(content)\\n 53 | \\t\\t// For images, we expect a token count based on the square root of the data length\\n 54 | \\t\\t// plus the fudge factor\\n----\\n 72 | \\n 73 | \\t\\tconst result = await tiktoken(content)\\n 74 | \\t\\t// Conservative estimate is 300 tokens, plus the fudge factor\\n 75 | \\t\\tconst expectedMinTokens = 300\\n----\\n 78 | \\n 79 | \\tit(\\\"should correctly count tokens for mixed content\\\", async () => {\\n 80 | \\t\\tconst base64Data =\\n----\\n 94 | \\n 95 | \\t\\tconst result = await tiktoken(content)\\n 96 | \\t\\t// We expect a positive token count for mixed content\\n 97 | \\t\\texpect(result).toBeGreaterThan(0)\\n----\\n 99 | \\n100 | \\tit(\\\"should apply a fudge factor to the token count\\\", async () => {\\n101 | \\t\\t// We can test the fudge factor by comparing the token count with a rough estimate\\n102 | \\t\\tconst content: Anthropic.Messages.ContentBlockParam[] = [{ type: \\\"text\\\", text: \\\"Test\\\" }]\\n103 | \\n104 | \\t\\tconst result = await tiktoken(content)\\n105 | \\n106 | \\t\\t// Run the function again with the same content to get a consistent result\\n107 | \\t\\tconst result2 = await tiktoken(content)\\n108 | \\n109 | \\t\\t// Both calls should return the same token count\\n110 | \\t\\texpect(result).toBe(result2)\\n----\\n122 | \\n123 | \\t\\tconst result1 = await tiktoken(content)\\n124 | \\t\\tconst result2 = await tiktoken(content)\\n125 | \\n126 | \\t\\t// Both calls should return the same token count\\n127 | \\t\\texpect(result1).toBe(result2)\\n----\"}",
  "partial": false,
  "isProtected": false
}
[2025-06-16T20:26:56.078Z] {
  "ts": 1750105616071,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[search_files for 'task|subtask|context|token' in '*.ts'] Result:\\n\\nShowing first 300 of 300+ results. Use a more specific search if necessary.\\n\\n# src/workers/countTokens.ts\\n  4 | \\n  5 | import { tiktoken } from \\\"../utils/tiktoken\\\"\\n  6 | \\n----\\n 10 | \\ttry {\\n 11 | \\t\\tconst count = await tiktoken(content)\\n 12 | \\t\\treturn { success: true, count }\\n----\\n\\n# src/integrations/editor/DiffViewProvider.ts\\n 12 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n 13 | import { Task } from \\\"../../core/task/Task\\\"\\n 14 | \\n----\\n204 | \\t\\t// directly related to the work he's doing. This eliminates the risk of Roo\\n205 | \\t\\t// going off-task or getting distracted by unrelated issues, which was a problem\\n206 | \\t\\t// with the previous auto-debug approach. Some users' machines may be slow to\\n----\\n268 | \\t */\\n269 | \\tasync pushToolWriteResult(task: Task, cwd: string, isNewFile: boolean): Promise<string> {\\n270 | \\t\\tif (!this.relPath) {\\n----\\n283 | \\t\\t\\t// Send the user feedback\\n284 | \\t\\t\\tawait task.say(\\\"user_feedback_diff\\\", JSON.stringify(say))\\n285 | \\t\\t}\\n----\\n296 | \\t\\t\\t\\t\\t\\t\\\"You do not need to re-read the file, as you have seen all changes\\\",\\n297 | \\t\\t\\t\\t\\t\\t\\\"Proceed with the task using these changes as the new baseline.\\\",\\n298 | \\t\\t\\t\\t\\t\\t...(this.userEdits\\n299 | \\t\\t\\t\\t\\t\\t\\t? [\\n300 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\\"If the user's edits have addressed part of the task or changed the requirements, adjust your approach accordingly.\\\",\\n301 | \\t\\t\\t\\t\\t\\t\\t\\t]\\n----\\n\\n# src/integrations/terminal/types.ts\\n  9 | \\trunning: boolean\\n 10 | \\ttaskId?: string\\n 11 | \\tprocess?: RooTerminalProcess\\n----\\n\\n# src/integrations/editor/EditorUtils.ts\\n168 | \\t/**\\n169 | \\t * Builds the editor context from the provided text editor or from the active text editor.\\n170 | \\t * The context includes file path, effective selected text, and any diagnostics that intersect with the effective range.\\n171 | \\t *\\n----\\n205 | \\t\\t} catch (error) {\\n206 | \\t\\t\\tconsole.error(\\\"Error getting editor context:\\\", error)\\n207 | \\t\\t\\treturn null\\n----\\n\\n# src/integrations/workspace/WorkspaceTracker.ts\\n  9 | \\n 10 | // Note: this is not a drop-in replacement for listFiles at the start of tasks, since that will be done for Desktops when there is no workspace selected\\n 11 | class WorkspaceTracker {\\n----\\n136 | \\tprivate async addFilePath(filePath: string): Promise<string> {\\n137 | \\t\\t// Allow for some buffer to account for files being created/deleted during a task\\n138 | \\t\\tif (this.filePaths.size >= MAX_INITIAL_FILES * 2) {\\n----\\n\\n# src/integrations/terminal/BaseTerminal.ts\\n 20 | \\n 21 | \\tpublic taskId?: string\\n 22 | \\tpublic process?: RooTerminalProcess\\n----\\n107 | \\t * Cleans the process queue by removing processes that no longer have unretrieved output\\n108 | \\t * or don't belong to the current task\\n109 | \\t */\\n----\\n\\n# src/integrations/misc/extract-text.ts\\n131 | /**\\n132 |  * Truncates multi-line output while preserving context from both the beginning and end.\\n133 |  * When truncation is needed, it keeps 20% of the lines from the start and 80% from the end,\\n----\\n\\n# src/integrations/misc/export-markdown.ts\\n 17 | \\thours = hours ? hours : 12 // the hour '0' should be '12'\\n 18 | \\tconst fileName = `roo_task_${month}-${day}-${year}_${hours}-${minutes}-${seconds}-${ampm}.md`\\n 19 | \\n----\\n\\n# src/integrations/terminal/TerminalRegistry.ts\\n 14 | // too many terminals, we need to keep track of terminals through the life of\\n 15 | // the extension, as well as session specific terminals for the life of a task\\n 16 | // (to get latest unretrieved output).\\n 17 | // Since we have promises keeping track of terminal processes, we get the added\\n 18 | // benefit of keep track of busy terminals even after a task is closed.\\n 19 | \\n----\\n149 | \\t * @param requiredCwd Whether the working directory is required (if false, may reuse any non-busy terminal)\\n150 | \\t * @param taskId Optional task ID to associate with the terminal\\n151 | \\t * @returns A Terminal instance\\n----\\n155 | \\t\\trequiredCwd: boolean = false,\\n156 | \\t\\ttaskId?: string,\\n157 | \\t\\tprovider: RooTerminalProvider = \\\"vscode\\\",\\n----\\n161 | \\n162 | \\t\\t// First priority: Find a terminal already assigned to this task with\\n163 | \\t\\t// matching directory.\\n164 | \\t\\tif (taskId) {\\n165 | \\t\\t\\tterminal = terminals.find((t) => {\\n166 | \\t\\t\\t\\tif (t.busy || t.taskId !== taskId || t.provider !== provider) {\\n167 | \\t\\t\\t\\t\\treturn false\\n----\\n207 | \\n208 | \\t\\tterminal.taskId = taskId\\n209 | \\n----\\n233 | \\t/**\\n234 | \\t * Gets terminals filtered by busy state and optionally by task id.\\n235 | \\t *\\n236 | \\t * @param busy Whether to get busy or non-busy terminals\\n237 | \\t * @param taskId Optional task ID to filter terminals by\\n238 | \\t * @returns Array of Terminal objects\\n239 | \\t */\\n240 | \\tpublic static getTerminals(busy: boolean, taskId?: string): RooTerminal[] {\\n241 | \\t\\treturn this.getAllTerminals().filter((t) => {\\n----\\n246 | \\n247 | \\t\\t\\t// If taskId is provided, also filter by taskId.\\n248 | \\t\\t\\tif (taskId !== undefined && t.taskId !== taskId) {\\n249 | \\t\\t\\t\\treturn false\\n----\\n256 | \\t/**\\n257 | \\t * Gets background terminals (taskId undefined) that have unretrieved output\\n258 | \\t * or are still running.\\n----\\n264 | \\t\\treturn this.getAllTerminals().filter((t) => {\\n265 | \\t\\t\\t// Only get background terminals (taskId undefined).\\n266 | \\t\\t\\tif (t.taskId !== undefined) {\\n267 | \\t\\t\\t\\treturn false\\n----\\n287 | \\t/**\\n288 | \\t * Releases all terminals associated with a task.\\n289 | \\t *\\n290 | \\t * @param taskId The task ID\\n291 | \\t */\\n292 | \\tpublic static releaseTerminalsForTask(taskId: string): void {\\n293 | \\t\\tthis.terminals.forEach((terminal) => {\\n294 | \\t\\t\\tif (terminal.taskId === taskId) {\\n295 | \\t\\t\\t\\tterminal.taskId = undefined\\n296 | \\t\\t\\t}\\n----\\n\\n# src/extension.ts\\n 53 | // Your extension is activated the very first time the command is executed.\\n 54 | export async function activate(context: vscode.ExtensionContext) {\\n 55 | \\textensionContext = context\\n 56 | \\toutputChannel = vscode.window.createOutputChannel(Package.outputChannel)\\n 57 | \\tcontext.subscriptions.push(outputChannel)\\n 58 | \\toutputChannel.appendLine(`${Package.name} extension activated - ${JSON.stringify(Package)}`)\\n----\\n 60 | \\t// Migrate old settings to new\\n 61 | \\tawait migrateSettings(context, outputChannel)\\n 62 | \\n----\\n 75 | \\t// Initialize Roo Code Cloud service.\\n 76 | \\tawait CloudService.createInstance(context, {\\n 77 | \\t\\tstateChanged: () => ClineProvider.getVisibleInstance()?.postStateToWebview(),\\n----\\n 81 | \\t// Initialize i18n for internationalization support\\n 82 | \\tinitializeI18n(context.globalState.get(\\\"language\\\") ?? formatLanguage(vscode.env.language))\\n 83 | \\n----\\n 90 | \\t// Initialize global state if not already set.\\n 91 | \\tif (!context.globalState.get(\\\"allowedCommands\\\")) {\\n 92 | \\t\\tcontext.globalState.update(\\\"allowedCommands\\\", defaultCommands)\\n 93 | \\t}\\n 94 | \\n 95 | \\tconst contextProxy = await ContextProxy.getInstance(context)\\n 96 | \\tconst codeIndexManager = CodeIndexManager.getInstance(context)\\n 97 | \\n 98 | \\ttry {\\n 99 | \\t\\tawait codeIndexManager?.initialize(contextProxy)\\n100 | \\t} catch (error) {\\n----\\n105 | \\n106 | \\tconst provider = new ClineProvider(context, outputChannel, \\\"sidebar\\\", contextProxy, codeIndexManager)\\n107 | \\tTelemetryService.instance.setProvider(provider)\\n----\\n109 | \\tif (codeIndexManager) {\\n110 | \\t\\tcontext.subscriptions.push(codeIndexManager)\\n111 | \\t}\\n112 | \\n113 | \\tcontext.subscriptions.push(\\n114 | \\t\\tvscode.window.registerWebviewViewProvider(ClineProvider.sideBarId, provider, {\\n----\\n118 | \\n119 | \\tregisterCommands({ context, outputChannel, provider })\\n120 | \\n----\\n142 | \\n143 | \\tcontext.subscriptions.push(\\n144 | \\t\\tvscode.workspace.registerTextDocumentContentProvider(DIFF_VIEW_URI_SCHEME, diffContentProvider),\\n----\\n146 | \\n147 | \\tcontext.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))\\n148 | \\n149 | \\t// Register code actions provider.\\n150 | \\tcontext.subscriptions.push(\\n151 | \\t\\tvscode.languages.registerCodeActionsProvider({ pattern: \\\"**/*\\\" }, new CodeActionProvider(), {\\n----\\n155 | \\n156 | \\tregisterCodeActions(context)\\n157 | \\tregisterTerminalActions(context)\\n158 | \\n----\\n170 | \\t\\tconst watchPaths = [\\n171 | \\t\\t\\t{ path: context.extensionPath, name: \\\"extension\\\" },\\n172 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/types\\\"), name: \\\"types\\\" },\\n173 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/telemetry\\\"), name: \\\"telemetry\\\" },\\n174 | \\t\\t\\t{ path: path.join(context.extensionPath, \\\"../packages/cloud\\\"), name: \\\"cloud\\\" },\\n175 | \\t\\t]\\n----\\n188 | \\n189 | \\t\\t\\tcontext.subscriptions.push(watcher)\\n190 | \\t\\t})\\n----\\n\\n# src/utils/tiktoken.ts\\n  1 | import { Anthropic } from \\\"@anthropic-ai/sdk\\\"\\n  2 | import { Tiktoken } from \\\"tiktoken/lite\\\"\\n  3 | import o200kBase from \\\"tiktoken/encoders/o200k_base\\\"\\n  4 | \\n----\\n  6 | \\n  7 | let encoder: Tiktoken | null = null\\n  8 | \\n  9 | export async function tiktoken(content: Anthropic.Messages.ContentBlockParam[]): Promise<number> {\\n 10 | \\tif (content.length === 0) {\\n----\\n 17 | \\tif (!encoder) {\\n 18 | \\t\\tencoder = new Tiktoken(o200kBase.bpe_ranks, o200kBase.special_tokens, o200kBase.pat_str)\\n 19 | \\t}\\n----\\n 26 | \\t\\t\\tif (text.length > 0) {\\n 27 | \\t\\t\\t\\tconst tokens = encoder.encode(text)\\n 28 | \\t\\t\\t\\ttotalTokens += tokens.length\\n 29 | \\t\\t\\t}\\n----\\n 42 | \\n 43 | \\t// Add a fudge factor to account for the fact that tiktoken is not always\\n 44 | \\t// accurate.\\n----\\n\\n# src/utils/single-completion-handler.ts\\n  5 | /**\\n  6 |  * Enhances a prompt using the configured API without creating a full Cline instance or task history.\\n  7 |  * This is a lightweight alternative that only uses the API's completion functionality.\\n----\\n\\n# src/utils/logging/CompactLogger.ts\\n112 | \\t/**\\n113 | \\t * Combines parent and current metadata with proper context handling\\n114 | \\t * @private\\n----\\n\\n# src/utils/migrateSettings.ts\\n 15 | export async function migrateSettings(\\n 16 | \\tcontext: vscode.ExtensionContext,\\n 17 | \\toutputChannel: vscode.OutputChannel,\\n----\\n 26 | \\ttry {\\n 27 | \\t\\tconst settingsDir = path.join(context.globalStorageUri.fsPath, \\\"settings\\\")\\n 28 | \\n----\\n\\n# src/utils/logging/types.ts\\n 14 | \\tm: string\\n 15 | \\t/** Optional context identifier */\\n 16 | \\tc?: string\\n----\\n 29 | export interface LogMeta {\\n 30 | \\t/** Optional context identifier */\\n 31 | \\tctx?: string\\n----\\n\\n# src/utils/logging/__tests__/CompactLogger.spec.ts\\n147 | \\n148 | \\t\\ttest(\\\"child logger respects parent context when not overridden\\\", () => {\\n149 | \\t\\t\\tconst parentLogger = new CompactLogger(transport, { ctx: \\\"parent\\\" })\\n----\\n\\n# src/api/index.ts\\n 37 | \\tmode?: string\\n 38 | \\ttaskId: string\\n 39 | }\\n----\\n 50 | \\t/**\\n 51 | \\t * Counts tokens for content blocks\\n 52 | \\t * All providers extend BaseProvider which provides a default tiktoken implementation,\\n 53 | \\t * but they can override this to use their native token counting endpoints\\n 54 | \\t *\\n 55 | \\t * @param content The content to count tokens for\\n 56 | \\t * @returns A promise resolving to the token count\\n 57 | \\t */\\n----\\n\\n# src/utils/storage.ts\\n 51 | /**\\n 52 |  * Gets the storage directory path for a task\\n 53 |  */\\n 54 | export async function getTaskDirectoryPath(globalStoragePath: string, taskId: string): Promise<string> {\\n 55 | \\tconst basePath = await getStorageBasePath(globalStoragePath)\\n 56 | \\tconst taskDir = path.join(basePath, \\\"tasks\\\", taskId)\\n 57 | \\tawait fs.mkdir(taskDir, { recursive: true })\\n 58 | \\treturn taskDir\\n 59 | }\\n----\\n\\n# src/api/providers/anthropic-vertex.ts\\n 83 | \\t\\t * This ensures we stay under the 4-block limit while maintaining effective caching\\n 84 | \\t\\t * for the most relevant context.\\n 85 | \\t\\t */\\n----\\n 87 | \\t\\t\\tmodel: id,\\n 88 | \\t\\t\\tmax_tokens: maxTokens ?? ANTHROPIC_DEFAULT_MAX_TOKENS,\\n 89 | \\t\\t\\ttemperature,\\n----\\n107 | \\t\\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n108 | \\t\\t\\t\\t\\t\\tinputTokens: usage.input_tokens || 0,\\n109 | \\t\\t\\t\\t\\t\\toutputTokens: usage.output_tokens || 0,\\n110 | \\t\\t\\t\\t\\t\\tcacheWriteTokens: usage.cache_creation_input_tokens || undefined,\\n111 | \\t\\t\\t\\t\\t\\tcacheReadTokens: usage.cache_read_input_tokens || undefined,\\n112 | \\t\\t\\t\\t\\t}\\n----\\n119 | \\t\\t\\t\\t\\t\\tinputTokens: 0,\\n120 | \\t\\t\\t\\t\\t\\toutputTokens: chunk.usage!.output_tokens || 0,\\n121 | \\t\\t\\t\\t\\t}\\n----\\n189 | \\t\\t\\t\\tmodel: id,\\n190 | \\t\\t\\t\\tmax_tokens: maxTokens,\\n191 | \\t\\t\\t\\ttemperature,\\n----\\n\\n# src/utils/__tests__/enhance-prompt.spec.ts\\n 33 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n 34 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n 35 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n 88 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n 89 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n 90 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n115 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n116 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n117 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n135 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n136 | \\t\\t\\t\\t\\tcontextWindow: 8192,\\n137 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n\\n# src/core/prompts/system.ts\\n 29 | async function generatePrompt(\\n 30 | \\tcontext: vscode.ExtensionContext,\\n 31 | \\tcwd: string,\\n----\\n 47 | ): Promise<string> {\\n 48 | \\tif (!context) {\\n 49 | \\t\\tthrow new Error(\\\"Extension context is required for generating system prompt\\\")\\n 50 | \\t}\\n----\\n 59 | \\tconst [modesSection, mcpServersSection] = await Promise.all([\\n 60 | \\t\\tgetModesSection(context),\\n 61 | \\t\\tmodeConfig.groups.some((groupEntry) => getGroupName(groupEntry) === \\\"mcp\\\")\\n----\\n 65 | \\n 66 | \\tconst codeIndexManager = CodeIndexManager.getInstance(context)\\n 67 | \\n----\\n107 | export const SYSTEM_PROMPT = async (\\n108 | \\tcontext: vscode.ExtensionContext,\\n109 | \\tcwd: string,\\n----\\n125 | ): Promise<string> => {\\n126 | \\tif (!context) {\\n127 | \\t\\tthrow new Error(\\\"Extension context is required for generating system prompt\\\")\\n128 | \\t}\\n----\\n180 | \\treturn generatePrompt(\\n181 | \\t\\tcontext,\\n182 | \\t\\tcwd,\\n----\\n\\n# src/core/tools/writeToFileTool.ts\\n  4 | \\n  5 | import { Task } from \\\"../task/Task\\\"\\n  6 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n  8 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  9 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 10 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n----\\n\\n# src/core/prompts/instructions/instructions.ts\\n  9 | \\tdiffStrategy?: DiffStrategy\\n 10 | \\tcontext?: vscode.ExtensionContext\\n 11 | }\\n----\\n 18 | \\t\\tcase \\\"create_mode\\\": {\\n 19 | \\t\\t\\treturn await createModeInstructions(detail.context)\\n 20 | \\t\\t}\\n----\\n\\n# src/core/tools/fetchInstructionsTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { fetchInstructions } from \\\"../prompts/instructions/instructions\\\"\\n----\\n 13 | ) {\\n 14 | \\tconst task: string | undefined = block.params.task\\n 15 | \\tconst sharedMessageProps: ClineSayTool = { tool: \\\"fetchInstructions\\\", content: task }\\n 16 | \\n----\\n 22 | \\t\\t} else {\\n 23 | \\t\\t\\tif (!task) {\\n 24 | \\t\\t\\t\\tcline.consecutiveMistakeCount++\\n 25 | \\t\\t\\t\\tcline.recordToolError(\\\"fetch_instructions\\\")\\n 26 | \\t\\t\\t\\tpushToolResult(await cline.sayAndCreateMissingParamError(\\\"fetch_instructions\\\", \\\"task\\\"))\\n 27 | \\t\\t\\t\\treturn\\n----\\n 31 | \\n 32 | \\t\\t\\tconst completeMessage = JSON.stringify({ ...sharedMessageProps, content: task } satisfies ClineSayTool)\\n 33 | \\t\\t\\tconst didApprove = await askApproval(\\\"tool\\\", completeMessage)\\n----\\n 47 | \\t\\t\\tconst diffStrategy = cline.diffStrategy\\n 48 | \\t\\t\\tconst context = provider?.context\\n 49 | \\t\\t\\tconst content = await fetchInstructions(task, { mcpHub, diffStrategy, context })\\n 50 | \\n 51 | \\t\\t\\tif (!content) {\\n 52 | \\t\\t\\t\\tpushToolResult(formatResponse.toolError(`Invalid instructions request: ${task}`))\\n 53 | \\t\\t\\t\\treturn\\n----\\n\\n# src/core/tools/searchAndReplaceTool.ts\\n  6 | // Internal imports\\n  7 | import { Task } from \\\"../task/Task\\\"\\n  8 | import { AskApproval, HandleError, PushToolResult, RemoveClosingTag, ToolUse } from \\\"../../shared/tools\\\"\\n----\\n 12 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n 13 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 14 | \\n----\\n\\n# src/core/tools/attemptCompletionTool.ts\\n  4 | \\n  5 | import { Task } from \\\"../task/Task\\\"\\n  6 | import {\\n----\\n 49 | \\n 50 | \\t\\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n 51 | \\t\\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n 52 | \\n----\\n 83 | \\t\\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", result, undefined, false)\\n 84 | \\t\\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n 85 | \\t\\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n 86 | \\t\\t\\t\\t}\\n----\\n108 | \\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", result, undefined, false)\\n109 | \\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n110 | \\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n111 | \\t\\t\\t}\\n----\\n119 | \\n120 | \\t\\t\\t\\t// tell the provider to remove the current subtask and resume the previous task in the stack\\n121 | \\t\\t\\t\\tawait cline.providerRef.deref()?.finishSubTask(result)\\n----\\n131 | \\t\\t\\t// cline never happens since yesButtonClicked\\n132 | \\t\\t\\t// will trigger a new task).\\n133 | \\t\\t\\tif (response === \\\"yesButtonClicked\\\") {\\n----\\n150 | \\t\\t\\t\\ttype: \\\"text\\\",\\n151 | \\t\\t\\t\\ttext: `The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.\\\\n<feedback>\\\\n${text}\\\\n</feedback>`,\\n152 | \\t\\t\\t})\\n----\\n\\n# src/core/tools/listCodeDefinitionNamesTool.ts\\n  4 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  5 | import { Task } from \\\"../task/Task\\\"\\n  6 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n  9 | import { parseSourceCodeForDefinitionsTopLevel, parseSourceCodeDefinitionsForFile } from \\\"../../services/tree-sitter\\\"\\n 10 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 11 | \\n----\\n\\n# src/core/tools/searchFilesTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/useMcpToolTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/applyDiffTool.ts\\n  7 | import { getReadablePath } from \\\"../../utils/path\\\"\\n  8 | import { Task } from \\\"../task/Task\\\"\\n  9 | import { ToolUse, RemoveClosingTag, AskApproval, HandleError, PushToolResult } from \\\"../../shared/tools\\\"\\n----\\n 11 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n 12 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 13 | import { unescapeHtmlEntities } from \\\"../../utils/text-normalization\\\"\\n----\\n108 | \\t\\t\\t\\tlet formattedError = \\\"\\\"\\n109 | \\t\\t\\t\\tTelemetryService.instance.captureDiffApplicationError(cline.taskId, currentCount)\\n110 | \\n----\\n\\n# src/core/tools/askFollowupQuestionTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/prompts/instructions/create-mode.ts\\n  5 | \\n  6 | export async function createModeInstructions(context: vscode.ExtensionContext | undefined): Promise<string> {\\n  7 | \\tif (!context) throw new Error(\\\"Missing VSCode Extension Context\\\")\\n  8 | \\n  9 | \\tconst settingsDir = path.join(context.globalStorageUri.fsPath, \\\"settings\\\")\\n 10 | \\tconst customModesPath = path.join(settingsDir, GlobalFileNames.customModes)\\n----\\n 28 | - The following fields are optional but highly recommended:\\n 29 |   * whenToUse: A clear description of when this mode should be selected and what types of tasks it's best suited for. This helps the Orchestrator mode make better decisions.\\n 30 |   * customInstructions: Additional instructions for how the mode should operate\\n----\\n\\n# src/core/tools/browserActionTool.ts\\n  1 | import { Task } from \\\"../task/Task\\\"\\n  2 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/readFileTool.ts\\n  3 | \\n  4 | import { Task } from \\\"../task/Task\\\"\\n  5 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n  8 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  9 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 10 | import { isPathOutsideWorkspace } from \\\"../../utils/pathUtils\\\"\\n----\\n 29 | \\t\\t\\t\\t// Modified part for single file\\n 30 | \\t\\t\\t\\treturn `[${blockName} for '${paths[0]}'. Reading multiple files at once is more efficient for the LLM. If other files are relevant to your current task, please read them simultaneously.]`\\n 31 | \\t\\t\\t} else if (paths.length <= 3) {\\n----\\n 43 | \\t\\t// Modified part for single file (legacy)\\n 44 | \\t\\treturn `[${blockName} for '${blockParams.path}'. Reading multiple files at once is more efficient for the LLM. If other files are relevant to your current task, please read them simultaneously.]`\\n 45 | \\t} else {\\n----\\n\\n# src/core/tools/newTaskTool.ts\\n  3 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n  4 | import { Task } from \\\"../task/Task\\\"\\n  5 | import { defaultModeSlug, getModeBySlug } from \\\"../../shared/modes\\\"\\n----\\n 31 | \\t\\t\\t\\tcline.consecutiveMistakeCount++\\n 32 | \\t\\t\\t\\tcline.recordToolError(\\\"new_task\\\")\\n 33 | \\t\\t\\t\\tpushToolResult(await cline.sayAndCreateMissingParamError(\\\"new_task\\\", \\\"mode\\\"))\\n 34 | \\t\\t\\t\\treturn\\n----\\n 38 | \\t\\t\\t\\tcline.consecutiveMistakeCount++\\n 39 | \\t\\t\\t\\tcline.recordToolError(\\\"new_task\\\")\\n 40 | \\t\\t\\t\\tpushToolResult(await cline.sayAndCreateMissingParamError(\\\"new_task\\\", \\\"message\\\"))\\n 41 | \\t\\t\\t\\treturn\\n----\\n 44 | \\t\\t\\tcline.consecutiveMistakeCount = 0\\n 45 | \\t\\t\\t// Un-escape one level of backslashes before '@' for hierarchical subtasks\\n 46 | // Un-escape one level: \\\\\\\\@ -> \\\\@ (removes one backslash for hierarchical subtasks)\\n 47 | \\t\\t\\tconst unescapedMessage = message.replace(/\\\\\\\\\\\\\\\\@/g, \\\"\\\\\\\\@\\\")\\n----\\n 81 | \\n 82 | \\t\\t\\t// Switch mode first, then create new task instance.\\n 83 | \\t\\t\\tawait provider.handleModeSwitch(mode)\\n----\\n 88 | \\t\\t\\tconst newCline = await provider.initClineWithTask(unescapedMessage, undefined, cline)\\n 89 | \\t\\t\\tcline.emit(\\\"taskSpawned\\\", newCline.taskId)\\n 90 | \\n 91 | \\t\\t\\tpushToolResult(`Successfully created new task in ${targetMode.name} mode with message: ${unescapedMessage}`)\\n 92 | \\n 93 | \\t\\t\\t// Set the isPaused flag to true so the parent\\n 94 | \\t\\t\\t// task can wait for the sub-task to finish.\\n 95 | \\t\\t\\tcline.isPaused = true\\n 96 | \\t\\t\\tcline.emit(\\\"taskPaused\\\")\\n 97 | \\n----\\n100 | \\t} catch (error) {\\n101 | \\t\\tawait handleError(\\\"creating new task\\\", error)\\n102 | \\t\\treturn\\n----\\n\\n# src/core/tools/multiApplyDiffTool.ts\\n  7 | import { getReadablePath } from \\\"../../utils/path\\\"\\n  8 | import { Task } from \\\"../task/Task\\\"\\n  9 | import { ToolUse, RemoveClosingTag, AskApproval, HandleError, PushToolResult } from \\\"../../shared/tools\\\"\\n----\\n 11 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n 12 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 13 | import { unescapeHtmlEntities } from \\\"../../utils/text-normalization\\\"\\n----\\n429 | \\n430 | \\t\\t\\t\\t\\tTelemetryService.instance.captureDiffApplicationError(cline.taskId, currentCount)\\n431 | \\n----\\n\\n# src/core/tools/accessMcpResourceTool.ts\\n  2 | import { ToolUse, RemoveClosingTag, AskApproval, HandleError, PushToolResult } from \\\"../../shared/tools\\\"\\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { formatResponse } from \\\"../prompts/responses\\\"\\n----\\n\\n# src/core/prompts/instructions/create-mcp-server.ts\\n 11 | \\n 12 | When creating MCP servers, it's important to understand that they operate in a non-interactive environment. The server cannot initiate OAuth flows, open browser windows, or prompt for user input during runtime. All credentials and authentication tokens must be provided upfront through environment variables in the MCP settings configuration. For example, Spotify's API uses OAuth to get a refresh token for the user, but the MCP server cannot initiate this flow. While you can walk the user through  [truncated...]\\n 13 | \\n----\\n 63 | cd ${await mcpHub.getMcpServersPath()}\\n 64 | npx @modelcontextprotocol/create-server weather-server\\n 65 | cd weather-server\\n 66 | # Install dependencies\\n 67 | npm install axios zod @modelcontextprotocol/sdk\\n 68 | \\\\`\\\\`\\\\`\\n----\\n 76 | \\t\\t\\t\\t...\\n 77 | \\t\\t\\t\\t\\\"type\\\": \\\"module\\\", // added by default, uses ES module syntax (import/export) rather than CommonJS (require/module.exports) (Important to know if you create additional scripts in this server repository like a get-refresh-token.js script)\\n 78 | \\t\\t\\t\\t\\\"scripts\\\": {\\n----\\n 92 | #!/usr/bin/env node\\n 93 | import { McpServer, ResourceTemplate } from \\\"@modelcontextprotocol/sdk/server/mcp.js\\\";\\n 94 | import { StdioServerTransport } from \\\"@modelcontextprotocol/sdk/server/stdio.js\\\";\\n 95 | import { z } from \\\"zod\\\";\\n----\\n316 | \\n317 | The user may not always request the use or creation of MCP servers. Instead, they might provide tasks that can be completed with existing tools. While using the MCP SDK to extend your capabilities can be useful, it's important to understand that this is just one specialized type of task you can accomplish. You should only implement MCP servers when the user explicitly requests it (e.g., \\\"add a tool that...\\\").\\n318 | \\n319 | Remember: The MCP documentation and example provided above are to help you understand and work with existing MCP servers or create new ones when requested by the user. You already have access to tools and capabilities that can be used to accomplish a wide range of tasks.`\\n320 | }\\n----\\n\\n# src/core/tools/switchModeTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n\\n# src/core/tools/insertContentTool.ts\\n  5 | import { getReadablePath } from \\\"../../utils/path\\\"\\n  6 | import { Task } from \\\"../task/Task\\\"\\n  7 | import { ToolUse, AskApproval, HandleError, PushToolResult, RemoveClosingTag } from \\\"../../shared/tools\\\"\\n----\\n  9 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n 10 | import { RecordSource } from \\\"../context-tracking/FileContextTrackerTypes\\\"\\n 11 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n----\\n\\n# src/core/tools/executeCommandTool.ts\\n  8 | \\n  9 | import { Task } from \\\"../task/Task\\\"\\n 10 | \\n----\\n194 | \\t\\tcallbacks.onNoShellIntegration = async (error: string) => {\\n195 | \\t\\t\\tTelemetryService.instance.captureShellIntegrationError(cline.taskId)\\n196 | \\t\\t\\tshellIntegrationError = error\\n----\\n199 | \\n200 | \\tconst terminal = await TerminalRegistry.getOrCreateTerminal(workingDir, !!customCwd, cline.taskId, terminalProvider)\\n201 | \\n----\\n\\n# src/core/prompts/sections/mcp-servers.ts\\n 74 | <fetch_instructions>\\n 75 | <task>create_mcp_server</task>\\n 76 | </fetch_instructions>`\\n----\\n\\n# src/core/prompts/responses.ts\\n 13 | \\ttoolApprovedWithFeedback: (feedback?: string) =>\\n 14 | \\t\\t`The user approved this operation and provided the following context:\\\\n<feedback>\\\\n${feedback}\\\\n</feedback>`,\\n 15 | \\n----\\n 18 | \\trooIgnoreError: (path: string) =>\\n 19 | \\t\\t`Access to ${path} is blocked by the .rooignore file settings. You must try to continue in the task without using this file, or ask the user to update the .rooignore file.`,\\n 20 | \\n----\\n 27 | \\n 28 | If you have completed the user's task, use the attempt_completion tool.\\n 29 | If you require additional information from the user, use the ask_followup_question tool.\\n 30 | Otherwise, if you have not completed the task and do not need additional information, then proceed with the next step of the task.\\n 31 | (This is an automated message, so do not respond to it conversationally.)`,\\n----\\n206 | <result>\\n207 | I have completed the task...\\n208 | </result>\\n----\\n\\n# src/core/prompts/sections/capabilities.ts\\n 17 | \\t\\tsupportsComputerUse ? \\\", use the browser\\\" : \\\"\\\"\\n 18 | \\t}, read and write files, and ask follow-up questions. These tools help you effectively accomplish a wide range of tasks, such as writing code, making edits or improvements to existing files, understanding the current state of a project, performing system operations, and much more.\\n 19 | - When the user initially gives you a task, a recursive list of all filepaths in the current workspace directory ('${cwd}') will be included in environment_details. This provides an overview of the project's file structure, offering key insights into the project from directory/file names (how developers conceptualize and organize their code) and file extensions (the language used). This can also guide decision-making on which files to explore further. If you need to further explore directories s [truncated...]\\n 20 | \\t\\tcodeIndexManager &&\\n----\\n 27 | \\t}\\n 28 | - You can use search_files to perform regex searches across files in a specified directory, outputting context-rich results that include surrounding lines. This is particularly useful for understanding code patterns, finding specific implementations, or identifying areas that need refactoring.\\n 29 | - You can use the list_code_definition_names tool to get an overview of source code definitions for all files at the top level of a specified directory. This can be particularly useful when you need to understand the broader context and relationships between certain parts of the code. You may need to call this tool multiple times to understand various parts of the codebase related to the task.\\n 30 |     - For example, when asked to make edits or improvements you might analyze the file structure in the initial environment_details to get an overview of the project, then use list_code_definition_names to get further insight using source code definitions for files located in relevant directories, then read_file to examine the contents of relevant files, analyze the code and suggest improvements or make necessary edits, then use ${diffStrategy ? \\\"the apply_diff or write_to_file\\\" : \\\"the write_to_ [truncated...]\\n 31 | - You can use the execute_command tool to run commands on the user's computer whenever you feel it can help accomplish the user's task. When you need to execute a CLI command, you must provide a clear explanation of what the command does. Prefer to execute complex CLI commands over creating executable scripts, since they are more flexible and easier to run. Interactive and long-running commands are allowed, since the commands are run in the user's VSCode terminal. The user may keep commands runn [truncated...]\\n 32 | \\t\\tsupportsComputerUse\\n 33 | \\t\\t\\t? \\\"\\\\n- You can use the browser_action tool to interact with websites (including html files and locally running development servers) through a Puppeteer-controlled browser when you feel it is necessary in accomplishing the user's task. This tool is particularly useful for web development tasks as it allows you to launch a browser, navigate to pages, interact with elements through clicks and keyboard input, and capture the results through screenshots and console logs. This tool may be useful at [truncated...]\\n 34 | \\t\\t\\t: \\\"\\\"\\n----\\n 37 | \\t\\t\\t? `\\n 38 | - You have access to MCP servers that may provide additional tools and resources. Each server may provide different capabilities that you can use to accomplish tasks more effectively.\\n 39 | `\\n----\\n\\n# src/core/tools/__tests__/newTaskTool.test.ts\\n 11 | // Define a minimal type for the resolved value\\n 12 | type MockClineInstance = { taskId: string }\\n 13 | // Make initClineWithTask return a mock Cline-like object with taskId, providing type hint\\n 14 | const mockInitClineWithTask = jest\\n 15 | \\t.fn<() => Promise<MockClineInstance>>()\\n 16 | \\t.mockResolvedValue({ taskId: \\\"mock-subtask-id\\\" })\\n 17 | const mockEmit = jest.fn()\\n----\\n 66 | \\n 67 | \\tit(\\\"should correctly un-escape \\\\\\\\\\\\\\\\@ to \\\\\\\\@ in the message passed to the new task\\\", async () => {\\n 68 | \\t\\tconst block: ToolUse = {\\n 69 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n 70 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n 71 | \\t\\t\\tparams: {\\n----\\n 97 | \\t\\t// Verify side effects\\n 98 | \\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\\"taskSpawned\\\", expect.any(String)) // Assuming initCline returns a mock task ID\\n 99 | \\t\\texpect(mockCline.isPaused).toBe(true)\\n100 | \\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\\"taskPaused\\\")\\n101 | \\t\\texpect(mockPushToolResult).toHaveBeenCalledWith(expect.stringContaining(\\\"Successfully created new task\\\"))\\n102 | \\t})\\n----\\n106 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n107 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n108 | \\t\\t\\tparams: {\\n----\\n133 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n134 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n135 | \\t\\t\\tparams: {\\n----\\n160 | \\t\\t\\ttype: \\\"tool_use\\\", // Add required 'type' property\\n161 | \\t\\t\\tname: \\\"new_task\\\", // Correct property name\\n162 | \\t\\t\\tparams: {\\n----\\n\\n# src/core/tools/__tests__/writeToFileTool.test.ts\\n145 | \\t\\t\\t\\tthis: any,\\n146 | \\t\\t\\t\\ttask: any,\\n147 | \\t\\t\\t\\tcwd: string,\\n----\\n151 | \\t\\t\\t\\tif (this.userEdits) {\\n152 | \\t\\t\\t\\t\\tawait task.say(\\n153 | \\t\\t\\t\\t\\t\\t\\\"user_feedback_diff\\\",\\n----\\n\\n# src/core/tools/__tests__/useMcpToolTool.test.ts\\n  1 | import { useMcpToolTool } from \\\"../useMcpToolTool\\\"\\n  2 | import { Task } from \\\"../../task/Task\\\"\\n  3 | import { ToolUse } from \\\"../../../shared/tools\\\"\\n----\\n\\n# src/core/tools/__tests__/executeCommandTool.spec.ts\\n  6 | \\n  7 | import { Task } from \\\"../../task/Task\\\"\\n  8 | import { formatResponse } from \\\"../../prompts/responses\\\"\\n----\\n 16 | \\n 17 | vitest.mock(\\\"../../task/Task\\\")\\n 18 | vitest.mock(\\\"../../prompts/responses\\\")\\n----\\n\\n# src/core/prompts/sections/modes.ts\\n  8 | \\n  9 | export async function getModesSection(context: vscode.ExtensionContext): Promise<string> {\\n 10 | \\tconst settingsDir = path.join(context.globalStorageUri.fsPath, \\\"settings\\\")\\n 11 | \\tawait fs.mkdir(settingsDir, { recursive: true })\\n----\\n 13 | \\t// Get all modes with their overrides from extension state\\n 14 | \\tconst allModes = await getAllModesWithPrompts(context)\\n 15 | \\n----\\n 37 | <fetch_instructions>\\n 38 | <task>create_mode</task>\\n 39 | </fetch_instructions>\\n----\\n\\n# src/core/tools/__tests__/attemptCompletionTool.experiment.test.ts\\n  1 | import { Task } from \\\"../../task/Task\\\"\\n  2 | import { attemptCompletionTool } from \\\"../attemptCompletionTool\\\"\\n----\\n 49 | \\t\\t\\tuserMessageContent: [],\\n 50 | \\t\\t\\ttaskId: \\\"test-task-id\\\",\\n 51 | \\t\\t\\tproviderRef: {\\n----\\n103 | \\t\\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\n104 | \\t\\t\\t\\t\\\"taskCompleted\\\",\\n105 | \\t\\t\\t\\tmockCline.taskId,\\n106 | \\t\\t\\t\\texpect.any(Object),\\n----\\n146 | \\t\\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\n147 | \\t\\t\\t\\t\\\"taskCompleted\\\",\\n148 | \\t\\t\\t\\tmockCline.taskId,\\n149 | \\t\\t\\t\\texpect.any(Object),\\n----\\n224 | \\t\\t\\texpect(mockCline.emit).toHaveBeenCalledWith(\\n225 | \\t\\t\\t\\t\\\"taskCompleted\\\",\\n226 | \\t\\t\\t\\tmockCline.taskId,\\n227 | \\t\\t\\t\\texpect.any(Object),\\n----\\n\\n# src/core/prompts/sections/tool-use.ts\\n  5 | \\n  6 | You have access to a set of tools that are executed upon the user's approval. You can use one tool per message, and will receive the result of that tool use in the user's response. You use tools step-by-step to accomplish a given task, with each tool use informed by the result of the previous tool use.\\n  7 | \\n----\\n 17 | \\n 18 | For example, to use the new_task tool:\\n 19 | \\n 20 | <new_task>\\n 21 | <mode>code</mode>\\n 22 | <message>Implement a new feature for the application.</message>\\n 23 | </new_task>\\n 24 | \\n----\\n\\n# src/core/prompts/sections/system-info.ts\\n 15 | \\n 16 | The Current Workspace Directory is the active VS Code project directory, and is therefore the default directory for all tool operations. New terminals will be created in the current workspace directory, however if you change directories in a terminal it will then have a different working directory; changing directories in a terminal does not modify the workspace directory, because you do not have access to change the workspace directory. When the user initially gives you a task, a recursive list [truncated...]\\n 17 | \\n----\\n\\n# src/core/prompts/sections/__tests__/tool-use-guidelines.test.ts\\n 24 | \\t\\t\\texpect(guidelines).toContain(\\n 25 | \\t\\t\\t\\t\\\"IMPORTANT: When starting a new task or when you need to understand existing code/functionality, you MUST use the `codebase_search` tool FIRST\\\",\\n 26 | \\t\\t\\t)\\n----\\n 52 | \\t\\t\\texpect(guidelines).not.toContain(\\n 53 | \\t\\t\\t\\t\\\"IMPORTANT: When starting a new task or when you need to understand existing code/functionality, you MUST use the `codebase_search` tool FIRST\\\",\\n 54 | \\t\\t\\t)\\n----\\n\\n# src/core/prompts/sections/rules.ts\\n 69 | - All file paths must be relative to this directory. However, commands may change directories in terminals, so respect working directory specified by the response to <execute_command>.\\n 70 | - You cannot \\\\`cd\\\\` into a different directory to complete a task. You are stuck operating from '${cwd.toPosix()}', so be sure to pass in the correct 'path' parameter when using tools that require a path.\\n 71 | - Do not use the ~ character or $HOME to refer to the home directory.\\n 72 | - Before using the execute_command tool, you must first think about the SYSTEM INFORMATION context provided to understand the user's environment and tailor your commands to ensure they are compatible with their system. You must also consider if the command you need to run should be executed in a specific directory outside of the current working directory '${cwd.toPosix()}', and if so prepend with \\\\`cd\\\\`'ing into that directory && then executing the command (as one command since you are stuck ope [truncated...]\\n 73 | ${codebaseSearchRule}- When using the search_files tool${isCodebaseSearchAvailable ? \\\" (after codebase_search)\\\" : \\\"\\\"}, craft your regex patterns carefully to balance specificity and flexibility. Based on the user's task you may use it to find code patterns, TODO comments, function definitions, or any text-based information across the project. The results include context, so analyze the surrounding code to better understand the matches. Leverage the search_files tool in combination with other too [truncated...]\\n 74 | - When creating a new project (such as an app, website, or any software project), organize all new files within a dedicated project directory unless the user specifies otherwise. Use appropriate file paths when writing files, as the write_to_file tool will automatically create any necessary directories. Structure the project logically, adhering to best practices for the specific type of project being created. Unless otherwise specified, new projects should be easily run without additional setup, [truncated...]\\n----\\n 76 | - Some modes have restrictions on which files they can edit. If you attempt to edit a restricted file, the operation will be rejected with a FileRestrictionError that will specify which file patterns are allowed for the current mode.\\n 77 | - Be sure to consider the type of project (e.g. Python, JavaScript, web application) when determining the appropriate structure and files to include. Also consider what files may be most relevant to accomplishing the task, for example looking at a project's manifest file would help you understand the project's dependencies, which you could incorporate into any code you write.\\n 78 |   * For example, in architect mode trying to edit app.js would be rejected because architect mode can only edit files matching \\\"\\\\\\\\.md$\\\"\\n 79 | - When making changes to code, always consider the context in which the code is being used. Ensure that your changes are compatible with the existing codebase and that they follow the project's coding standards and best practices.\\n 80 | - Do not ask for more information than necessary. Use the tools provided to accomplish the user's request efficiently and effectively. When you've completed your task, you must use the attempt_completion tool to present the result to the user. The user may provide feedback, which you can use to make improvements and try again.\\n 81 | - You are only allowed to ask the user questions using the ask_followup_question tool. Use this tool only when you need additional details to complete a task, and be sure to use a clear and concise question that will help you move forward with the task. When you ask a question, provide the user with 2-4 suggested answers based on your question so they don't need to do so much typing. The suggestions should be specific, actionable, and directly related to the completed task. They should be ordere [truncated...]\\n 82 | - When executing commands, if you don't see the expected output, assume the terminal executed the command successfully and proceed with the task. The user's terminal may be unable to stream the output back properly. If you absolutely need to see the actual terminal output, use the ask_followup_question tool to request the user to copy and paste it back to you.\\n 83 | - The user may provide a file's contents directly in their message, in which case you shouldn't use the read_file tool to get the file contents again since you already have it.\\n 84 | - Your goal is to try to accomplish the user's task, NOT engage in a back and forth conversation.${\\n 85 | \\t\\tsupportsComputerUse\\n 86 | \\t\\t\\t? '\\\\n- The user may ask generic non-development tasks, such as \\\"what\\\\'s the latest news\\\" or \\\"look up the weather in San Diego\\\", in which case you might use the browser_action tool to complete the task if it makes sense to do so, rather than trying to create a website or using curl to answer the question. However, if an available MCP server tool or resource can be used instead, you should prefer to use it over browser_action.'\\n 87 | \\t\\t\\t: \\\"\\\"\\n----\\n 90 | - You are STRICTLY FORBIDDEN from starting your messages with \\\"Great\\\", \\\"Certainly\\\", \\\"Okay\\\", \\\"Sure\\\". You should NOT be conversational in your responses, but rather direct and to the point. For example you should NOT say \\\"Great, I've updated the CSS\\\" but instead something like \\\"I've updated the CSS\\\". It is important you be clear and technical in your messages.\\n 91 | - When presented with images, utilize your vision capabilities to thoroughly examine them and extract meaningful information. Incorporate these insights into your thought process as you accomplish the user's task.\\n 92 | - At the end of each user message, you will automatically receive environment_details. This information is not written by the user themselves, but is auto-generated to provide potentially relevant context about the project structure and environment. While this information can be valuable for understanding the project context, do not treat it as a direct part of the user's request or response. Use it to inform your actions and decisions, but don't assume the user is explicitly asking about or ref [truncated...]\\n 93 | - Before executing commands, check the \\\"Actively Running Terminals\\\" section in environment_details. If present, consider how these active processes might impact your task. For example, if a local development server is already running, you wouldn't need to start it again. If no active terminals are listed, proceed with command execution as normal.\\n 94 | - MCP operations should be used one at a time, similar to other tool usage. Wait for confirmation of success before proceeding with additional operations.\\n----\\n\\n# src/core/prompts/sections/__tests__/objective.test.ts\\n 24 | \\t\\t\\texpect(objective).toContain(\\n 25 | \\t\\t\\t\\t\\\"if the task involves understanding existing code or functionality, you MUST use the `codebase_search` tool\\\",\\n 26 | \\t\\t\\t)\\n----\\n 46 | \\t\\tfor (const objective of [objectiveEnabled, objectiveDisabled]) {\\n 47 | \\t\\t\\texpect(objective).toContain(\\\"1. Analyze the user's task\\\")\\n 48 | \\t\\t\\texpect(objective).toContain(\\\"2. Work through these goals sequentially\\\")\\n 49 | \\t\\t\\texpect(objective).toContain(\\\"3. Remember, you have extensive capabilities\\\")\\n 50 | \\t\\t\\texpect(objective).toContain(\\\"4. Once you've completed the user's task\\\")\\n 51 | \\t\\t\\texpect(objective).toContain(\\\"5. The user may provide feedback\\\")\\n----\\n\\n# src/core/tools/codebaseSearchTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { CodeIndexManager } from \\\"../../services/code-index/manager\\\"\\n----\\n 66 | \\ttry {\\n 67 | \\t\\tconst context = cline.providerRef.deref()?.context\\n 68 | \\t\\tif (!context) {\\n 69 | \\t\\t\\tthrow new Error(\\\"Extension context is not available.\\\")\\n 70 | \\t\\t}\\n 71 | \\n 72 | \\t\\tconst manager = CodeIndexManager.getInstance(context)\\n 73 | \\n----\\n\\n# src/core/tools/listFilesTool.ts\\n  2 | \\n  3 | import { Task } from \\\"../task/Task\\\"\\n  4 | import { ClineSayTool } from \\\"../../shared/ExtensionMessage\\\"\\n----\\n\\n# src/core/prompts/sections/tool-use-guidelines.ts\\n 15 | \\tguidelinesList.push(\\n 16 | \\t\\t`${itemNumber++}. In <thinking> tags, assess what information you already have and what information you need to proceed with the task.`,\\n 17 | \\t)\\n----\\n 21 | \\t\\tguidelinesList.push(\\n 22 | \\t\\t\\t`${itemNumber++}. **IMPORTANT: When starting a new task or when you need to understand existing code/functionality, you MUST use the \\\\`codebase_search\\\\` tool FIRST before any other search tools.** This semantic search tool helps you find relevant code based on meaning rather than just keywords. Only after using codebase_search should you use other tools like search_files, list_files, or read_file for more specific exploration.`,\\n 23 | \\t\\t)\\n 24 | \\t\\tguidelinesList.push(\\n 25 | \\t\\t\\t`${itemNumber++}. Choose the most appropriate tool based on the task and the tool descriptions provided. Assess if you need additional information to proceed, and which of the available tools would be most effective for gathering this information. For example using the list_files tool is more effective than running a command like \\\\`ls\\\\` in the terminal. It's critical that you think about each available tool and use the one that best fits the current step in the task.`,\\n 26 | \\t\\t)\\n----\\n 28 | \\t\\tguidelinesList.push(\\n 29 | \\t\\t\\t`${itemNumber++}. Choose the most appropriate tool based on the task and the tool descriptions provided. Assess if you need additional information to proceed, and which of the available tools would be most effective for gathering this information. For example using the list_files tool is more effective than running a command like \\\\`ls\\\\` in the terminal. It's critical that you think about each available tool and use the one that best fits the current step in the task.`,\\n 30 | \\t\\t)\\n----\\n 34 | \\tguidelinesList.push(\\n 35 | \\t\\t`${itemNumber++}. If multiple actions are needed, use one tool at a time per message to accomplish the task iteratively, with each tool use being informed by the result of the previous tool use. Do not assume the outcome of any tool use. Each step must be informed by the previous step's result.`,\\n 36 | \\t)\\n 37 | \\tguidelinesList.push(`${itemNumber++}. Formulate your tool use using the XML format specified for each tool.`)\\n 38 | \\tguidelinesList.push(`${itemNumber++}. After each tool use, the user will respond with the result of that tool use. This result will provide you with the necessary information to continue your task or make further decisions. This response may include:\\n 39 |   - Information about whether the tool succeeded or failed, along with any reasons for failure.\\n----\\n 51 | \\n 52 | It is crucial to proceed step-by-step, waiting for the user's message after each tool use before moving forward with the task. This approach allows you to:\\n 53 | 1. Confirm the success of each step before proceeding.\\n----\\n 57 | \\n 58 | By waiting for and carefully considering the user's response after each tool use, you can react accordingly and make informed decisions about how to proceed with the task. This iterative process helps ensure the overall success and accuracy of your work.`\\n 59 | }\\n----\\n\\n# src/core/prompts/sections/objective.ts\\n 14 | \\tconst codebaseSearchInstruction = isCodebaseSearchAvailable\\n 15 | \\t\\t? \\\"First, if the task involves understanding existing code or functionality, you MUST use the `codebase_search` tool to search for relevant code based on the task's intent BEFORE using any other search or file exploration tools. Then, \\\"\\n 16 | \\t\\t: \\\"First, \\\"\\n----\\n 21 | \\tconst commandInstruction = !isCommandDisabled\\n 22 | \\t\\t? \\\" You may also provide a CLI command to showcase the result of your task; this can be particularly useful for web development tasks, where you can run e.g. \\\\`open index.html\\\\` to show the website you've built.\\\"\\n 23 | \\t\\t: \\\"\\\"\\n----\\n 28 | \\n 29 | You accomplish a given task iteratively, breaking it down into clear steps and working through them methodically.\\n 30 | \\n 31 | 1. Analyze the user's task and set clear, achievable goals to accomplish it. Prioritize these goals in a logical order.\\n 32 | 2. Work through these goals sequentially, utilizing available tools one at a time as necessary. Each goal should correspond to a distinct step in your problem-solving process. You will be informed on the work completed and what's remaining as you go.\\n 33 | 3. Remember, you have extensive capabilities with access to a wide range of tools that can be used in powerful and clever ways as necessary to accomplish each goal. Before calling a tool, do some analysis within <thinking></thinking> tags. ${codebaseSearchInstruction}analyze the file structure provided in environment_details to gain context and insights for proceeding effectively. Next, think about which of the provided tools is the most relevant tool to accomplish the user's task. Go through ea [truncated...]\\n 34 | 4. Once you've completed the user's task, you must use the attempt_completion tool to present the result of the task to the user.${commandInstruction}\\n 35 | 5. The user may provide feedback, which you can use to make improvements and try again. But DO NOT continue in pointless back and forth conversations, i.e. don't end your responses with questions or offers for further assistance.`\\n----\\n\\n# src/api/providers/human-relay.ts\\n 69 | \\t\\t\\t\\tmaxTokens: 16384,\\n 70 | \\t\\t\\t\\tcontextWindow: 100000,\\n 71 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n\\n# src/core/prompts/tools/read-file.ts\\n 73 | - ${isMultipleReadsEnabled ? `You MUST read all related files and implementations together in a single operation (up to ${maxConcurrentReads} files at once)` : \\\"You MUST read files one at a time, as multiple file reads are currently disabled\\\"}\\n 74 | - You MUST obtain all necessary context before proceeding with changes\\n 75 | ${\\n----\\n 79 | - You MUST use multiple ranges for content separated by >10 lines\\n 80 | - You MUST include sufficient line context for planned modifications while keeping ranges minimal\\n 81 | `\\n----\\n\\n# src/core/tools/__tests__/readFileTool.test.ts\\n120 | \\t\\tmockCline.cwd = \\\"/\\\"\\n121 | \\t\\tmockCline.task = \\\"Test\\\"\\n122 | \\t\\tmockCline.providerRef = mockProvider\\n----\\n429 | \\t\\tmockCline.cwd = \\\"/\\\"\\n430 | \\t\\tmockCline.task = \\\"Test\\\"\\n431 | \\t\\tmockCline.providerRef = mockProvider\\n----\\n961 | \\t\\t\\texpect(result).toBe(\\n962 | \\t\\t\\t\\t`<files>\\\\n<file><path>${testFilePath}</path><error>Access to ${testFilePath} is blocked by the .rooignore file settings. You must try to continue in the task without using this file, or ask the user to update the .rooignore file.</error></file>\\\\n</files>`,\\n963 | \\t\\t\\t)\\n----\\n\\n# src/api/providers/base-provider.ts\\n 21 | \\t/**\\n 22 | \\t * Default token counting implementation using tiktoken.\\n 23 | \\t * Providers can override this to use their native token counting endpoints.\\n 24 | \\t *\\n 25 | \\t * @param content The content to count tokens for\\n 26 | \\t * @returns A promise resolving to the token count\\n 27 | \\t */\\n----\\n\\n# src/core/prompts/tools/attempt-completion.ts\\n  9 | \\tconst baseDescription = `## attempt_completion\\n 10 | Description: After each tool use, the user will respond with the result of that tool use, i.e. if it succeeded or failed, along with any reasons for failure. Once you've received the results of tool uses and can confirm that the task is complete, use this tool to present the result of your work to the user.${!isCommandDisabled ? \\\" Optionally you may provide a CLI command to showcase the result of your work.\\\" : \\\"\\\"} The user may respond with feedback if they are not satisfied with the result, whic [truncated...]\\n 11 | IMPORTANT NOTE: This tool CANNOT be used until you've confirmed from the user that any previous tool uses were successful. Failure to do so will result in code corruption and system failure. Before using this tool, you must ask yourself in <thinking></thinking> tags if you've confirmed from the user that any previous tool uses were successful. If not, then DO NOT use this tool.\\n 12 | Parameters:\\n 13 | - result: (required) The result of the task. Formulate this result in a way that is final and does not require further input from the user. Don't end your result with questions or offers for further assistance.`\\n 14 | \\n----\\n\\n# src/core/assistant-message/__tests__/parseAssistantMessage.test.ts\\n294 | \\t\\t\\tit(\\\"should handle a complex message with multiple content types\\\", () => {\\n295 | \\t\\t\\t\\tconst message = `I'll help you with that task.\\n296 | \\n----\\n315 | \\t\\t\\t\\texpect(result[0].type).toBe(\\\"text\\\")\\n316 | \\t\\t\\t\\texpect((result[0] as TextContent).content).toBe(\\\"I'll help you with that task.\\\")\\n317 | \\n----\\n\\n# src/core/assistant-message/presentAssistantMessage.ts\\n 31 | import { validateToolUse } from \\\"../tools/validateToolUse\\\"\\n 32 | import { Task } from \\\"../task/Task\\\"\\n 33 | import { codebaseSearchTool } from \\\"../tools/codebaseSearchTool\\\"\\n----\\n 55 | \\tif (cline.abort) {\\n 56 | \\t\\tthrow new Error(`[Task#presentAssistantMessage] task ${cline.taskId}.${cline.instanceId} aborted`)\\n 57 | \\t}\\n----\\n159 | \\t\\t\\t\\t\\tcase \\\"fetch_instructions\\\":\\n160 | \\t\\t\\t\\t\\t\\treturn `[${block.name} for '${block.params.task}']`\\n161 | \\t\\t\\t\\t\\tcase \\\"write_to_file\\\":\\n----\\n207 | \\t\\t\\t\\t\\t\\treturn `[${block.name} for '${block.params.query}']`\\n208 | \\t\\t\\t\\t\\tcase \\\"new_task\\\": {\\n209 | \\t\\t\\t\\t\\t\\tconst mode = block.params.mode ?? defaultModeSlug\\n----\\n295 | \\t\\t\\tconst askFinishSubTaskApproval = async () => {\\n296 | \\t\\t\\t\\t// Ask the user to approve this task has completed, and he has\\n297 | \\t\\t\\t\\t// reviewed it, and we can declare task is finished and return\\n298 | \\t\\t\\t\\t// control to the parent task to continue running the rest of\\n299 | \\t\\t\\t\\t// the sub-tasks.\\n300 | \\t\\t\\t\\tconst toolMessage = JSON.stringify({ tool: \\\"finishTask\\\" })\\n----\\n347 | \\t\\t\\t\\tcline.recordToolUsage(block.name)\\n348 | \\t\\t\\t\\tTelemetryService.instance.captureToolUsage(cline.taskId, block.name)\\n349 | \\t\\t\\t}\\n----\\n395 | \\t\\t\\t\\t\\t\\t// Track tool repetition in telemetry.\\n396 | \\t\\t\\t\\t\\t\\tTelemetryService.instance.captureConsecutiveMistakeError(cline.taskId)\\n397 | \\t\\t\\t\\t\\t}\\n----\\n503 | \\t\\t\\t\\t\\tbreak\\n504 | \\t\\t\\t\\tcase \\\"new_task\\\":\\n505 | \\t\\t\\t\\t\\tawait newTaskTool(cline, block, askApproval, handleError, pushToolResult, removeClosingTag)\\n----\\n\\n# src/api/providers/deepseek.ts\\n 32 | \\t\\t\\ttype: \\\"usage\\\",\\n 33 | \\t\\t\\tinputTokens: usage?.prompt_tokens || 0,\\n 34 | \\t\\t\\toutputTokens: usage?.completion_tokens || 0,\\n 35 | \\t\\t\\tcacheWriteTokens: usage?.prompt_tokens_details?.cache_miss_tokens,\\n 36 | \\t\\t\\tcacheReadTokens: usage?.prompt_tokens_details?.cached_tokens,\\n 37 | \\t\\t}\\n----\\n\\n# src/core/prompts/tools/fetch-instructions.ts\\n  2 | \\treturn `## fetch_instructions\\n  3 | Description: Request to fetch instructions to perform a task\\n  4 | Parameters:\\n  5 | - task: (required) The task to get instructions for.  This can take the following values:\\n  6 |   create_mcp_server\\n----\\n 11 | <fetch_instructions>\\n 12 | <task>create_mcp_server</task>\\n 13 | </fetch_instructions>`\\n----\\n\\n# src/api/providers/ollama.ts\\n 79 | \\t\\t\\t\\ttype: \\\"usage\\\",\\n 80 | \\t\\t\\t\\tinputTokens: lastUsage?.prompt_tokens || 0,\\n 81 | \\t\\t\\t\\toutputTokens: lastUsage?.completion_tokens || 0,\\n 82 | \\t\\t\\t}\\n----\\n\\n# src/core/prompts/tools/ask-followup-question.ts\\n  2 | \\treturn `## ask_followup_question\\n  3 | Description: Ask the user a question to gather additional information needed to complete the task. This tool should be used when you encounter ambiguities, need clarification, or require more details to proceed effectively. It allows for interactive problem-solving by enabling direct communication with the user. Use this tool judiciously to maintain a balance between gathering necessary information and avoiding excessive back-and-forth.\\n  4 | Parameters:\\n----\\n  7 |   1. Be provided in its own <suggest> tag\\n  8 |   2. Be specific, actionable, and directly related to the completed task\\n  9 |   3. Be a complete answer to the question - the user should not need to provide additional information or fill in any missing details. DO NOT include placeholders with brackets or parentheses.\\n----\\n\\n# src/utils/__tests__/cost.spec.ts\\n 11 | \\t\\t\\tmaxTokens: 8192,\\n 12 | \\t\\t\\tcontextWindow: 200_000,\\n 13 | \\t\\t\\tsupportsPromptCache: true,\\n 14 | \\t\\t\\tinputPrice: 3.0, // $3 per million tokens\\n 15 | \\t\\t\\toutputPrice: 15.0, // $15 per million tokens\\n 16 | \\t\\t\\tcacheWritesPrice: 3.75, // $3.75 per million tokens\\n 17 | \\t\\t\\tcacheReadsPrice: 0.3, // $0.30 per million tokens\\n 18 | \\t\\t}\\n----\\n 62 | \\t\\t\\t\\tmaxTokens: 8192,\\n 63 | \\t\\t\\t\\tcontextWindow: 200_000,\\n 64 | \\t\\t\\t\\tsupportsPromptCache: true,\\n----\\n 70 | \\n 71 | \\t\\tit(\\\"should handle zero tokens\\\", () => {\\n 72 | \\t\\t\\tconst cost = calculateApiCostAnthropic(mockModelInfo, 0, 0, 0, 0)\\n----\\n104 | \\t\\t\\tmaxTokens: 8192,\\n105 | \\t\\t\\tcontextWindow: 200_000,\\n106 | \\t\\t\\tsupportsPromptCache: true,\\n107 | \\t\\t\\tinputPrice: 3.0, // $3 per million tokens\\n108 | \\t\\t\\toutputPrice: 15.0, // $15 per million tokens\\n109 | \\t\\t\\tcacheWritesPrice: 3.75, // $3.75 per million tokens\\n110 | \\t\\t\\tcacheReadsPrice: 0.3, // $0.30 per million tokens\\n111 | \\t\\t}\\n----\\n155 | \\t\\t\\t\\tmaxTokens: 8192,\\n156 | \\t\\t\\t\\tcontextWindow: 200_000,\\n157 | \\t\\t\\t\\tsupportsPromptCache: true,\\n----\\n163 | \\n164 | \\t\\tit(\\\"should handle zero tokens\\\", () => {\\n165 | \\t\\t\\tconst cost = calculateApiCostOpenAI(mockModelInfo, 0, 0, 0, 0)\\n----\\n\\n# src/api/providers/openai-native.ts\\n146 | \\tprivate async *yieldUsage(info: ModelInfo, usage: OpenAI.Completions.CompletionUsage | undefined): ApiStream {\\n147 | \\t\\tconst inputTokens = usage?.prompt_tokens || 0 // sum of cache hits and misses\\n148 | \\t\\tconst outputTokens = usage?.completion_tokens || 0\\n149 | \\t\\tconst cacheReadTokens = usage?.prompt_tokens_details?.cached_tokens || 0\\n150 | \\t\\tconst cacheWriteTokens = 0\\n----\\n\\n# src/core/prompts/tools/index.ts\\n 22 | import { getSwitchModeDescription } from \\\"./switch-mode\\\"\\n 23 | import { getNewTaskDescription } from \\\"./new-task\\\"\\n 24 | import { getCodebaseSearchDescription } from \\\"./codebase-search\\\"\\n----\\n 42 | \\tswitch_mode: () => getSwitchModeDescription(),\\n 43 | \\tnew_task: (args) => getNewTaskDescription(args),\\n 44 | \\tinsert_content: (args) => getInsertContentDescription(args),\\n----\\n\\n# src/core/prompts/tools/new-task.ts\\n  3 | export function getNewTaskDescription(_args: ToolArgs): string {\\n  4 | \\treturn `## new_task\\n  5 | Description: This will let you create a new task instance in the chosen mode using your provided message.\\n  6 | \\n  7 | Parameters:\\n  8 | - mode: (required) The slug of the mode to start the new task in (e.g., \\\"code\\\", \\\"debug\\\", \\\"architect\\\").\\n  9 | - message: (required) The initial user message or instructions for this new task.\\n 10 | \\n 11 | Usage:\\n 12 | <new_task>\\n 13 | <mode>your-mode-slug-here</mode>\\n 14 | <message>Your initial instructions here</message>\\n 15 | </new_task>\\n 16 | \\n 17 | Example:\\n 18 | <new_task>\\n 19 | <mode>code</mode>\\n 20 | <message>Implement a new feature for the application.</message>\\n 21 | </new_task>\\n 22 | `\\n----\\n\\n# src/api/providers/xai.ts\\n 52 | \\t\\t\\tmodel: modelId,\\n 53 | \\t\\t\\tmax_tokens: modelInfo.maxTokens,\\n 54 | \\t\\t\\ttemperature: this.options.modelTemperature ?? XAI_DEFAULT_TEMPERATURE,\\n----\\n 78 | \\t\\t\\tif (chunk.usage) {\\n 79 | \\t\\t\\t\\t// Extract detailed token information if available\\n 80 | \\t\\t\\t\\t// First check for prompt_tokens_details structure (real API response)\\n 81 | \\t\\t\\t\\tconst promptDetails = \\\"prompt_tokens_details\\\" in chunk.usage ? chunk.usage.prompt_tokens_details : null;\\n 82 | \\t\\t\\t\\tconst cachedTokens = promptDetails && \\\"cached_tokens\\\" in promptDetails ? promptDetails.cached_tokens : 0;\\n 83 | \\n 84 | \\t\\t\\t\\t// Fall back to direct fields in usage (used in test mocks)\\n 85 | \\t\\t\\t\\tconst readTokens = cachedTokens || (\\\"cache_read_input_tokens\\\" in chunk.usage ? (chunk.usage as any).cache_read_input_tokens : 0);\\n 86 | \\t\\t\\t\\tconst writeTokens = \\\"cache_creation_input_tokens\\\" in chunk.usage ? (chunk.usage as any).cache_creation_input_tokens : 0;\\n 87 | \\n----\\n 89 | \\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n 90 | \\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n 91 | \\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n 92 | \\t\\t\\t\\t\\tcacheReadTokens: readTokens,\\n----\\n\\n# src/core/prompts/tools/search-files.ts\\n  4 | \\treturn `## search_files\\n  5 | Description: Request to perform a regex search across files in a specified directory, providing context-rich results. This tool searches for patterns or specific content across multiple files, displaying each match with encapsulating context.\\n  6 | Parameters:\\n----\\n\\n# src/api/providers/openrouter.ts\\n 32 | \\tinclude_reasoning?: boolean\\n 33 | \\t// https://openrouter.ai/docs/use-cases/reasoning-tokens\\n 34 | \\treasoning?: OpenRouterReasoningParams\\n----\\n 40 | interface CompletionUsage {\\n 41 | \\tcompletion_tokens?: number\\n 42 | \\tcompletion_tokens_details?: {\\n 43 | \\t\\treasoning_tokens?: number\\n 44 | \\t}\\n 45 | \\tprompt_tokens?: number\\n 46 | \\tprompt_tokens_details?: {\\n 47 | \\t\\tcached_tokens?: number\\n 48 | \\t}\\n 49 | \\ttotal_tokens?: number\\n 50 | \\tcost?: number\\n----\\n 81 | \\n 82 | \\t\\t// OpenRouter sends reasoning tokens by default for Gemini 2.5 Pro\\n 83 | \\t\\t// Preview even if you don't request them. This is not the default for\\n----\\n116 | \\t\\t\\tmodel: modelId,\\n117 | \\t\\t\\t...(maxTokens && maxTokens > 0 && { max_tokens: maxTokens }),\\n118 | \\t\\t\\ttemperature,\\n----\\n165 | \\t\\t\\t\\ttype: \\\"usage\\\",\\n166 | \\t\\t\\t\\tinputTokens: lastUsage.prompt_tokens || 0,\\n167 | \\t\\t\\t\\toutputTokens: lastUsage.completion_tokens || 0,\\n168 | \\t\\t\\t\\t// Waiting on OpenRouter to figure out what this represents in the Gemini case\\n169 | \\t\\t\\t\\t// and how to best support it.\\n170 | \\t\\t\\t\\t// cacheReadTokens: lastUsage.prompt_tokens_details?.cached_tokens,\\n171 | \\t\\t\\t\\treasoningTokens: lastUsage.completion_tokens_details?.reasoning_tokens,\\n172 | \\t\\t\\t\\ttotalCost: (lastUsage.is_byok ? BYOK_COST_MULTIPLIER : 1) * (lastUsage.cost || 0),\\n----\\n219 | \\t\\t\\tmodel: modelId,\\n220 | \\t\\t\\tmax_tokens: maxTokens,\\n221 | \\t\\t\\ttemperature,\\n----\\n\\n# src/api/providers/anthropic.ts\\n 75 | \\t\\t\\t\\t\\t\\tmodel: modelId,\\n 76 | \\t\\t\\t\\t\\t\\tmax_tokens: maxTokens ?? ANTHROPIC_DEFAULT_MAX_TOKENS,\\n 77 | \\t\\t\\t\\t\\t\\ttemperature,\\n 78 | \\t\\t\\t\\t\\t\\tthinking,\\n 79 | \\t\\t\\t\\t\\t\\t// Setting cache breakpoint for system prompt so new tasks can reuse it.\\n 80 | \\t\\t\\t\\t\\t\\tsystem: [{ text: systemPrompt, type: \\\"text\\\", cache_control: cacheControl }],\\n----\\n124 | \\t\\t\\t\\t\\tmodel: modelId,\\n125 | \\t\\t\\t\\t\\tmax_tokens: maxTokens ?? ANTHROPIC_DEFAULT_MAX_TOKENS,\\n126 | \\t\\t\\t\\t\\ttemperature,\\n----\\n142 | \\t\\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n143 | \\t\\t\\t\\t\\t\\tinputTokens: usage.input_tokens || 0,\\n144 | \\t\\t\\t\\t\\t\\toutputTokens: usage.output_tokens || 0,\\n145 | \\t\\t\\t\\t\\t\\tcacheWriteTokens: usage.cache_creation_input_tokens || undefined,\\n146 | \\t\\t\\t\\t\\t\\tcacheReadTokens: usage.cache_read_input_tokens || undefined,\\n147 | \\t\\t\\t\\t\\t}\\n----\\n151 | \\t\\t\\t\\tcase \\\"message_delta\\\":\\n152 | \\t\\t\\t\\t\\t// Tells us stop_reason, stop_sequence, and output tokens\\n153 | \\t\\t\\t\\t\\t// along the way and at the end of the message.\\n----\\n156 | \\t\\t\\t\\t\\t\\tinputTokens: 0,\\n157 | \\t\\t\\t\\t\\t\\toutputTokens: chunk.usage.output_tokens || 0,\\n158 | \\t\\t\\t\\t\\t}\\n----\\n231 | \\t\\t\\tmodel,\\n232 | \\t\\t\\tmax_tokens: ANTHROPIC_DEFAULT_MAX_TOKENS,\\n233 | \\t\\t\\tthinking: undefined,\\n----\\n243 | \\t/**\\n244 | \\t * Counts tokens for the given content using Anthropic's API\\n245 | \\t *\\n246 | \\t * @param content The content blocks to count tokens for\\n247 | \\t * @returns A promise resolving to the token count\\n248 | \\t */\\n----\\n258 | \\n259 | \\t\\t\\treturn response.input_tokens\\n260 | \\t\\t} catch (error) {\\n261 | \\t\\t\\t// Log error but fallback to tiktoken estimation\\n262 | \\t\\t\\tconsole.warn(\\\"Anthropic token counting failed, using fallback\\\", error)\\n263 | \\n----\\n\\n# src/core/prompts/tools/execute-command.ts\\n  4 | \\treturn `## execute_command\\n  5 | Description: Request to execute a CLI command on the system. Use this when you need to perform system operations or run specific commands to accomplish any step in the user's task. You must tailor your command to the user's system and provide a clear explanation of what the command does. For command chaining, use the appropriate chaining syntax for the user's shell. Prefer to execute complex CLI commands over creating executable scripts, as they are more flexible and easier to run. Prefer relati [truncated...]\\n  6 | Parameters:\\n----\\n\\n# src/core/prompts/tools/access-mcp-resource.ts\\n  7 | \\treturn `## access_mcp_resource\\n  8 | Description: Request to access a resource provided by a connected MCP server. Resources represent data sources that can be used as context, such as files, API responses, or system information.\\n  9 | Parameters:\\n----\\n\\n# src/api/providers/gemini.ts\\n179 | \\t\\t\\tif (response.totalTokens === undefined) {\\n180 | \\t\\t\\t\\tconsole.warn(\\\"Gemini token counting returned undefined, using fallback\\\")\\n181 | \\t\\t\\t\\treturn super.countTokens(content)\\n----\\n185 | \\t\\t} catch (error) {\\n186 | \\t\\t\\tconsole.warn(\\\"Gemini token counting failed, using fallback\\\", error)\\n187 | \\t\\t\\treturn super.countTokens(content)\\n----\\n209 | \\n210 | \\t\\t// If there's tiered pricing then adjust the input and output token prices\\n211 | \\t\\t// based on the input tokens used.\\n212 | \\t\\tif (info.tiers) {\\n213 | \\t\\t\\tconst tier = info.tiers.find((tier) => inputTokens <= tier.contextWindow)\\n214 | \\n----\\n221 | \\n222 | \\t\\t// Subtract the cached input tokens from the total input tokens.\\n223 | \\t\\tconst uncachedInputTokens = inputTokens - cacheReadTokens\\n----\\n230 | \\n231 | \\t\\tconst trace: Record<string, { price: number; tokens: number; cost: number }> = {\\n232 | \\t\\t\\tinput: { price: inputPrice, tokens: uncachedInputTokens, cost: inputTokensCost },\\n233 | \\t\\t\\toutput: { price: outputPrice, tokens: outputTokens, cost: outputTokensCost },\\n234 | \\t\\t}\\n----\\n236 | \\t\\tif (cacheReadTokens > 0) {\\n237 | \\t\\t\\ttrace.cacheRead = { price: cacheReadsPrice, tokens: cacheReadTokens, cost: cacheReadCost }\\n238 | \\t\\t}\\n----\\n\\n# src/api/providers/requesty.ts\\n 19 | // Requesty usage includes an extra field for Anthropic use cases.\\n 20 | // Safely cast the prompt token details section to the appropriate structure.\\n 21 | interface RequestyUsage extends OpenAI.CompletionUsage {\\n 22 | \\tprompt_tokens_details?: {\\n 23 | \\t\\tcaching_tokens?: number\\n 24 | \\t\\tcached_tokens?: number\\n 25 | \\t}\\n----\\n 76 | \\t\\tconst requestyUsage = usage as RequestyUsage\\n 77 | \\t\\tconst inputTokens = requestyUsage?.prompt_tokens || 0\\n 78 | \\t\\tconst outputTokens = requestyUsage?.completion_tokens || 0\\n 79 | \\t\\tconst cacheWriteTokens = requestyUsage?.prompt_tokens_details?.caching_tokens || 0\\n 80 | \\t\\tconst cacheReadTokens = requestyUsage?.prompt_tokens_details?.cached_tokens || 0\\n 81 | \\t\\tconst totalCost = modelInfo\\n----\\n102 | \\t\\t\\tinfo,\\n103 | \\t\\t\\tmaxTokens: max_tokens,\\n104 | \\t\\t\\ttemperature,\\n----\\n116 | \\t\\t\\tmodel,\\n117 | \\t\\t\\tmax_tokens,\\n118 | \\t\\t\\ttemperature,\\n----\\n122 | \\t\\t\\tstream_options: { include_usage: true },\\n123 | \\t\\t\\trequesty: { trace_id: metadata?.taskId, extra: { mode: metadata?.mode } },\\n124 | \\t\\t}\\n----\\n150 | \\tasync completePrompt(prompt: string): Promise<string> {\\n151 | \\t\\tconst { id: model, maxTokens: max_tokens, temperature } = await this.fetchModel()\\n152 | \\n----\\n156 | \\t\\t\\tmodel,\\n157 | \\t\\t\\tmax_tokens,\\n158 | \\t\\t\\tmessages: openAiMessages,\\n----\\n\\n# src/api/providers/openai.ts\\n160 | \\n161 | \\t\\t\\t// Add max_tokens if needed\\n162 | \\t\\t\\tthis.addMaxTokensIfNeeded(requestOptions, modelInfo)\\n----\\n222 | \\n223 | \\t\\t\\t// Add max_tokens if needed\\n224 | \\t\\t\\tthis.addMaxTokensIfNeeded(requestOptions, modelInfo)\\n----\\n242 | \\t\\t\\ttype: \\\"usage\\\",\\n243 | \\t\\t\\tinputTokens: usage?.prompt_tokens || 0,\\n244 | \\t\\t\\toutputTokens: usage?.completion_tokens || 0,\\n245 | \\t\\t\\tcacheWriteTokens: usage?.cache_creation_input_tokens || undefined,\\n246 | \\t\\t\\tcacheReadTokens: usage?.cache_read_input_tokens || undefined,\\n247 | \\t\\t}\\n----\\n267 | \\n268 | \\t\\t\\t// Add max_tokens if needed\\n269 | \\t\\t\\tthis.addMaxTokensIfNeeded(requestOptions, modelInfo)\\n----\\n311 | \\n312 | \\t\\t\\t// O3 family models do not support the deprecated max_tokens parameter\\n313 | \\t\\t\\t// but they do support max_completion_tokens (the modern OpenAI parameter)\\n314 | \\t\\t\\t// This allows O3 models to limit response length when includeMaxTokens is enabled\\n----\\n336 | \\n337 | \\t\\t\\t// O3 family models do not support the deprecated max_tokens parameter\\n338 | \\t\\t\\t// but they do support max_completion_tokens (the modern OpenAI parameter)\\n339 | \\t\\t\\t// This allows O3 models to limit response length when includeMaxTokens is enabled\\n----\\n367 | \\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n368 | \\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n369 | \\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n370 | \\t\\t\\t\\t}\\n----\\n393 | \\t/**\\n394 | \\t * Adds max_completion_tokens to the request body if needed based on provider configuration\\n395 | \\t * Note: max_tokens is deprecated in favor of max_completion_tokens as per OpenAI documentation\\n396 | \\t * O3 family models handle max_tokens separately in handleO3FamilyMessage\\n397 | \\t */\\n----\\n403 | \\t): void {\\n404 | \\t\\t// Only add max_completion_tokens if includeMaxTokens is true\\n405 | \\t\\tif (this.options.includeMaxTokens === true) {\\n406 | \\t\\t\\t// Use user-configured modelMaxTokens if available, otherwise fall back to model's default maxTokens\\n407 | \\t\\t\\t// Using max_completion_tokens as max_tokens is deprecated\\n408 | \\t\\t\\trequestOptions.max_completion_tokens = this.options.modelMaxTokens || modelInfo.maxTokens\\n409 | \\t\\t}\\n----\\n\\n# src/core/prompts/__tests__/responses-rooignore.test.ts\\n 53 | \\t\\t\\texpect(errorMessage).toContain(\\\"Access to secrets/api-keys.json is blocked by the .rooignore file settings\\\")\\n 54 | \\t\\t\\texpect(errorMessage).toContain(\\\"continue in the task without using this file\\\")\\n 55 | \\t\\t\\texpect(errorMessage).toContain(\\\"ask the user to update the .rooignore file\\\")\\n----\\n\\n# src/api/providers/__tests__/bedrock-custom-arn.spec.ts\\n215 | \\t\\t\\texpect(model.info).toHaveProperty(\\\"maxTokens\\\")\\n216 | \\t\\t\\texpect(model.info).toHaveProperty(\\\"contextWindow\\\")\\n217 | \\t\\t\\texpect(model.info).toHaveProperty(\\\"supportsPromptCache\\\")\\n----\\n\\n# src/api/providers/__tests__/ollama.spec.ts\\n 28 | \\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 29 | \\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 30 | \\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 31 | \\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 32 | \\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n 54 | \\t\\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 55 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 56 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 57 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 58 | \\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n164 | \\t\\t\\texpect(modelInfo.info.maxTokens).toBe(-1)\\n165 | \\t\\t\\texpect(modelInfo.info.contextWindow).toBe(128_000)\\n166 | \\t\\t})\\n----\\n\\n# src/api/providers/__tests__/lmstudio.test.ts\\n 25 | \\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 26 | \\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 27 | \\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 28 | \\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 29 | \\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n 51 | \\t\\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 52 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 53 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 54 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 55 | \\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n163 | \\t\\t\\texpect(modelInfo.info.maxTokens).toBe(-1)\\n164 | \\t\\t\\texpect(modelInfo.info.contextWindow).toBe(128_000)\\n165 | \\t\\t})\\n----\\n\\n# src/api/providers/__tests__/bedrock-reasoning.test.ts\\n 94 | \\t\\t\\t\\ttype: \\\"enabled\\\",\\n 95 | \\t\\t\\t\\tbudget_tokens: 4096, // Uses the full modelMaxThinkingTokens value\\n 96 | \\t\\t\\t})\\n----\\n123 | \\t\\t\\tconst metadata = {\\n124 | \\t\\t\\t\\ttaskId: \\\"test-task\\\",\\n125 | \\t\\t\\t\\tthinking: {\\n----\\n143 | \\t\\t\\t\\ttype: \\\"enabled\\\",\\n144 | \\t\\t\\t\\tbudget_tokens: 8192,\\n145 | \\t\\t\\t})\\n----\\n266 | \\t\\t\\t\\ttype: \\\"enabled\\\",\\n267 | \\t\\t\\t\\tbudget_tokens: 4096,\\n268 | \\t\\t\\t})\\n----\\n\\n# src/api/providers/__tests__/openai-native.spec.ts\\n 29 | \\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 30 | \\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 31 | \\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 32 | \\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 33 | \\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n 55 | \\t\\t\\t\\t\\t\\t\\t\\t\\tusage: {\\n 56 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tprompt_tokens: 10,\\n 57 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 5,\\n 58 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\ttotal_tokens: 15,\\n 59 | \\t\\t\\t\\t\\t\\t\\t\\t\\t},\\n----\\n145 | \\t\\t\\t\\t\\t\\tusage: {\\n146 | \\t\\t\\t\\t\\t\\t\\tprompt_tokens: 0,\\n147 | \\t\\t\\t\\t\\t\\t\\tcompletion_tokens: 0,\\n148 | \\t\\t\\t\\t\\t\\t\\ttotal_tokens: 0,\\n149 | \\t\\t\\t\\t\\t\\t},\\n----\\n215 | \\t\\t\\t\\t{ choices: [{ delta: { content: \\\" there\\\" } }], usage: null },\\n216 | \\t\\t\\t\\t{ choices: [{ delta: { content: \\\"!\\\" } }], usage: { prompt_tokens: 10, completion_tokens: 5 } },\\n217 | \\t\\t\\t]\\n----\\n261 | \\t\\t\\t\\t{ choices: [{ delta: { content: null } }], usage: null },\\n262 | \\t\\t\\t\\t{ choices: [{ delta: { content: \\\"Hello\\\" } }], usage: { prompt_tokens: 10, completion_tokens: 5 } },\\n263 | \\t\\t\\t]\\n----\\n450 | \\t\\t\\texpect(modelInfo.info.maxTokens).toBe(32768)\\n451 | \\t\\t\\texpect(modelInfo.info.contextWindow).toBe(1047576)\\n452 | \\t\\t})\\n----\\n\\n# src/api/providers/base-openai-compatible-provider.ts\\n 71 | \\t\\t\\tid: model,\\n 72 | \\t\\t\\tinfo: { maxTokens: max_tokens },\\n 73 | \\t\\t} = this.getModel()\\n----\\n 78 | \\t\\t\\tmodel,\\n 79 | \\t\\t\\tmax_tokens,\\n 80 | \\t\\t\\ttemperature,\\n----\\n100 | \\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n101 | \\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n102 | \\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n103 | \\t\\t\\t\\t}\\n----\\n\\n# src/core/webview/getNonce.ts\\n  4 |  * @remarks This function is primarily used to help enforce content security\\n  5 |  * policies for resources/scripts being executed in a webview context.\\n  6 |  *\\n----\\n\\n# src/api/providers/bedrock.ts\\n 52 | \\t\\ttype: \\\"enabled\\\"\\n 53 | \\t\\tbudget_tokens: number\\n 54 | \\t}\\n----\\n109 | \\tmessageStop?: {\\n110 | \\t\\tstopReason?: \\\"end_turn\\\" | \\\"tool_use\\\" | \\\"max_tokens\\\" | \\\"stop_sequence\\\"\\n111 | \\t\\tadditionalModelResponseFields?: Record<string, unknown>\\n----\\n248 | \\t\\t\\t\\tmaxTokens: 8192,\\n249 | \\t\\t\\t\\tcontextWindow: 200_000,\\n250 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n254 | \\t\\t\\t\\tmaxTokens: 8192,\\n255 | \\t\\t\\t\\tcontextWindow: 200_000,\\n256 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n260 | \\t\\t\\t\\tmaxTokens: 8192,\\n261 | \\t\\t\\t\\tcontextWindow: 200_000,\\n262 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n266 | \\t\\t\\t\\tmaxTokens: 4096,\\n267 | \\t\\t\\t\\tcontextWindow: 200_000,\\n268 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n272 | \\t\\t\\t\\tmaxTokens: 4096,\\n273 | \\t\\t\\t\\tcontextWindow: 200_000,\\n274 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n278 | \\t\\t\\t\\tmaxTokens: 4096,\\n279 | \\t\\t\\t\\tcontextWindow: 200_000,\\n280 | \\t\\t\\t\\tsupportsImages: true,\\n----\\n295 | \\t\\t\\tmaxTokens: BEDROCK_MAX_TOKENS,\\n296 | \\t\\t\\tcontextWindow: BEDROCK_DEFAULT_CONTEXT,\\n297 | \\t\\t\\tsupportsImages: false,\\n----\\n349 | \\t\\t\\t\\t\\ttype: \\\"enabled\\\",\\n350 | \\t\\t\\t\\t\\tbudget_tokens: metadata?.thinking?.maxThinkingTokens || modelConfig.reasoningBudget || 4096,\\n351 | \\t\\t\\t\\t},\\n----\\n418 | \\n419 | \\t\\t\\t\\t\\t// Check both field naming conventions for cache tokens\\n420 | \\t\\t\\t\\t\\tconst cacheReadTokens = usage.cacheReadInputTokens || usage.cacheReadInputTokenCount || 0\\n----\\n422 | \\n423 | \\t\\t\\t\\t\\t// Always include all available token information\\n424 | \\t\\t\\t\\t\\tyield {\\n----\\n436 | \\t\\t\\t\\t\\t\\t//update the in-use model info to be based on the invoked Model Id for the router\\n437 | \\t\\t\\t\\t\\t\\t//so that pricing, context window, caching etc have values that can be used\\n438 | \\t\\t\\t\\t\\t\\t//However, we want to keep the id of the model to be the ID for the router for\\n----\\n450 | \\n451 | \\t\\t\\t\\t\\t\\t\\t// Check both field naming conventions for cache tokens\\n452 | \\t\\t\\t\\t\\t\\t\\tconst cacheReadTokens =\\n----\\n564 | \\t\\t\\t// Use the extracted error handling method for all errors\\n565 | \\t\\t\\tconst errorChunks = this.handleBedrockError(error, true) // true for streaming context\\n566 | \\t\\t\\t// Yield each chunk individually to ensure type compatibility\\n----\\n637 | \\t\\t\\t// Use the extracted error handling method for all errors\\n638 | \\t\\t\\tconst errorResult = this.handleBedrockError(error, false) // false for non-streaming context\\n639 | \\t\\t\\t// Since we're in a non-streaming context, we know the result is a string\\n640 | \\t\\t\\tconst errorMessage = errorResult as string\\n----\\n668 | \\t\\t\\tmaxTokens: modelInfo?.maxTokens || 8192,\\n669 | \\t\\t\\tcontextWindow: modelInfo?.contextWindow || 200_000,\\n670 | \\t\\t\\tsupportsPromptCache: modelInfo?.supportsPromptCache || false,\\n----\\n725 | \\t\\tid: \\\"\\\",\\n726 | \\t\\tinfo: { maxTokens: 0, contextWindow: 0, supportsPromptCache: false, supportsImages: false },\\n727 | \\t}\\n----\\n857 | \\n858 | \\t\\t// Always allow user to override detected/guessed maxTokens and contextWindow\\n859 | \\t\\tif (this.options.modelMaxTokens && this.options.modelMaxTokens > 0) {\\n----\\n862 | \\t\\tif (this.options.awsModelContextWindow && this.options.awsModelContextWindow > 0) {\\n863 | \\t\\t\\tmodel.info.contextWindow = this.options.awsModelContextWindow\\n864 | \\t\\t}\\n----\\n922 | \\n923 | \\t\\t// Don't override maxTokens/contextWindow here; handled in getModelById (and includes user overrides)\\n924 | \\t\\treturn { ...modelConfig, ...params } as {\\n----\\n1049 | \\t\\tTOO_MANY_TOKENS: {\\n1050 | \\t\\t\\tpatterns: [\\\"too many tokens\\\"],\\n1051 | \\t\\t\\tmessageTemplate: `\\\"Too many tokens\\\" error detected.\\n1052 | Possible Causes:\\n1053 | 1. Input exceeds model's context window limit\\n1054 | 2. Rate limiting (too many tokens per minute)\\n1055 | 3. Quota exceeded for token usage\\n1056 | 4. Other token-related service limitations\\n1057 | \\n----\\n1060 | 2. Split your request into smaller chunks\\n1061 | 3. Use a model with a larger context window\\n1062 | 4. If rate limited, reduce request frequency\\n----\\n1139 | \\t/**\\n1140 | \\t * Formats an error message based on the error type and context\\n1141 | \\t */\\n----\\n1154 | \\t\\t\\ttemplateVars.modelId = modelConfig.id\\n1155 | \\t\\t\\ttemplateVars.contextWindow = String(modelConfig.info.contextWindow || \\\"unknown\\\")\\n1156 | \\n----\\n1188 | \\n1189 | \\t\\t// Add context-specific template variables\\n1190 | \\t\\tconst region =\\n----\\n1206 | \\t * @param error The error that occurred\\n1207 | \\t * @param isStreamContext Whether the error occurred in a streaming context (true) or not (false)\\n1208 | \\t * @returns Error message string for non-streaming context or array of stream chunks for streaming context\\n1209 | \\t */\\n----\\n1222 | \\t\\tconst logMethod = definition.logLevel\\n1223 | \\t\\tconst contextName = isStreamContext ? \\\"createMessage\\\" : \\\"completePrompt\\\"\\n1224 | \\t\\tlogger[logMethod](`${errorType} error in ${contextName}`, {\\n1225 | \\t\\t\\tctx: \\\"bedrock\\\",\\n----\\n1239 | \\t\\t} else {\\n1240 | \\t\\t\\t// For non-streaming context, add the expected prefix\\n1241 | \\t\\t\\treturn `Bedrock completion error: ${errorMessage}`\\n----\\n\\n# src/api/providers/chutes.ts\\n 31 | \\t\\t\\tid: model,\\n 32 | \\t\\t\\tinfo: { maxTokens: max_tokens },\\n 33 | \\t\\t} = this.getModel()\\n----\\n 38 | \\t\\t\\tmodel,\\n 39 | \\t\\t\\tmax_tokens,\\n 40 | \\t\\t\\ttemperature,\\n----\\n 76 | \\t\\t\\t\\t\\t\\ttype: \\\"usage\\\",\\n 77 | \\t\\t\\t\\t\\t\\tinputTokens: chunk.usage.prompt_tokens || 0,\\n 78 | \\t\\t\\t\\t\\t\\toutputTokens: chunk.usage.completion_tokens || 0,\\n 79 | \\t\\t\\t\\t\\t}\\n----\\n\\n# src/core/webview/__tests__/webviewMessageHandler.test.ts\\n 34 | \\t\\t\\t\\tmaxTokens: 4096,\\n 35 | \\t\\t\\t\\tcontextWindow: 8192,\\n 36 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n 40 | \\t\\t\\t\\tmaxTokens: 8192,\\n 41 | \\t\\t\\t\\tcontextWindow: 16384,\\n 42 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n 90 | \\t\\t\\t\\tmaxTokens: 4096,\\n 91 | \\t\\t\\t\\tcontextWindow: 8192,\\n 92 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n128 | \\t\\t\\t\\tmaxTokens: 4096,\\n129 | \\t\\t\\t\\tcontextWindow: 8192,\\n130 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n165 | \\t\\t\\t\\tmaxTokens: 4096,\\n166 | \\t\\t\\t\\tcontextWindow: 8192,\\n167 | \\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n\\n# src/api/providers/__tests__/bedrock-invokedModelId.spec.ts\\n176 | \\n177 | \\t\\t// The last usage event should have the token counts from the metadata\\n178 | \\t\\tconst lastUsageEvent = usageEvents[usageEvents.length - 1]\\n179 | \\t\\t// Expect the usage event to include all token information\\n180 | \\t\\texpect(lastUsageEvent).toMatchObject({\\n----\\n183 | \\t\\t\\toutputTokens: 200,\\n184 | \\t\\t\\t// Cache tokens may be present with default values\\n185 | \\t\\t\\tcacheReadTokens: expect.any(Number),\\n----\\n331 | \\t\\t\\t\\t\\tmaxTokens: 4096,\\n332 | \\t\\t\\t\\t\\tcontextWindow: 128_000,\\n333 | \\t\\t\\t\\t\\tsupportsPromptCache: false,\\n----\\n\\n# src/utils/__tests__/tiktoken.spec.ts\\n  1 | // npx vitest utils/__tests__/tiktoken.spec.ts\\n  2 | \\n  3 | import { describe, it, expect } from \\\"vitest\\\"\\n  4 | import { tiktoken } from \\\"../tiktoken\\\"\\n  5 | import { Anthropic } from \\\"@anthropic-ai/sdk\\\"\\n  6 | \\n  7 | describe(\\\"tiktoken\\\", () => {\\n  8 | \\tit(\\\"should return 0 for empty content array\\\", async () => {\\n  9 | \\t\\tconst result = await tiktoken([])\\n 10 | \\t\\texpect(result).toBe(0)\\n----\\n 12 | \\n 13 | \\tit(\\\"should correctly count tokens for text content\\\", async () => {\\n 14 | \\t\\tconst content: Anthropic.Messages.ContentBlockParam[] = [{ type: \\\"text\\\", text: \\\"Hello world\\\" }]\\n 15 | \\n 16 | \\t\\tconst result = await tiktoken(content)\\n 17 | \\t\\t// We can't predict the exact token count without mocking,\\n 18 | \\t\\t// but we can verify it's a positive number\\n----\\n 24 | \\n 25 | \\t\\tconst result = await tiktoken(content)\\n 26 | \\t\\texpect(result).toBe(0)\\n----\\n 33 | \\n 34 | \\t\\tconst result = await tiktoken(content)\\n 35 | \\t\\texpect(result).toBe(0)\\n----\\n 37 | \\n 38 | \\tit(\\\"should correctly count tokens for image content with data\\\", async () => {\\n 39 | \\t\\tconst base64Data =\\n----\\n 51 | \\n 52 | \\t\\tconst result = await tiktoken(content)\\n 53 | \\t\\t// For images, we expect a token count based on the square root of the data length\\n 54 | \\t\\t// plus the fudge factor\\n----\\n 72 | \\n 73 | \\t\\tconst result = await tiktoken(content)\\n 74 | \\t\\t// Conservative estimate is 300 tokens, plus the fudge factor\\n 75 | \\t\\tconst expectedMinTokens = 300\\n----\\n 78 | \\n 79 | \\tit(\\\"should correctly count tokens for mixed content\\\", async () => {\\n 80 | \\t\\tconst base64Data =\\n----\\n 94 | \\n 95 | \\t\\tconst result = await tiktoken(content)\\n 96 | \\t\\t// We expect a positive token count for mixed content\\n 97 | \\t\\texpect(result).toBeGreaterThan(0)\\n----\\n 99 | \\n100 | \\tit(\\\"should apply a fudge factor to the token count\\\", async () => {\\n101 | \\t\\t// We can test the fudge factor by comparing the token count with a rough estimate\\n102 | \\t\\tconst content: Anthropic.Messages.ContentBlockParam[] = [{ type: \\\"text\\\", text: \\\"Test\\\" }]\\n103 | \\n104 | \\t\\tconst result = await tiktoken(content)\\n105 | \\n106 | \\t\\t// Run the function again with the same content to get a consistent result\\n107 | \\t\\tconst result2 = await tiktoken(content)\\n108 | \\n109 | \\t\\t// Both calls should return the same token count\\n110 | \\t\\texpect(result).toBe(result2)\\n----\\n122 | \\n123 | \\t\\tconst result1 = await tiktoken(content)\\n124 | \\t\\tconst result2 = await tiktoken(content)\\n125 | \\n126 | \\t\\t// Both calls should return the same token count\\n127 | \\t\\texpect(result1).toBe(result2)\\n----\\n\\nLoading...\"}"
}
[2025-06-16T20:26:59.855Z] {
  "ts": 1750105619201,
  "type": "say",
  "say": "text",
  "text": "Now let me look at the core task implementation to understand how tasks and subtasks work, and where context management happens.",
  "partial": false
}
[2025-06-16T20:27:00.727Z] {
  "ts": 1750105619854,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"readFile\",\"batchFiles\":[{\"path\":\"src/core/task/Task.ts\",\"lineSnippet\":\"\",\"isOutsideWorkspace\":false,\"key\":\"src/core/task/Task.ts\",\"content\":\"/roo/repos/Roo-Code/src/core/task/Task.ts\"},{\"path\":\"src/core/webview/ClineProvider.ts\",\"lineSnippet\":\"\",\"isOutsideWorkspace\":false,\"key\":\"src/core/webview/ClineProvider.ts\",\"content\":\"/roo/repos/Roo-Code/src/core/webview/ClineProvider.ts\"}]}",
  "partial": false
}
[2025-06-16T20:27:00.889Z] {
  "ts": 1750105620881,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[read_file for 'src/core/task/Task.ts', 'src/core/webview/ClineProvider.ts'] Result:\\n\\n<files>\\n<file><path>src/core/task/Task.ts</path>\\n<content lines=\\\"1-1900\\\">\\n   1 | import * as path from \\\"path\\\"\\n   2 | import os from \\\"os\\\"\\n   3 | import crypto from \\\"crypto\\\"\\n   4 | import EventEmitter from \\\"events\\\"\\n   5 | \\n   6 | import { Anthropic } from \\\"@anthropic-ai/sdk\\\"\\n   7 | import delay from \\\"delay\\\"\\n   8 | import pWaitFor from \\\"p-wait-for\\\"\\n   9 | import { serializeError } from \\\"serialize-error\\\"\\n  10 | \\n  11 | import {\\n  12 | \\ttype ProviderSettings,\\n  13 | \\ttype TokenUsage,\\n  14 | \\ttype ToolUsage,\\n  15 | \\ttype ToolName,\\n  16 | \\ttype ContextCondense,\\n  17 | \\ttype ClineAsk,\\n  18 | \\ttype ClineMessage,\\n  19 | \\ttype ClineSay,\\n  20 | \\ttype ToolProgressStatus,\\n  21 | \\ttype HistoryItem,\\n  22 | \\tTelemetryEventName,\\n  23 | } from \\\"@roo-code/types\\\"\\n  24 | import { TelemetryService } from \\\"@roo-code/telemetry\\\"\\n  25 | import { CloudService } from \\\"@roo-code/cloud\\\"\\n  26 | \\n  27 | // api\\n  28 | import { ApiHandler, ApiHandlerCreateMessageMetadata, buildApiHandler } from \\\"../../api\\\"\\n  29 | import { ApiStream } from \\\"../../api/transform/stream\\\"\\n  30 | \\n  31 | // shared\\n  32 | import { findLastIndex } from \\\"../../shared/array\\\"\\n  33 | import { combineApiRequests } from \\\"../../shared/combineApiRequests\\\"\\n  34 | import { combineCommandSequences } from \\\"../../shared/combineCommandSequences\\\"\\n  35 | import { t } from \\\"../../i18n\\\"\\n  36 | import { ClineApiReqCancelReason, ClineApiReqInfo } from \\\"../../shared/ExtensionMessage\\\"\\n  37 | import { getApiMetrics } from \\\"../../shared/getApiMetrics\\\"\\n  38 | import { ClineAskResponse } from \\\"../../shared/WebviewMessage\\\"\\n  39 | import { defaultModeSlug } from \\\"../../shared/modes\\\"\\n  40 | import { DiffStrategy } from \\\"../../shared/tools\\\"\\n  41 | import { EXPERIMENT_IDS, experiments } from \\\"../../shared/experiments\\\"\\n  42 | \\n  43 | // services\\n  44 | import { UrlContentFetcher } from \\\"../../services/browser/UrlContentFetcher\\\"\\n  45 | import { BrowserSession } from \\\"../../services/browser/BrowserSession\\\"\\n  46 | import { McpHub } from \\\"../../services/mcp/McpHub\\\"\\n  47 | import { McpServerManager } from \\\"../../services/mcp/McpServerManager\\\"\\n  48 | import { RepoPerTaskCheckpointService } from \\\"../../services/checkpoints\\\"\\n  49 | \\n  50 | // integrations\\n  51 | import { DiffViewProvider } from \\\"../../integrations/editor/DiffViewProvider\\\"\\n  52 | import { findToolName, formatContentBlockToMarkdown } from \\\"../../integrations/misc/export-markdown\\\"\\n  53 | import { RooTerminalProcess } from \\\"../../integrations/terminal/types\\\"\\n  54 | import { TerminalRegistry } from \\\"../../integrations/terminal/TerminalRegistry\\\"\\n  55 | \\n  56 | // utils\\n  57 | import { calculateApiCostAnthropic } from \\\"../../shared/cost\\\"\\n  58 | import { getWorkspacePath } from \\\"../../utils/path\\\"\\n  59 | \\n  60 | // prompts\\n  61 | import { formatResponse } from \\\"../prompts/responses\\\"\\n  62 | import { SYSTEM_PROMPT } from \\\"../prompts/system\\\"\\n  63 | \\n  64 | // core modules\\n  65 | import { ToolRepetitionDetector } from \\\"../tools/ToolRepetitionDetector\\\"\\n  66 | import { FileContextTracker } from \\\"../context-tracking/FileContextTracker\\\"\\n  67 | import { RooIgnoreController } from \\\"../ignore/RooIgnoreController\\\"\\n  68 | import { RooProtectedController } from \\\"../protect/RooProtectedController\\\"\\n  69 | import { type AssistantMessageContent, parseAssistantMessage, presentAssistantMessage } from \\\"../assistant-message\\\"\\n  70 | import { truncateConversationIfNeeded } from \\\"../sliding-window\\\"\\n  71 | import { ClineProvider } from \\\"../webview/ClineProvider\\\"\\n  72 | import { MultiSearchReplaceDiffStrategy } from \\\"../diff/strategies/multi-search-replace\\\"\\n  73 | import { MultiFileSearchReplaceDiffStrategy } from \\\"../diff/strategies/multi-file-search-replace\\\"\\n  74 | import { readApiMessages, saveApiMessages, readTaskMessages, saveTaskMessages, taskMetadata } from \\\"../task-persistence\\\"\\n  75 | import { getEnvironmentDetails } from \\\"../environment/getEnvironmentDetails\\\"\\n  76 | import {\\n  77 | \\ttype CheckpointDiffOptions,\\n  78 | \\ttype CheckpointRestoreOptions,\\n  79 | \\tgetCheckpointService,\\n  80 | \\tcheckpointSave,\\n  81 | \\tcheckpointRestore,\\n  82 | \\tcheckpointDiff,\\n  83 | } from \\\"../checkpoints\\\"\\n  84 | import { processUserContentMentions } from \\\"../mentions/processUserContentMentions\\\"\\n  85 | import { ApiMessage } from \\\"../task-persistence/apiMessages\\\"\\n  86 | import { getMessagesSinceLastSummary, summarizeConversation } from \\\"../condense\\\"\\n  87 | import { maybeRemoveImageBlocks } from \\\"../../api/transform/image-cleaning\\\"\\n  88 | \\n  89 | export type ClineEvents = {\\n  90 | \\tmessage: [{ action: \\\"created\\\" | \\\"updated\\\"; message: ClineMessage }]\\n  91 | \\ttaskStarted: []\\n  92 | \\ttaskModeSwitched: [taskId: string, mode: string]\\n  93 | \\ttaskPaused: []\\n  94 | \\ttaskUnpaused: []\\n  95 | \\ttaskAskResponded: []\\n  96 | \\ttaskAborted: []\\n  97 | \\ttaskSpawned: [taskId: string]\\n  98 | \\ttaskCompleted: [taskId: string, tokenUsage: TokenUsage, toolUsage: ToolUsage]\\n  99 | \\ttaskTokenUsageUpdated: [taskId: string, tokenUsage: TokenUsage]\\n 100 | \\ttaskToolFailed: [taskId: string, tool: ToolName, error: string]\\n 101 | }\\n 102 | \\n 103 | export type TaskOptions = {\\n 104 | \\tprovider: ClineProvider\\n 105 | \\tapiConfiguration: ProviderSettings\\n 106 | \\tenableDiff?: boolean\\n 107 | \\tenableCheckpoints?: boolean\\n 108 | \\tfuzzyMatchThreshold?: number\\n 109 | \\tconsecutiveMistakeLimit?: number\\n 110 | \\ttask?: string\\n 111 | \\timages?: string[]\\n 112 | \\thistoryItem?: HistoryItem\\n 113 | \\texperiments?: Record<string, boolean>\\n 114 | \\tstartTask?: boolean\\n 115 | \\trootTask?: Task\\n 116 | \\tparentTask?: Task\\n 117 | \\ttaskNumber?: number\\n 118 | \\tonCreated?: (cline: Task) => void\\n 119 | }\\n 120 | \\n 121 | export class Task extends EventEmitter<ClineEvents> {\\n 122 | \\treadonly taskId: string\\n 123 | \\treadonly instanceId: string\\n 124 | \\n 125 | \\treadonly rootTask: Task | undefined = undefined\\n 126 | \\treadonly parentTask: Task | undefined = undefined\\n 127 | \\treadonly taskNumber: number\\n 128 | \\treadonly workspacePath: string\\n 129 | \\n 130 | \\tproviderRef: WeakRef<ClineProvider>\\n 131 | \\tprivate readonly globalStoragePath: string\\n 132 | \\tabort: boolean = false\\n 133 | \\tdidFinishAbortingStream = false\\n 134 | \\tabandoned = false\\n 135 | \\tisInitialized = false\\n 136 | \\tisPaused: boolean = false\\n 137 | \\tpausedModeSlug: string = defaultModeSlug\\n 138 | \\tprivate pauseInterval: NodeJS.Timeout | undefined\\n 139 | \\n 140 | \\t// API\\n 141 | \\treadonly apiConfiguration: ProviderSettings\\n 142 | \\tapi: ApiHandler\\n 143 | \\tprivate lastApiRequestTime?: number\\n 144 | \\tprivate consecutiveAutoApprovedRequestsCount: number = 0\\n 145 | \\n 146 | \\ttoolRepetitionDetector: ToolRepetitionDetector\\n 147 | \\trooIgnoreController?: RooIgnoreController\\n 148 | \\trooProtectedController?: RooProtectedController\\n 149 | \\tfileContextTracker: FileContextTracker\\n 150 | \\turlContentFetcher: UrlContentFetcher\\n 151 | \\tterminalProcess?: RooTerminalProcess\\n 152 | \\n 153 | \\t// Computer User\\n 154 | \\tbrowserSession: BrowserSession\\n 155 | \\n 156 | \\t// Editing\\n 157 | \\tdiffViewProvider: DiffViewProvider\\n 158 | \\tdiffStrategy?: DiffStrategy\\n 159 | \\tdiffEnabled: boolean = false\\n 160 | \\tfuzzyMatchThreshold: number\\n 161 | \\tdidEditFile: boolean = false\\n 162 | \\n 163 | \\t// LLM Messages & Chat Messages\\n 164 | \\tapiConversationHistory: ApiMessage[] = []\\n 165 | \\tclineMessages: ClineMessage[] = []\\n 166 | \\n 167 | \\t// Ask\\n 168 | \\tprivate askResponse?: ClineAskResponse\\n 169 | \\tprivate askResponseText?: string\\n 170 | \\tprivate askResponseImages?: string[]\\n 171 | \\tpublic lastMessageTs?: number\\n 172 | \\n 173 | \\t// Tool Use\\n 174 | \\tconsecutiveMistakeCount: number = 0\\n 175 | \\tconsecutiveMistakeLimit: number\\n 176 | \\tconsecutiveMistakeCountForApplyDiff: Map<string, number> = new Map()\\n 177 | \\ttoolUsage: ToolUsage = {}\\n 178 | \\n 179 | \\t// Checkpoints\\n 180 | \\tenableCheckpoints: boolean\\n 181 | \\tcheckpointService?: RepoPerTaskCheckpointService\\n 182 | \\tcheckpointServiceInitializing = false\\n 183 | \\n 184 | \\t// Streaming\\n 185 | \\tisWaitingForFirstChunk = false\\n 186 | \\tisStreaming = false\\n 187 | \\tcurrentStreamingContentIndex = 0\\n 188 | \\tassistantMessageContent: AssistantMessageContent[] = []\\n 189 | \\tpresentAssistantMessageLocked = false\\n 190 | \\tpresentAssistantMessageHasPendingUpdates = false\\n 191 | \\tuserMessageContent: (Anthropic.TextBlockParam | Anthropic.ImageBlockParam)[] = []\\n 192 | \\tuserMessageContentReady = false\\n 193 | \\tdidRejectTool = false\\n 194 | \\tdidAlreadyUseTool = false\\n 195 | \\tdidCompleteReadingStream = false\\n 196 | \\n 197 | \\tconstructor({\\n 198 | \\t\\tprovider,\\n 199 | \\t\\tapiConfiguration,\\n 200 | \\t\\tenableDiff = false,\\n 201 | \\t\\tenableCheckpoints = true,\\n 202 | \\t\\tfuzzyMatchThreshold = 1.0,\\n 203 | \\t\\tconsecutiveMistakeLimit = 3,\\n 204 | \\t\\ttask,\\n 205 | \\t\\timages,\\n 206 | \\t\\thistoryItem,\\n 207 | \\t\\tstartTask = true,\\n 208 | \\t\\trootTask,\\n 209 | \\t\\tparentTask,\\n 210 | \\t\\ttaskNumber = -1,\\n 211 | \\t\\tonCreated,\\n 212 | \\t}: TaskOptions) {\\n 213 | \\t\\tsuper()\\n 214 | \\n 215 | \\t\\tif (startTask && !task && !images && !historyItem) {\\n 216 | \\t\\t\\tthrow new Error(\\\"Either historyItem or task/images must be provided\\\")\\n 217 | \\t\\t}\\n 218 | \\n 219 | \\t\\tthis.taskId = historyItem ? historyItem.id : crypto.randomUUID()\\n 220 | \\t\\t// normal use-case is usually retry similar history task with new workspace\\n 221 | \\t\\tthis.workspacePath = parentTask\\n 222 | \\t\\t\\t? parentTask.workspacePath\\n 223 | \\t\\t\\t: getWorkspacePath(path.join(os.homedir(), \\\"Desktop\\\"))\\n 224 | \\t\\tthis.instanceId = crypto.randomUUID().slice(0, 8)\\n 225 | \\t\\tthis.taskNumber = -1\\n 226 | \\n 227 | \\t\\tthis.rooIgnoreController = new RooIgnoreController(this.cwd)\\n 228 | \\t\\tthis.rooProtectedController = new RooProtectedController(this.cwd)\\n 229 | \\t\\tthis.fileContextTracker = new FileContextTracker(provider, this.taskId)\\n 230 | \\n 231 | \\t\\tthis.rooIgnoreController.initialize().catch((error) => {\\n 232 | \\t\\t\\tconsole.error(\\\"Failed to initialize RooIgnoreController:\\\", error)\\n 233 | \\t\\t})\\n 234 | \\n 235 | \\t\\tthis.apiConfiguration = apiConfiguration\\n 236 | \\t\\tthis.api = buildApiHandler(apiConfiguration)\\n 237 | \\n 238 | \\t\\tthis.urlContentFetcher = new UrlContentFetcher(provider.context)\\n 239 | \\t\\tthis.browserSession = new BrowserSession(provider.context)\\n 240 | \\t\\tthis.diffEnabled = enableDiff\\n 241 | \\t\\tthis.fuzzyMatchThreshold = fuzzyMatchThreshold\\n 242 | \\t\\tthis.consecutiveMistakeLimit = consecutiveMistakeLimit\\n 243 | \\t\\tthis.providerRef = new WeakRef(provider)\\n 244 | \\t\\tthis.globalStoragePath = provider.context.globalStorageUri.fsPath\\n 245 | \\t\\tthis.diffViewProvider = new DiffViewProvider(this.cwd)\\n 246 | \\t\\tthis.enableCheckpoints = enableCheckpoints\\n 247 | \\n 248 | \\t\\tthis.rootTask = rootTask\\n 249 | \\t\\tthis.parentTask = parentTask\\n 250 | \\t\\tthis.taskNumber = taskNumber\\n 251 | \\n 252 | \\t\\tif (historyItem) {\\n 253 | \\t\\t\\tTelemetryService.instance.captureTaskRestarted(this.taskId)\\n 254 | \\t\\t} else {\\n 255 | \\t\\t\\tTelemetryService.instance.captureTaskCreated(this.taskId)\\n 256 | \\t\\t}\\n 257 | \\n 258 | \\t\\t// Only set up diff strategy if diff is enabled\\n 259 | \\t\\tif (this.diffEnabled) {\\n 260 | \\t\\t\\t// Default to old strategy, will be updated if experiment is enabled\\n 261 | \\t\\t\\tthis.diffStrategy = new MultiSearchReplaceDiffStrategy(this.fuzzyMatchThreshold)\\n 262 | \\n 263 | \\t\\t\\t// Check experiment asynchronously and update strategy if needed\\n 264 | \\t\\t\\tprovider.getState().then((state) => {\\n 265 | \\t\\t\\t\\tconst isMultiFileApplyDiffEnabled = experiments.isEnabled(\\n 266 | \\t\\t\\t\\t\\tstate.experiments ?? {},\\n 267 | \\t\\t\\t\\t\\tEXPERIMENT_IDS.MULTI_FILE_APPLY_DIFF,\\n 268 | \\t\\t\\t\\t)\\n 269 | \\n 270 | \\t\\t\\t\\tif (isMultiFileApplyDiffEnabled) {\\n 271 | \\t\\t\\t\\t\\tthis.diffStrategy = new MultiFileSearchReplaceDiffStrategy(this.fuzzyMatchThreshold)\\n 272 | \\t\\t\\t\\t}\\n 273 | \\t\\t\\t})\\n 274 | \\t\\t}\\n 275 | \\n 276 | \\t\\tthis.toolRepetitionDetector = new ToolRepetitionDetector(this.consecutiveMistakeLimit)\\n 277 | \\n 278 | \\t\\tonCreated?.(this)\\n 279 | \\n 280 | \\t\\tif (startTask) {\\n 281 | \\t\\t\\tif (task || images) {\\n 282 | \\t\\t\\t\\tthis.startTask(task, images)\\n 283 | \\t\\t\\t} else if (historyItem) {\\n 284 | \\t\\t\\t\\tthis.resumeTaskFromHistory()\\n 285 | \\t\\t\\t} else {\\n 286 | \\t\\t\\t\\tthrow new Error(\\\"Either historyItem or task/images must be provided\\\")\\n 287 | \\t\\t\\t}\\n 288 | \\t\\t}\\n 289 | \\t}\\n 290 | \\n 291 | \\tstatic create(options: TaskOptions): [Task, Promise<void>] {\\n 292 | \\t\\tconst instance = new Task({ ...options, startTask: false })\\n 293 | \\t\\tconst { images, task, historyItem } = options\\n 294 | \\t\\tlet promise\\n 295 | \\n 296 | \\t\\tif (images || task) {\\n 297 | \\t\\t\\tpromise = instance.startTask(task, images)\\n 298 | \\t\\t} else if (historyItem) {\\n 299 | \\t\\t\\tpromise = instance.resumeTaskFromHistory()\\n 300 | \\t\\t} else {\\n 301 | \\t\\t\\tthrow new Error(\\\"Either historyItem or task/images must be provided\\\")\\n 302 | \\t\\t}\\n 303 | \\n 304 | \\t\\treturn [instance, promise]\\n 305 | \\t}\\n 306 | \\n 307 | \\t// API Messages\\n 308 | \\n 309 | \\tprivate async getSavedApiConversationHistory(): Promise<ApiMessage[]> {\\n 310 | \\t\\treturn readApiMessages({ taskId: this.taskId, globalStoragePath: this.globalStoragePath })\\n 311 | \\t}\\n 312 | \\n 313 | \\tprivate async addToApiConversationHistory(message: Anthropic.MessageParam) {\\n 314 | \\t\\tconst messageWithTs = { ...message, ts: Date.now() }\\n 315 | \\t\\tthis.apiConversationHistory.push(messageWithTs)\\n 316 | \\t\\tawait this.saveApiConversationHistory()\\n 317 | \\t}\\n 318 | \\n 319 | \\tasync overwriteApiConversationHistory(newHistory: ApiMessage[]) {\\n 320 | \\t\\tthis.apiConversationHistory = newHistory\\n 321 | \\t\\tawait this.saveApiConversationHistory()\\n 322 | \\t}\\n 323 | \\n 324 | \\tprivate async saveApiConversationHistory() {\\n 325 | \\t\\ttry {\\n 326 | \\t\\t\\tawait saveApiMessages({\\n 327 | \\t\\t\\t\\tmessages: this.apiConversationHistory,\\n 328 | \\t\\t\\t\\ttaskId: this.taskId,\\n 329 | \\t\\t\\t\\tglobalStoragePath: this.globalStoragePath,\\n 330 | \\t\\t\\t})\\n 331 | \\t\\t} catch (error) {\\n 332 | \\t\\t\\t// In the off chance this fails, we don't want to stop the task.\\n 333 | \\t\\t\\tconsole.error(\\\"Failed to save API conversation history:\\\", error)\\n 334 | \\t\\t}\\n 335 | \\t}\\n 336 | \\n 337 | \\t// Cline Messages\\n 338 | \\n 339 | \\tprivate async getSavedClineMessages(): Promise<ClineMessage[]> {\\n 340 | \\t\\treturn readTaskMessages({ taskId: this.taskId, globalStoragePath: this.globalStoragePath })\\n 341 | \\t}\\n 342 | \\n 343 | \\tprivate async addToClineMessages(message: ClineMessage) {\\n 344 | \\t\\tthis.clineMessages.push(message)\\n 345 | \\t\\tconst provider = this.providerRef.deref()\\n 346 | \\t\\tawait provider?.postStateToWebview()\\n 347 | \\t\\tthis.emit(\\\"message\\\", { action: \\\"created\\\", message })\\n 348 | \\t\\tawait this.saveClineMessages()\\n 349 | \\n 350 | \\t\\tconst shouldCaptureMessage = message.partial !== true && CloudService.isEnabled()\\n 351 | \\n 352 | \\t\\tif (shouldCaptureMessage) {\\n 353 | \\t\\t\\tCloudService.instance.captureEvent({\\n 354 | \\t\\t\\t\\tevent: TelemetryEventName.TASK_MESSAGE,\\n 355 | \\t\\t\\t\\tproperties: { taskId: this.taskId, message },\\n 356 | \\t\\t\\t})\\n 357 | \\t\\t}\\n 358 | \\t}\\n 359 | \\n 360 | \\tpublic async overwriteClineMessages(newMessages: ClineMessage[]) {\\n 361 | \\t\\tthis.clineMessages = newMessages\\n 362 | \\t\\tawait this.saveClineMessages()\\n 363 | \\t}\\n 364 | \\n 365 | \\tprivate async updateClineMessage(message: ClineMessage) {\\n 366 | \\t\\tconst provider = this.providerRef.deref()\\n 367 | \\t\\tawait provider?.postMessageToWebview({ type: \\\"messageUpdated\\\", clineMessage: message })\\n 368 | \\t\\tthis.emit(\\\"message\\\", { action: \\\"updated\\\", message })\\n 369 | \\n 370 | \\t\\tconst shouldCaptureMessage = message.partial !== true && CloudService.isEnabled()\\n 371 | \\n 372 | \\t\\tif (shouldCaptureMessage) {\\n 373 | \\t\\t\\tCloudService.instance.captureEvent({\\n 374 | \\t\\t\\t\\tevent: TelemetryEventName.TASK_MESSAGE,\\n 375 | \\t\\t\\t\\tproperties: { taskId: this.taskId, message },\\n 376 | \\t\\t\\t})\\n 377 | \\t\\t}\\n 378 | \\t}\\n 379 | \\n 380 | \\tprivate async saveClineMessages() {\\n 381 | \\t\\ttry {\\n 382 | \\t\\t\\tawait saveTaskMessages({\\n 383 | \\t\\t\\t\\tmessages: this.clineMessages,\\n 384 | \\t\\t\\t\\ttaskId: this.taskId,\\n 385 | \\t\\t\\t\\tglobalStoragePath: this.globalStoragePath,\\n 386 | \\t\\t\\t})\\n 387 | \\n 388 | \\t\\t\\tconst { historyItem, tokenUsage } = await taskMetadata({\\n 389 | \\t\\t\\t\\tmessages: this.clineMessages,\\n 390 | \\t\\t\\t\\ttaskId: this.taskId,\\n 391 | \\t\\t\\t\\ttaskNumber: this.taskNumber,\\n 392 | \\t\\t\\t\\tglobalStoragePath: this.globalStoragePath,\\n 393 | \\t\\t\\t\\tworkspace: this.cwd,\\n 394 | \\t\\t\\t})\\n 395 | \\n 396 | \\t\\t\\tthis.emit(\\\"taskTokenUsageUpdated\\\", this.taskId, tokenUsage)\\n 397 | \\n 398 | \\t\\t\\tawait this.providerRef.deref()?.updateTaskHistory(historyItem)\\n 399 | \\t\\t} catch (error) {\\n 400 | \\t\\t\\tconsole.error(\\\"Failed to save Roo messages:\\\", error)\\n 401 | \\t\\t}\\n 402 | \\t}\\n 403 | \\n 404 | \\t// Note that `partial` has three valid states true (partial message),\\n 405 | \\t// false (completion of partial message), undefined (individual complete\\n 406 | \\t// message).\\n 407 | \\tasync ask(\\n 408 | \\t\\ttype: ClineAsk,\\n 409 | \\t\\ttext?: string,\\n 410 | \\t\\tpartial?: boolean,\\n 411 | \\t\\tprogressStatus?: ToolProgressStatus,\\n 412 | \\t\\tisProtected?: boolean,\\n 413 | \\t): Promise<{ response: ClineAskResponse; text?: string; images?: string[] }> {\\n 414 | \\t\\t// If this Cline instance was aborted by the provider, then the only\\n 415 | \\t\\t// thing keeping us alive is a promise still running in the background,\\n 416 | \\t\\t// in which case we don't want to send its result to the webview as it\\n 417 | \\t\\t// is attached to a new instance of Cline now. So we can safely ignore\\n 418 | \\t\\t// the result of any active promises, and this class will be\\n 419 | \\t\\t// deallocated. (Although we set Cline = undefined in provider, that\\n 420 | \\t\\t// simply removes the reference to this instance, but the instance is\\n 421 | \\t\\t// still alive until this promise resolves or rejects.)\\n 422 | \\t\\tif (this.abort) {\\n 423 | \\t\\t\\tthrow new Error(`[RooCode#ask] task ${this.taskId}.${this.instanceId} aborted`)\\n 424 | \\t\\t}\\n 425 | \\n 426 | \\t\\tlet askTs: number\\n 427 | \\n 428 | \\t\\tif (partial !== undefined) {\\n 429 | \\t\\t\\tconst lastMessage = this.clineMessages.at(-1)\\n 430 | \\n 431 | \\t\\t\\tconst isUpdatingPreviousPartial =\\n 432 | \\t\\t\\t\\tlastMessage && lastMessage.partial && lastMessage.type === \\\"ask\\\" && lastMessage.ask === type\\n 433 | \\n 434 | \\t\\t\\tif (partial) {\\n 435 | \\t\\t\\t\\tif (isUpdatingPreviousPartial) {\\n 436 | \\t\\t\\t\\t\\t// Existing partial message, so update it.\\n 437 | \\t\\t\\t\\t\\tlastMessage.text = text\\n 438 | \\t\\t\\t\\t\\tlastMessage.partial = partial\\n 439 | \\t\\t\\t\\t\\tlastMessage.progressStatus = progressStatus\\n 440 | \\t\\t\\t\\t\\tlastMessage.isProtected = isProtected\\n 441 | \\t\\t\\t\\t\\t// TODO: Be more efficient about saving and posting only new\\n 442 | \\t\\t\\t\\t\\t// data or one whole message at a time so ignore partial for\\n 443 | \\t\\t\\t\\t\\t// saves, and only post parts of partial message instead of\\n 444 | \\t\\t\\t\\t\\t// whole array in new listener.\\n 445 | \\t\\t\\t\\t\\tthis.updateClineMessage(lastMessage)\\n 446 | \\t\\t\\t\\t\\tthrow new Error(\\\"Current ask promise was ignored (#1)\\\")\\n 447 | \\t\\t\\t\\t} else {\\n 448 | \\t\\t\\t\\t\\t// This is a new partial message, so add it with partial\\n 449 | \\t\\t\\t\\t\\t// state.\\n 450 | \\t\\t\\t\\t\\taskTs = Date.now()\\n 451 | \\t\\t\\t\\t\\tthis.lastMessageTs = askTs\\n 452 | \\t\\t\\t\\t\\tawait this.addToClineMessages({ ts: askTs, type: \\\"ask\\\", ask: type, text, partial, isProtected })\\n 453 | \\t\\t\\t\\t\\tthrow new Error(\\\"Current ask promise was ignored (#2)\\\")\\n 454 | \\t\\t\\t\\t}\\n 455 | \\t\\t\\t} else {\\n 456 | \\t\\t\\t\\tif (isUpdatingPreviousPartial) {\\n 457 | \\t\\t\\t\\t\\t// This is the complete version of a previously partial\\n 458 | \\t\\t\\t\\t\\t// message, so replace the partial with the complete version.\\n 459 | \\t\\t\\t\\t\\tthis.askResponse = undefined\\n 460 | \\t\\t\\t\\t\\tthis.askResponseText = undefined\\n 461 | \\t\\t\\t\\t\\tthis.askResponseImages = undefined\\n 462 | \\n 463 | \\t\\t\\t\\t\\t// Bug for the history books:\\n 464 | \\t\\t\\t\\t\\t// In the webview we use the ts as the chatrow key for the\\n 465 | \\t\\t\\t\\t\\t// virtuoso list. Since we would update this ts right at the\\n 466 | \\t\\t\\t\\t\\t// end of streaming, it would cause the view to flicker. The\\n 467 | \\t\\t\\t\\t\\t// key prop has to be stable otherwise react has trouble\\n 468 | \\t\\t\\t\\t\\t// reconciling items between renders, causing unmounting and\\n 469 | \\t\\t\\t\\t\\t// remounting of components (flickering).\\n 470 | \\t\\t\\t\\t\\t// The lesson here is if you see flickering when rendering\\n 471 | \\t\\t\\t\\t\\t// lists, it's likely because the key prop is not stable.\\n 472 | \\t\\t\\t\\t\\t// So in this case we must make sure that the message ts is\\n 473 | \\t\\t\\t\\t\\t// never altered after first setting it.\\n 474 | \\t\\t\\t\\t\\taskTs = lastMessage.ts\\n 475 | \\t\\t\\t\\t\\tthis.lastMessageTs = askTs\\n 476 | \\t\\t\\t\\t\\tlastMessage.text = text\\n 477 | \\t\\t\\t\\t\\tlastMessage.partial = false\\n 478 | \\t\\t\\t\\t\\tlastMessage.progressStatus = progressStatus\\n 479 | \\t\\t\\t\\t\\tlastMessage.isProtected = isProtected\\n 480 | \\t\\t\\t\\t\\tawait this.saveClineMessages()\\n 481 | \\t\\t\\t\\t\\tthis.updateClineMessage(lastMessage)\\n 482 | \\t\\t\\t\\t} else {\\n 483 | \\t\\t\\t\\t\\t// This is a new and complete message, so add it like normal.\\n 484 | \\t\\t\\t\\t\\tthis.askResponse = undefined\\n 485 | \\t\\t\\t\\t\\tthis.askResponseText = undefined\\n 486 | \\t\\t\\t\\t\\tthis.askResponseImages = undefined\\n 487 | \\t\\t\\t\\t\\taskTs = Date.now()\\n 488 | \\t\\t\\t\\t\\tthis.lastMessageTs = askTs\\n 489 | \\t\\t\\t\\t\\tawait this.addToClineMessages({ ts: askTs, type: \\\"ask\\\", ask: type, text, isProtected })\\n 490 | \\t\\t\\t\\t}\\n 491 | \\t\\t\\t}\\n 492 | \\t\\t} else {\\n 493 | \\t\\t\\t// This is a new non-partial message, so add it like normal.\\n 494 | \\t\\t\\tthis.askResponse = undefined\\n 495 | \\t\\t\\tthis.askResponseText = undefined\\n 496 | \\t\\t\\tthis.askResponseImages = undefined\\n 497 | \\t\\t\\taskTs = Date.now()\\n 498 | \\t\\t\\tthis.lastMessageTs = askTs\\n 499 | \\t\\t\\tawait this.addToClineMessages({ ts: askTs, type: \\\"ask\\\", ask: type, text, isProtected })\\n 500 | \\t\\t}\\n 501 | \\n 502 | \\t\\tawait pWaitFor(() => this.askResponse !== undefined || this.lastMessageTs !== askTs, { interval: 100 })\\n 503 | \\n 504 | \\t\\tif (this.lastMessageTs !== askTs) {\\n 505 | \\t\\t\\t// Could happen if we send multiple asks in a row i.e. with\\n 506 | \\t\\t\\t// command_output. It's important that when we know an ask could\\n 507 | \\t\\t\\t// fail, it is handled gracefully.\\n 508 | \\t\\t\\tthrow new Error(\\\"Current ask promise was ignored\\\")\\n 509 | \\t\\t}\\n 510 | \\n 511 | \\t\\tconst result = { response: this.askResponse!, text: this.askResponseText, images: this.askResponseImages }\\n 512 | \\t\\tthis.askResponse = undefined\\n 513 | \\t\\tthis.askResponseText = undefined\\n 514 | \\t\\tthis.askResponseImages = undefined\\n 515 | \\t\\tthis.emit(\\\"taskAskResponded\\\")\\n 516 | \\t\\treturn result\\n 517 | \\t}\\n 518 | \\n 519 | \\tasync handleWebviewAskResponse(askResponse: ClineAskResponse, text?: string, images?: string[]) {\\n 520 | \\t\\tthis.askResponse = askResponse\\n 521 | \\t\\tthis.askResponseText = text\\n 522 | \\t\\tthis.askResponseImages = images\\n 523 | \\t}\\n 524 | \\n 525 | \\tasync handleTerminalOperation(terminalOperation: \\\"continue\\\" | \\\"abort\\\") {\\n 526 | \\t\\tif (terminalOperation === \\\"continue\\\") {\\n 527 | \\t\\t\\tthis.terminalProcess?.continue()\\n 528 | \\t\\t} else if (terminalOperation === \\\"abort\\\") {\\n 529 | \\t\\t\\tthis.terminalProcess?.abort()\\n 530 | \\t\\t}\\n 531 | \\t}\\n 532 | \\n 533 | \\tpublic async condenseContext(): Promise<void> {\\n 534 | \\t\\tconst systemPrompt = await this.getSystemPrompt()\\n 535 | \\n 536 | \\t\\t// Get condensing configuration\\n 537 | \\t\\t// Using type assertion to handle the case where Phase 1 hasn't been implemented yet\\n 538 | \\t\\tconst state = await this.providerRef.deref()?.getState()\\n 539 | \\t\\tconst customCondensingPrompt = state ? (state as any).customCondensingPrompt : undefined\\n 540 | \\t\\tconst condensingApiConfigId = state ? (state as any).condensingApiConfigId : undefined\\n 541 | \\t\\tconst listApiConfigMeta = state ? (state as any).listApiConfigMeta : undefined\\n 542 | \\n 543 | \\t\\t// Determine API handler to use\\n 544 | \\t\\tlet condensingApiHandler: ApiHandler | undefined\\n 545 | \\t\\tif (condensingApiConfigId && listApiConfigMeta && Array.isArray(listApiConfigMeta)) {\\n 546 | \\t\\t\\t// Using type assertion for the id property to avoid implicit any\\n 547 | \\t\\t\\tconst matchingConfig = listApiConfigMeta.find((config: any) => config.id === condensingApiConfigId)\\n 548 | \\t\\t\\tif (matchingConfig) {\\n 549 | \\t\\t\\t\\tconst profile = await this.providerRef.deref()?.providerSettingsManager.getProfile({\\n 550 | \\t\\t\\t\\t\\tid: condensingApiConfigId,\\n 551 | \\t\\t\\t\\t})\\n 552 | \\t\\t\\t\\t// Ensure profile and apiProvider exist before trying to build handler\\n 553 | \\t\\t\\t\\tif (profile && profile.apiProvider) {\\n 554 | \\t\\t\\t\\t\\tcondensingApiHandler = buildApiHandler(profile)\\n 555 | \\t\\t\\t\\t}\\n 556 | \\t\\t\\t}\\n 557 | \\t\\t}\\n 558 | \\n 559 | \\t\\tconst { contextTokens: prevContextTokens } = this.getTokenUsage()\\n 560 | \\t\\tconst {\\n 561 | \\t\\t\\tmessages,\\n 562 | \\t\\t\\tsummary,\\n 563 | \\t\\t\\tcost,\\n 564 | \\t\\t\\tnewContextTokens = 0,\\n 565 | \\t\\t\\terror,\\n 566 | \\t\\t} = await summarizeConversation(\\n 567 | \\t\\t\\tthis.apiConversationHistory,\\n 568 | \\t\\t\\tthis.api, // Main API handler (fallback)\\n 569 | \\t\\t\\tsystemPrompt, // Default summarization prompt (fallback)\\n 570 | \\t\\t\\tthis.taskId,\\n 571 | \\t\\t\\tprevContextTokens,\\n 572 | \\t\\t\\tfalse, // manual trigger\\n 573 | \\t\\t\\tcustomCondensingPrompt, // User's custom prompt\\n 574 | \\t\\t\\tcondensingApiHandler, // Specific handler for condensing\\n 575 | \\t\\t)\\n 576 | \\t\\tif (error) {\\n 577 | \\t\\t\\tthis.say(\\n 578 | \\t\\t\\t\\t\\\"condense_context_error\\\",\\n 579 | \\t\\t\\t\\terror,\\n 580 | \\t\\t\\t\\tundefined /* images */,\\n 581 | \\t\\t\\t\\tfalse /* partial */,\\n 582 | \\t\\t\\t\\tundefined /* checkpoint */,\\n 583 | \\t\\t\\t\\tundefined /* progressStatus */,\\n 584 | \\t\\t\\t\\t{ isNonInteractive: true } /* options */,\\n 585 | \\t\\t\\t)\\n 586 | \\t\\t\\treturn\\n 587 | \\t\\t}\\n 588 | \\t\\tawait this.overwriteApiConversationHistory(messages)\\n 589 | \\t\\tconst contextCondense: ContextCondense = { summary, cost, newContextTokens, prevContextTokens }\\n 590 | \\t\\tawait this.say(\\n 591 | \\t\\t\\t\\\"condense_context\\\",\\n 592 | \\t\\t\\tundefined /* text */,\\n 593 | \\t\\t\\tundefined /* images */,\\n 594 | \\t\\t\\tfalse /* partial */,\\n 595 | \\t\\t\\tundefined /* checkpoint */,\\n 596 | \\t\\t\\tundefined /* progressStatus */,\\n 597 | \\t\\t\\t{ isNonInteractive: true } /* options */,\\n 598 | \\t\\t\\tcontextCondense,\\n 599 | \\t\\t)\\n 600 | \\t}\\n 601 | \\n 602 | \\tasync say(\\n 603 | \\t\\ttype: ClineSay,\\n 604 | \\t\\ttext?: string,\\n 605 | \\t\\timages?: string[],\\n 606 | \\t\\tpartial?: boolean,\\n 607 | \\t\\tcheckpoint?: Record<string, unknown>,\\n 608 | \\t\\tprogressStatus?: ToolProgressStatus,\\n 609 | \\t\\toptions: {\\n 610 | \\t\\t\\tisNonInteractive?: boolean\\n 611 | \\t\\t} = {},\\n 612 | \\t\\tcontextCondense?: ContextCondense,\\n 613 | \\t): Promise<undefined> {\\n 614 | \\t\\tif (this.abort) {\\n 615 | \\t\\t\\tthrow new Error(`[RooCode#say] task ${this.taskId}.${this.instanceId} aborted`)\\n 616 | \\t\\t}\\n 617 | \\n 618 | \\t\\tif (partial !== undefined) {\\n 619 | \\t\\t\\tconst lastMessage = this.clineMessages.at(-1)\\n 620 | \\n 621 | \\t\\t\\tconst isUpdatingPreviousPartial =\\n 622 | \\t\\t\\t\\tlastMessage && lastMessage.partial && lastMessage.type === \\\"say\\\" && lastMessage.say === type\\n 623 | \\n 624 | \\t\\t\\tif (partial) {\\n 625 | \\t\\t\\t\\tif (isUpdatingPreviousPartial) {\\n 626 | \\t\\t\\t\\t\\t// Existing partial message, so update it.\\n 627 | \\t\\t\\t\\t\\tlastMessage.text = text\\n 628 | \\t\\t\\t\\t\\tlastMessage.images = images\\n 629 | \\t\\t\\t\\t\\tlastMessage.partial = partial\\n 630 | \\t\\t\\t\\t\\tlastMessage.progressStatus = progressStatus\\n 631 | \\t\\t\\t\\t\\tthis.updateClineMessage(lastMessage)\\n 632 | \\t\\t\\t\\t} else {\\n 633 | \\t\\t\\t\\t\\t// This is a new partial message, so add it with partial state.\\n 634 | \\t\\t\\t\\t\\tconst sayTs = Date.now()\\n 635 | \\n 636 | \\t\\t\\t\\t\\tif (!options.isNonInteractive) {\\n 637 | \\t\\t\\t\\t\\t\\tthis.lastMessageTs = sayTs\\n 638 | \\t\\t\\t\\t\\t}\\n 639 | \\n 640 | \\t\\t\\t\\t\\tawait this.addToClineMessages({\\n 641 | \\t\\t\\t\\t\\t\\tts: sayTs,\\n 642 | \\t\\t\\t\\t\\t\\ttype: \\\"say\\\",\\n 643 | \\t\\t\\t\\t\\t\\tsay: type,\\n 644 | \\t\\t\\t\\t\\t\\ttext,\\n 645 | \\t\\t\\t\\t\\t\\timages,\\n 646 | \\t\\t\\t\\t\\t\\tpartial,\\n 647 | \\t\\t\\t\\t\\t\\tcontextCondense,\\n 648 | \\t\\t\\t\\t\\t})\\n 649 | \\t\\t\\t\\t}\\n 650 | \\t\\t\\t} else {\\n 651 | \\t\\t\\t\\t// New now have a complete version of a previously partial message.\\n 652 | \\t\\t\\t\\t// This is the complete version of a previously partial\\n 653 | \\t\\t\\t\\t// message, so replace the partial with the complete version.\\n 654 | \\t\\t\\t\\tif (isUpdatingPreviousPartial) {\\n 655 | \\t\\t\\t\\t\\tif (!options.isNonInteractive) {\\n 656 | \\t\\t\\t\\t\\t\\tthis.lastMessageTs = lastMessage.ts\\n 657 | \\t\\t\\t\\t\\t}\\n 658 | \\n 659 | \\t\\t\\t\\t\\tlastMessage.text = text\\n 660 | \\t\\t\\t\\t\\tlastMessage.images = images\\n 661 | \\t\\t\\t\\t\\tlastMessage.partial = false\\n 662 | \\t\\t\\t\\t\\tlastMessage.progressStatus = progressStatus\\n 663 | \\n 664 | \\t\\t\\t\\t\\t// Instead of streaming partialMessage events, we do a save\\n 665 | \\t\\t\\t\\t\\t// and post like normal to persist to disk.\\n 666 | \\t\\t\\t\\t\\tawait this.saveClineMessages()\\n 667 | \\n 668 | \\t\\t\\t\\t\\t// More performant than an entire `postStateToWebview`.\\n 669 | \\t\\t\\t\\t\\tthis.updateClineMessage(lastMessage)\\n 670 | \\t\\t\\t\\t} else {\\n 671 | \\t\\t\\t\\t\\t// This is a new and complete message, so add it like normal.\\n 672 | \\t\\t\\t\\t\\tconst sayTs = Date.now()\\n 673 | \\n 674 | \\t\\t\\t\\t\\tif (!options.isNonInteractive) {\\n 675 | \\t\\t\\t\\t\\t\\tthis.lastMessageTs = sayTs\\n 676 | \\t\\t\\t\\t\\t}\\n 677 | \\n 678 | \\t\\t\\t\\t\\tawait this.addToClineMessages({ ts: sayTs, type: \\\"say\\\", say: type, text, images, contextCondense })\\n 679 | \\t\\t\\t\\t}\\n 680 | \\t\\t\\t}\\n 681 | \\t\\t} else {\\n 682 | \\t\\t\\t// This is a new non-partial message, so add it like normal.\\n 683 | \\t\\t\\tconst sayTs = Date.now()\\n 684 | \\n 685 | \\t\\t\\t// A \\\"non-interactive\\\" message is a message is one that the user\\n 686 | \\t\\t\\t// does not need to respond to. We don't want these message types\\n 687 | \\t\\t\\t// to trigger an update to `lastMessageTs` since they can be created\\n 688 | \\t\\t\\t// asynchronously and could interrupt a pending ask.\\n 689 | \\t\\t\\tif (!options.isNonInteractive) {\\n 690 | \\t\\t\\t\\tthis.lastMessageTs = sayTs\\n 691 | \\t\\t\\t}\\n 692 | \\n 693 | \\t\\t\\tawait this.addToClineMessages({\\n 694 | \\t\\t\\t\\tts: sayTs,\\n 695 | \\t\\t\\t\\ttype: \\\"say\\\",\\n 696 | \\t\\t\\t\\tsay: type,\\n 697 | \\t\\t\\t\\ttext,\\n 698 | \\t\\t\\t\\timages,\\n 699 | \\t\\t\\t\\tcheckpoint,\\n 700 | \\t\\t\\t\\tcontextCondense,\\n 701 | \\t\\t\\t})\\n 702 | \\t\\t}\\n 703 | \\t}\\n 704 | \\n 705 | \\tasync sayAndCreateMissingParamError(toolName: ToolName, paramName: string, relPath?: string) {\\n 706 | \\t\\tawait this.say(\\n 707 | \\t\\t\\t\\\"error\\\",\\n 708 | \\t\\t\\t`Roo tried to use ${toolName}${\\n 709 | \\t\\t\\t\\trelPath ? ` for '${relPath.toPosix()}'` : \\\"\\\"\\n 710 | \\t\\t\\t} without value for required parameter '${paramName}'. Retrying...`,\\n 711 | \\t\\t)\\n 712 | \\t\\treturn formatResponse.toolError(formatResponse.missingToolParameterError(paramName))\\n 713 | \\t}\\n 714 | \\n 715 | \\t// Start / Abort / Resume\\n 716 | \\n 717 | \\tprivate async startTask(task?: string, images?: string[]): Promise<void> {\\n 718 | \\t\\t// `conversationHistory` (for API) and `clineMessages` (for webview)\\n 719 | \\t\\t// need to be in sync.\\n 720 | \\t\\t// If the extension process were killed, then on restart the\\n 721 | \\t\\t// `clineMessages` might not be empty, so we need to set it to [] when\\n 722 | \\t\\t// we create a new Cline client (otherwise webview would show stale\\n 723 | \\t\\t// messages from previous session).\\n 724 | \\t\\tthis.clineMessages = []\\n 725 | \\t\\tthis.apiConversationHistory = []\\n 726 | \\t\\tawait this.providerRef.deref()?.postStateToWebview()\\n 727 | \\n 728 | \\t\\tawait this.say(\\\"text\\\", task, images)\\n 729 | \\t\\tthis.isInitialized = true\\n 730 | \\n 731 | \\t\\tlet imageBlocks: Anthropic.ImageBlockParam[] = formatResponse.imageBlocks(images)\\n 732 | \\n 733 | \\t\\tconsole.log(`[subtasks] task ${this.taskId}.${this.instanceId} starting`)\\n 734 | \\n 735 | \\t\\tawait this.initiateTaskLoop([\\n 736 | \\t\\t\\t{\\n 737 | \\t\\t\\t\\ttype: \\\"text\\\",\\n 738 | \\t\\t\\t\\ttext: `<task>\\\\n${task}\\\\n</task>`,\\n 739 | \\t\\t\\t},\\n 740 | \\t\\t\\t...imageBlocks,\\n 741 | \\t\\t])\\n 742 | \\t}\\n 743 | \\n 744 | \\tpublic async resumePausedTask(lastMessage: string) {\\n 745 | \\t\\t// Release this Cline instance from paused state.\\n 746 | \\t\\tthis.isPaused = false\\n 747 | \\t\\tthis.emit(\\\"taskUnpaused\\\")\\n 748 | \\n 749 | \\t\\t// Fake an answer from the subtask that it has completed running and\\n 750 | \\t\\t// this is the result of what it has done  add the message to the chat\\n 751 | \\t\\t// history and to the webview ui.\\n 752 | \\t\\ttry {\\n 753 | \\t\\t\\tawait this.say(\\\"subtask_result\\\", lastMessage)\\n 754 | \\n 755 | \\t\\t\\tawait this.addToApiConversationHistory({\\n 756 | \\t\\t\\t\\trole: \\\"user\\\",\\n 757 | \\t\\t\\t\\tcontent: [{ type: \\\"text\\\", text: `[new_task completed] Result: ${lastMessage}` }],\\n 758 | \\t\\t\\t})\\n 759 | \\t\\t} catch (error) {\\n 760 | \\t\\t\\tthis.providerRef\\n 761 | \\t\\t\\t\\t.deref()\\n 762 | \\t\\t\\t\\t?.log(`Error failed to add reply from subtask into conversation of parent task, error: ${error}`)\\n 763 | \\n 764 | \\t\\t\\tthrow error\\n 765 | \\t\\t}\\n 766 | \\t}\\n 767 | \\n 768 | \\tprivate async resumeTaskFromHistory() {\\n 769 | \\t\\tconst modifiedClineMessages = await this.getSavedClineMessages()\\n 770 | \\n 771 | \\t\\t// Remove any resume messages that may have been added before\\n 772 | \\t\\tconst lastRelevantMessageIndex = findLastIndex(\\n 773 | \\t\\t\\tmodifiedClineMessages,\\n 774 | \\t\\t\\t(m) => !(m.ask === \\\"resume_task\\\" || m.ask === \\\"resume_completed_task\\\"),\\n 775 | \\t\\t)\\n 776 | \\n 777 | \\t\\tif (lastRelevantMessageIndex !== -1) {\\n 778 | \\t\\t\\tmodifiedClineMessages.splice(lastRelevantMessageIndex + 1)\\n 779 | \\t\\t}\\n 780 | \\n 781 | \\t\\t// since we don't use api_req_finished anymore, we need to check if the last api_req_started has a cost value, if it doesn't and no cancellation reason to present, then we remove it since it indicates an api request without any partial content streamed\\n 782 | \\t\\tconst lastApiReqStartedIndex = findLastIndex(\\n 783 | \\t\\t\\tmodifiedClineMessages,\\n 784 | \\t\\t\\t(m) => m.type === \\\"say\\\" && m.say === \\\"api_req_started\\\",\\n 785 | \\t\\t)\\n 786 | \\n 787 | \\t\\tif (lastApiReqStartedIndex !== -1) {\\n 788 | \\t\\t\\tconst lastApiReqStarted = modifiedClineMessages[lastApiReqStartedIndex]\\n 789 | \\t\\t\\tconst { cost, cancelReason }: ClineApiReqInfo = JSON.parse(lastApiReqStarted.text || \\\"{}\\\")\\n 790 | \\t\\t\\tif (cost === undefined && cancelReason === undefined) {\\n 791 | \\t\\t\\t\\tmodifiedClineMessages.splice(lastApiReqStartedIndex, 1)\\n 792 | \\t\\t\\t}\\n 793 | \\t\\t}\\n 794 | \\n 795 | \\t\\tawait this.overwriteClineMessages(modifiedClineMessages)\\n 796 | \\t\\tthis.clineMessages = await this.getSavedClineMessages()\\n 797 | \\n 798 | \\t\\t// Now present the cline messages to the user and ask if they want to\\n 799 | \\t\\t// resume (NOTE: we ran into a bug before where the\\n 800 | \\t\\t// apiConversationHistory wouldn't be initialized when opening a old\\n 801 | \\t\\t// task, and it was because we were waiting for resume).\\n 802 | \\t\\t// This is important in case the user deletes messages without resuming\\n 803 | \\t\\t// the task first.\\n 804 | \\t\\tthis.apiConversationHistory = await this.getSavedApiConversationHistory()\\n 805 | \\n 806 | \\t\\tconst lastClineMessage = this.clineMessages\\n 807 | \\t\\t\\t.slice()\\n 808 | \\t\\t\\t.reverse()\\n 809 | \\t\\t\\t.find((m) => !(m.ask === \\\"resume_task\\\" || m.ask === \\\"resume_completed_task\\\")) // could be multiple resume tasks\\n 810 | \\n 811 | \\t\\tlet askType: ClineAsk\\n 812 | \\t\\tif (lastClineMessage?.ask === \\\"completion_result\\\") {\\n 813 | \\t\\t\\taskType = \\\"resume_completed_task\\\"\\n 814 | \\t\\t} else {\\n 815 | \\t\\t\\taskType = \\\"resume_task\\\"\\n 816 | \\t\\t}\\n 817 | \\n 818 | \\t\\tthis.isInitialized = true\\n 819 | \\n 820 | \\t\\tconst { response, text, images } = await this.ask(askType) // calls poststatetowebview\\n 821 | \\t\\tlet responseText: string | undefined\\n 822 | \\t\\tlet responseImages: string[] | undefined\\n 823 | \\t\\tif (response === \\\"messageResponse\\\") {\\n 824 | \\t\\t\\tawait this.say(\\\"user_feedback\\\", text, images)\\n 825 | \\t\\t\\tresponseText = text\\n 826 | \\t\\t\\tresponseImages = images\\n 827 | \\t\\t}\\n 828 | \\n 829 | \\t\\t// Make sure that the api conversation history can be resumed by the API,\\n 830 | \\t\\t// even if it goes out of sync with cline messages.\\n 831 | \\t\\tlet existingApiConversationHistory: ApiMessage[] = await this.getSavedApiConversationHistory()\\n 832 | \\n 833 | \\t\\t// v2.0 xml tags refactor caveat: since we don't use tools anymore, we need to replace all tool use blocks with a text block since the API disallows conversations with tool uses and no tool schema\\n 834 | \\t\\tconst conversationWithoutToolBlocks = existingApiConversationHistory.map((message) => {\\n 835 | \\t\\t\\tif (Array.isArray(message.content)) {\\n 836 | \\t\\t\\t\\tconst newContent = message.content.map((block) => {\\n 837 | \\t\\t\\t\\t\\tif (block.type === \\\"tool_use\\\") {\\n 838 | \\t\\t\\t\\t\\t\\t// It's important we convert to the new tool schema\\n 839 | \\t\\t\\t\\t\\t\\t// format so the model doesn't get confused about how to\\n 840 | \\t\\t\\t\\t\\t\\t// invoke tools.\\n 841 | \\t\\t\\t\\t\\t\\tconst inputAsXml = Object.entries(block.input as Record<string, string>)\\n 842 | \\t\\t\\t\\t\\t\\t\\t.map(([key, value]) => `<${key}>\\\\n${value}\\\\n</${key}>`)\\n 843 | \\t\\t\\t\\t\\t\\t\\t.join(\\\"\\\\n\\\")\\n 844 | \\t\\t\\t\\t\\t\\treturn {\\n 845 | \\t\\t\\t\\t\\t\\t\\ttype: \\\"text\\\",\\n 846 | \\t\\t\\t\\t\\t\\t\\ttext: `<${block.name}>\\\\n${inputAsXml}\\\\n</${block.name}>`,\\n 847 | \\t\\t\\t\\t\\t\\t} as Anthropic.Messages.TextBlockParam\\n 848 | \\t\\t\\t\\t\\t} else if (block.type === \\\"tool_result\\\") {\\n 849 | \\t\\t\\t\\t\\t\\t// Convert block.content to text block array, removing images\\n 850 | \\t\\t\\t\\t\\t\\tconst contentAsTextBlocks = Array.isArray(block.content)\\n 851 | \\t\\t\\t\\t\\t\\t\\t? block.content.filter((item) => item.type === \\\"text\\\")\\n 852 | \\t\\t\\t\\t\\t\\t\\t: [{ type: \\\"text\\\", text: block.content }]\\n 853 | \\t\\t\\t\\t\\t\\tconst textContent = contentAsTextBlocks.map((item) => item.text).join(\\\"\\\\n\\\\n\\\")\\n 854 | \\t\\t\\t\\t\\t\\tconst toolName = findToolName(block.tool_use_id, existingApiConversationHistory)\\n 855 | \\t\\t\\t\\t\\t\\treturn {\\n 856 | \\t\\t\\t\\t\\t\\t\\ttype: \\\"text\\\",\\n 857 | \\t\\t\\t\\t\\t\\t\\ttext: `[${toolName} Result]\\\\n\\\\n${textContent}`,\\n 858 | \\t\\t\\t\\t\\t\\t} as Anthropic.Messages.TextBlockParam\\n 859 | \\t\\t\\t\\t\\t}\\n 860 | \\t\\t\\t\\t\\treturn block\\n 861 | \\t\\t\\t\\t})\\n 862 | \\t\\t\\t\\treturn { ...message, content: newContent }\\n 863 | \\t\\t\\t}\\n 864 | \\t\\t\\treturn message\\n 865 | \\t\\t})\\n 866 | \\t\\texistingApiConversationHistory = conversationWithoutToolBlocks\\n 867 | \\n 868 | \\t\\t// FIXME: remove tool use blocks altogether\\n 869 | \\n 870 | \\t\\t// if the last message is an assistant message, we need to check if there's tool use since every tool use has to have a tool response\\n 871 | \\t\\t// if there's no tool use and only a text block, then we can just add a user message\\n 872 | \\t\\t// (note this isn't relevant anymore since we use custom tool prompts instead of tool use blocks, but this is here for legacy purposes in case users resume old tasks)\\n 873 | \\n 874 | \\t\\t// if the last message is a user message, we can need to get the assistant message before it to see if it made tool calls, and if so, fill in the remaining tool responses with 'interrupted'\\n 875 | \\n 876 | \\t\\tlet modifiedOldUserContent: Anthropic.Messages.ContentBlockParam[] // either the last message if its user message, or the user message before the last (assistant) message\\n 877 | \\t\\tlet modifiedApiConversationHistory: ApiMessage[] // need to remove the last user message to replace with new modified user message\\n 878 | \\t\\tif (existingApiConversationHistory.length > 0) {\\n 879 | \\t\\t\\tconst lastMessage = existingApiConversationHistory[existingApiConversationHistory.length - 1]\\n 880 | \\n 881 | \\t\\t\\tif (lastMessage.role === \\\"assistant\\\") {\\n 882 | \\t\\t\\t\\tconst content = Array.isArray(lastMessage.content)\\n 883 | \\t\\t\\t\\t\\t? lastMessage.content\\n 884 | \\t\\t\\t\\t\\t: [{ type: \\\"text\\\", text: lastMessage.content }]\\n 885 | \\t\\t\\t\\tconst hasToolUse = content.some((block) => block.type === \\\"tool_use\\\")\\n 886 | \\n 887 | \\t\\t\\t\\tif (hasToolUse) {\\n 888 | \\t\\t\\t\\t\\tconst toolUseBlocks = content.filter(\\n 889 | \\t\\t\\t\\t\\t\\t(block) => block.type === \\\"tool_use\\\",\\n 890 | \\t\\t\\t\\t\\t) as Anthropic.Messages.ToolUseBlock[]\\n 891 | \\t\\t\\t\\t\\tconst toolResponses: Anthropic.ToolResultBlockParam[] = toolUseBlocks.map((block) => ({\\n 892 | \\t\\t\\t\\t\\t\\ttype: \\\"tool_result\\\",\\n 893 | \\t\\t\\t\\t\\t\\ttool_use_id: block.id,\\n 894 | \\t\\t\\t\\t\\t\\tcontent: \\\"Task was interrupted before this tool call could be completed.\\\",\\n 895 | \\t\\t\\t\\t\\t}))\\n 896 | \\t\\t\\t\\t\\tmodifiedApiConversationHistory = [...existingApiConversationHistory] // no changes\\n 897 | \\t\\t\\t\\t\\tmodifiedOldUserContent = [...toolResponses]\\n 898 | \\t\\t\\t\\t} else {\\n 899 | \\t\\t\\t\\t\\tmodifiedApiConversationHistory = [...existingApiConversationHistory]\\n 900 | \\t\\t\\t\\t\\tmodifiedOldUserContent = []\\n 901 | \\t\\t\\t\\t}\\n 902 | \\t\\t\\t} else if (lastMessage.role === \\\"user\\\") {\\n 903 | \\t\\t\\t\\tconst previousAssistantMessage: ApiMessage | undefined =\\n 904 | \\t\\t\\t\\t\\texistingApiConversationHistory[existingApiConversationHistory.length - 2]\\n 905 | \\n 906 | \\t\\t\\t\\tconst existingUserContent: Anthropic.Messages.ContentBlockParam[] = Array.isArray(lastMessage.content)\\n 907 | \\t\\t\\t\\t\\t? lastMessage.content\\n 908 | \\t\\t\\t\\t\\t: [{ type: \\\"text\\\", text: lastMessage.content }]\\n 909 | \\t\\t\\t\\tif (previousAssistantMessage && previousAssistantMessage.role === \\\"assistant\\\") {\\n 910 | \\t\\t\\t\\t\\tconst assistantContent = Array.isArray(previousAssistantMessage.content)\\n 911 | \\t\\t\\t\\t\\t\\t? previousAssistantMessage.content\\n 912 | \\t\\t\\t\\t\\t\\t: [{ type: \\\"text\\\", text: previousAssistantMessage.content }]\\n 913 | \\n 914 | \\t\\t\\t\\t\\tconst toolUseBlocks = assistantContent.filter(\\n 915 | \\t\\t\\t\\t\\t\\t(block) => block.type === \\\"tool_use\\\",\\n 916 | \\t\\t\\t\\t\\t) as Anthropic.Messages.ToolUseBlock[]\\n 917 | \\n 918 | \\t\\t\\t\\t\\tif (toolUseBlocks.length > 0) {\\n 919 | \\t\\t\\t\\t\\t\\tconst existingToolResults = existingUserContent.filter(\\n 920 | \\t\\t\\t\\t\\t\\t\\t(block) => block.type === \\\"tool_result\\\",\\n 921 | \\t\\t\\t\\t\\t\\t) as Anthropic.ToolResultBlockParam[]\\n 922 | \\n 923 | \\t\\t\\t\\t\\t\\tconst missingToolResponses: Anthropic.ToolResultBlockParam[] = toolUseBlocks\\n 924 | \\t\\t\\t\\t\\t\\t\\t.filter(\\n 925 | \\t\\t\\t\\t\\t\\t\\t\\t(toolUse) => !existingToolResults.some((result) => result.tool_use_id === toolUse.id),\\n 926 | \\t\\t\\t\\t\\t\\t\\t)\\n 927 | \\t\\t\\t\\t\\t\\t\\t.map((toolUse) => ({\\n 928 | \\t\\t\\t\\t\\t\\t\\t\\ttype: \\\"tool_result\\\",\\n 929 | \\t\\t\\t\\t\\t\\t\\t\\ttool_use_id: toolUse.id,\\n 930 | \\t\\t\\t\\t\\t\\t\\t\\tcontent: \\\"Task was interrupted before this tool call could be completed.\\\",\\n 931 | \\t\\t\\t\\t\\t\\t\\t}))\\n 932 | \\n 933 | \\t\\t\\t\\t\\t\\tmodifiedApiConversationHistory = existingApiConversationHistory.slice(0, -1) // removes the last user message\\n 934 | \\t\\t\\t\\t\\t\\tmodifiedOldUserContent = [...existingUserContent, ...missingToolResponses]\\n 935 | \\t\\t\\t\\t\\t} else {\\n 936 | \\t\\t\\t\\t\\t\\tmodifiedApiConversationHistory = existingApiConversationHistory.slice(0, -1)\\n 937 | \\t\\t\\t\\t\\t\\tmodifiedOldUserContent = [...existingUserContent]\\n 938 | \\t\\t\\t\\t\\t}\\n 939 | \\t\\t\\t\\t} else {\\n 940 | \\t\\t\\t\\t\\tmodifiedApiConversationHistory = existingApiConversationHistory.slice(0, -1)\\n 941 | \\t\\t\\t\\t\\tmodifiedOldUserContent = [...existingUserContent]\\n 942 | \\t\\t\\t\\t}\\n 943 | \\t\\t\\t} else {\\n 944 | \\t\\t\\t\\tthrow new Error(\\\"Unexpected: Last message is not a user or assistant message\\\")\\n 945 | \\t\\t\\t}\\n 946 | \\t\\t} else {\\n 947 | \\t\\t\\tthrow new Error(\\\"Unexpected: No existing API conversation history\\\")\\n 948 | \\t\\t}\\n 949 | \\n 950 | \\t\\tlet newUserContent: Anthropic.Messages.ContentBlockParam[] = [...modifiedOldUserContent]\\n 951 | \\n 952 | \\t\\tconst agoText = ((): string => {\\n 953 | \\t\\t\\tconst timestamp = lastClineMessage?.ts ?? Date.now()\\n 954 | \\t\\t\\tconst now = Date.now()\\n 955 | \\t\\t\\tconst diff = now - timestamp\\n 956 | \\t\\t\\tconst minutes = Math.floor(diff / 60000)\\n 957 | \\t\\t\\tconst hours = Math.floor(minutes / 60)\\n 958 | \\t\\t\\tconst days = Math.floor(hours / 24)\\n 959 | \\n 960 | \\t\\t\\tif (days > 0) {\\n 961 | \\t\\t\\t\\treturn `${days} day${days > 1 ? \\\"s\\\" : \\\"\\\"} ago`\\n 962 | \\t\\t\\t}\\n 963 | \\t\\t\\tif (hours > 0) {\\n 964 | \\t\\t\\t\\treturn `${hours} hour${hours > 1 ? \\\"s\\\" : \\\"\\\"} ago`\\n 965 | \\t\\t\\t}\\n 966 | \\t\\t\\tif (minutes > 0) {\\n 967 | \\t\\t\\t\\treturn `${minutes} minute${minutes > 1 ? \\\"s\\\" : \\\"\\\"} ago`\\n 968 | \\t\\t\\t}\\n 969 | \\t\\t\\treturn \\\"just now\\\"\\n 970 | \\t\\t})()\\n 971 | \\n 972 | \\t\\tconst lastTaskResumptionIndex = newUserContent.findIndex(\\n 973 | \\t\\t\\t(x) => x.type === \\\"text\\\" && x.text.startsWith(\\\"[TASK RESUMPTION]\\\"),\\n 974 | \\t\\t)\\n 975 | \\t\\tif (lastTaskResumptionIndex !== -1) {\\n 976 | \\t\\t\\tnewUserContent.splice(lastTaskResumptionIndex, newUserContent.length - lastTaskResumptionIndex)\\n 977 | \\t\\t}\\n 978 | \\n 979 | \\t\\tconst wasRecent = lastClineMessage?.ts && Date.now() - lastClineMessage.ts < 30_000\\n 980 | \\n 981 | \\t\\tnewUserContent.push({\\n 982 | \\t\\t\\ttype: \\\"text\\\",\\n 983 | \\t\\t\\ttext:\\n 984 | \\t\\t\\t\\t`[TASK RESUMPTION] This task was interrupted ${agoText}. It may or may not be complete, so please reassess the task context. Be aware that the project state may have changed since then. If the task has not been completed, retry the last step before interruption and proceed with completing the task.\\\\n\\\\nNote: If you previously attempted a tool use that the user did not provide a result for, you should assume the tool use was not successful and assess whether you should retry. If the last tool was a browser_action, the browser has been closed and you must launch a new browser if needed.${\\n 985 | \\t\\t\\t\\t\\twasRecent\\n 986 | \\t\\t\\t\\t\\t\\t? \\\"\\\\n\\\\nIMPORTANT: If the last tool use was a write_to_file that was interrupted, the file was reverted back to its original state before the interrupted edit, and you do NOT need to re-read the file as you already have its up-to-date contents.\\\"\\n 987 | \\t\\t\\t\\t\\t\\t: \\\"\\\"\\n 988 | \\t\\t\\t\\t}` +\\n 989 | \\t\\t\\t\\t(responseText\\n 990 | \\t\\t\\t\\t\\t? `\\\\n\\\\nNew instructions for task continuation:\\\\n<user_message>\\\\n${responseText}\\\\n</user_message>`\\n 991 | \\t\\t\\t\\t\\t: \\\"\\\"),\\n 992 | \\t\\t})\\n 993 | \\n 994 | \\t\\tif (responseImages && responseImages.length > 0) {\\n 995 | \\t\\t\\tnewUserContent.push(...formatResponse.imageBlocks(responseImages))\\n 996 | \\t\\t}\\n 997 | \\n 998 | \\t\\tawait this.overwriteApiConversationHistory(modifiedApiConversationHistory)\\n 999 | \\n1000 | \\t\\tconsole.log(`[subtasks] task ${this.taskId}.${this.instanceId} resuming from history item`)\\n1001 | \\n1002 | \\t\\tawait this.initiateTaskLoop(newUserContent)\\n1003 | \\t}\\n1004 | \\n1005 | \\tpublic dispose(): void {\\n1006 | \\t\\t// Stop waiting for child task completion.\\n1007 | \\t\\tif (this.pauseInterval) {\\n1008 | \\t\\t\\tclearInterval(this.pauseInterval)\\n1009 | \\t\\t\\tthis.pauseInterval = undefined\\n1010 | \\t\\t}\\n1011 | \\n1012 | \\t\\t// Release any terminals associated with this task.\\n1013 | \\t\\ttry {\\n1014 | \\t\\t\\t// Release any terminals associated with this task.\\n1015 | \\t\\t\\tTerminalRegistry.releaseTerminalsForTask(this.taskId)\\n1016 | \\t\\t} catch (error) {\\n1017 | \\t\\t\\tconsole.error(\\\"Error releasing terminals:\\\", error)\\n1018 | \\t\\t}\\n1019 | \\n1020 | \\t\\ttry {\\n1021 | \\t\\t\\tthis.urlContentFetcher.closeBrowser()\\n1022 | \\t\\t} catch (error) {\\n1023 | \\t\\t\\tconsole.error(\\\"Error closing URL content fetcher browser:\\\", error)\\n1024 | \\t\\t}\\n1025 | \\n1026 | \\t\\ttry {\\n1027 | \\t\\t\\tthis.browserSession.closeBrowser()\\n1028 | \\t\\t} catch (error) {\\n1029 | \\t\\t\\tconsole.error(\\\"Error closing browser session:\\\", error)\\n1030 | \\t\\t}\\n1031 | \\n1032 | \\t\\ttry {\\n1033 | \\t\\t\\tif (this.rooIgnoreController) {\\n1034 | \\t\\t\\t\\tthis.rooIgnoreController.dispose()\\n1035 | \\t\\t\\t\\tthis.rooIgnoreController = undefined\\n1036 | \\t\\t\\t}\\n1037 | \\t\\t} catch (error) {\\n1038 | \\t\\t\\tconsole.error(\\\"Error disposing RooIgnoreController:\\\", error)\\n1039 | \\t\\t\\t// This is the critical one for the leak fix\\n1040 | \\t\\t}\\n1041 | \\n1042 | \\t\\ttry {\\n1043 | \\t\\t\\tthis.fileContextTracker.dispose()\\n1044 | \\t\\t} catch (error) {\\n1045 | \\t\\t\\tconsole.error(\\\"Error disposing file context tracker:\\\", error)\\n1046 | \\t\\t}\\n1047 | \\n1048 | \\t\\ttry {\\n1049 | \\t\\t\\t// If we're not streaming then `abortStream` won't be called\\n1050 | \\t\\t\\tif (this.isStreaming && this.diffViewProvider.isEditing) {\\n1051 | \\t\\t\\t\\tthis.diffViewProvider.revertChanges().catch(console.error)\\n1052 | \\t\\t\\t}\\n1053 | \\t\\t} catch (error) {\\n1054 | \\t\\t\\tconsole.error(\\\"Error reverting diff changes:\\\", error)\\n1055 | \\t\\t}\\n1056 | \\t}\\n1057 | \\n1058 | \\tpublic async abortTask(isAbandoned = false) {\\n1059 | \\t\\tconsole.log(`[subtasks] aborting task ${this.taskId}.${this.instanceId}`)\\n1060 | \\n1061 | \\t\\t// Will stop any autonomously running promises.\\n1062 | \\t\\tif (isAbandoned) {\\n1063 | \\t\\t\\tthis.abandoned = true\\n1064 | \\t\\t}\\n1065 | \\n1066 | \\t\\tthis.abort = true\\n1067 | \\t\\tthis.emit(\\\"taskAborted\\\")\\n1068 | \\n1069 | \\t\\ttry {\\n1070 | \\t\\t\\tthis.dispose() // Call the centralized dispose method\\n1071 | \\t\\t} catch (error) {\\n1072 | \\t\\t\\tconsole.error(`Error during task ${this.taskId}.${this.instanceId} disposal:`, error)\\n1073 | \\t\\t\\t// Don't rethrow - we want abort to always succeed\\n1074 | \\t\\t}\\n1075 | \\t\\t// Save the countdown message in the automatic retry or other content.\\n1076 | \\t\\ttry {\\n1077 | \\t\\t\\t// Save the countdown message in the automatic retry or other content.\\n1078 | \\t\\t\\tawait this.saveClineMessages()\\n1079 | \\t\\t} catch (error) {\\n1080 | \\t\\t\\tconsole.error(`Error saving messages during abort for task ${this.taskId}.${this.instanceId}:`, error)\\n1081 | \\t\\t}\\n1082 | \\t}\\n1083 | \\n1084 | \\t// Used when a sub-task is launched and the parent task is waiting for it to\\n1085 | \\t// finish.\\n1086 | \\t// TBD: The 1s should be added to the settings, also should add a timeout to\\n1087 | \\t// prevent infinite waiting.\\n1088 | \\tpublic async waitForResume() {\\n1089 | \\t\\tawait new Promise<void>((resolve) => {\\n1090 | \\t\\t\\tthis.pauseInterval = setInterval(() => {\\n1091 | \\t\\t\\t\\tif (!this.isPaused) {\\n1092 | \\t\\t\\t\\t\\tclearInterval(this.pauseInterval)\\n1093 | \\t\\t\\t\\t\\tthis.pauseInterval = undefined\\n1094 | \\t\\t\\t\\t\\tresolve()\\n1095 | \\t\\t\\t\\t}\\n1096 | \\t\\t\\t}, 1000)\\n1097 | \\t\\t})\\n1098 | \\t}\\n1099 | \\n1100 | \\t// Task Loop\\n1101 | \\n1102 | \\tprivate async initiateTaskLoop(userContent: Anthropic.Messages.ContentBlockParam[]): Promise<void> {\\n1103 | \\t\\t// Kicks off the checkpoints initialization process in the background.\\n1104 | \\t\\tgetCheckpointService(this)\\n1105 | \\n1106 | \\t\\tlet nextUserContent = userContent\\n1107 | \\t\\tlet includeFileDetails = true\\n1108 | \\n1109 | \\t\\tthis.emit(\\\"taskStarted\\\")\\n1110 | \\n1111 | \\t\\twhile (!this.abort) {\\n1112 | \\t\\t\\tconst didEndLoop = await this.recursivelyMakeClineRequests(nextUserContent, includeFileDetails)\\n1113 | \\t\\t\\tincludeFileDetails = false // we only need file details the first time\\n1114 | \\n1115 | \\t\\t\\t// The way this agentic loop works is that cline will be given a\\n1116 | \\t\\t\\t// task that he then calls tools to complete. Unless there's an\\n1117 | \\t\\t\\t// attempt_completion call, we keep responding back to him with his\\n1118 | \\t\\t\\t// tool's responses until he either attempt_completion or does not\\n1119 | \\t\\t\\t// use anymore tools. If he does not use anymore tools, we ask him\\n1120 | \\t\\t\\t// to consider if he's completed the task and then call\\n1121 | \\t\\t\\t// attempt_completion, otherwise proceed with completing the task.\\n1122 | \\t\\t\\t// There is a MAX_REQUESTS_PER_TASK limit to prevent infinite\\n1123 | \\t\\t\\t// requests, but Cline is prompted to finish the task as efficiently\\n1124 | \\t\\t\\t// as he can.\\n1125 | \\n1126 | \\t\\t\\tif (didEndLoop) {\\n1127 | \\t\\t\\t\\t// For now a task never 'completes'. This will only happen if\\n1128 | \\t\\t\\t\\t// the user hits max requests and denies resetting the count.\\n1129 | \\t\\t\\t\\tbreak\\n1130 | \\t\\t\\t} else {\\n1131 | \\t\\t\\t\\tnextUserContent = [{ type: \\\"text\\\", text: formatResponse.noToolsUsed() }]\\n1132 | \\t\\t\\t\\tthis.consecutiveMistakeCount++\\n1133 | \\t\\t\\t}\\n1134 | \\t\\t}\\n1135 | \\t}\\n1136 | \\n1137 | \\tpublic async recursivelyMakeClineRequests(\\n1138 | \\t\\tuserContent: Anthropic.Messages.ContentBlockParam[],\\n1139 | \\t\\tincludeFileDetails: boolean = false,\\n1140 | \\t): Promise<boolean> {\\n1141 | \\t\\tif (this.abort) {\\n1142 | \\t\\t\\tthrow new Error(`[RooCode#recursivelyMakeRooRequests] task ${this.taskId}.${this.instanceId} aborted`)\\n1143 | \\t\\t}\\n1144 | \\n1145 | \\t\\tif (this.consecutiveMistakeCount >= this.consecutiveMistakeLimit) {\\n1146 | \\t\\t\\tconst { response, text, images } = await this.ask(\\n1147 | \\t\\t\\t\\t\\\"mistake_limit_reached\\\",\\n1148 | \\t\\t\\t\\tt(\\\"common:errors.mistake_limit_guidance\\\"),\\n1149 | \\t\\t\\t)\\n1150 | \\n1151 | \\t\\t\\tif (response === \\\"messageResponse\\\") {\\n1152 | \\t\\t\\t\\tuserContent.push(\\n1153 | \\t\\t\\t\\t\\t...[\\n1154 | \\t\\t\\t\\t\\t\\t{ type: \\\"text\\\" as const, text: formatResponse.tooManyMistakes(text) },\\n1155 | \\t\\t\\t\\t\\t\\t...formatResponse.imageBlocks(images),\\n1156 | \\t\\t\\t\\t\\t],\\n1157 | \\t\\t\\t\\t)\\n1158 | \\n1159 | \\t\\t\\t\\tawait this.say(\\\"user_feedback\\\", text, images)\\n1160 | \\n1161 | \\t\\t\\t\\t// Track consecutive mistake errors in telemetry.\\n1162 | \\t\\t\\t\\tTelemetryService.instance.captureConsecutiveMistakeError(this.taskId)\\n1163 | \\t\\t\\t}\\n1164 | \\n1165 | \\t\\t\\tthis.consecutiveMistakeCount = 0\\n1166 | \\t\\t}\\n1167 | \\n1168 | \\t\\t// In this Cline request loop, we need to check if this task instance\\n1169 | \\t\\t// has been asked to wait for a subtask to finish before continuing.\\n1170 | \\t\\tconst provider = this.providerRef.deref()\\n1171 | \\n1172 | \\t\\tif (this.isPaused && provider) {\\n1173 | \\t\\t\\tprovider.log(`[subtasks] paused ${this.taskId}.${this.instanceId}`)\\n1174 | \\t\\t\\tawait this.waitForResume()\\n1175 | \\t\\t\\tprovider.log(`[subtasks] resumed ${this.taskId}.${this.instanceId}`)\\n1176 | \\t\\t\\tconst currentMode = (await provider.getState())?.mode ?? defaultModeSlug\\n1177 | \\n1178 | \\t\\t\\tif (currentMode !== this.pausedModeSlug) {\\n1179 | \\t\\t\\t\\t// The mode has changed, we need to switch back to the paused mode.\\n1180 | \\t\\t\\t\\tawait provider.handleModeSwitch(this.pausedModeSlug)\\n1181 | \\n1182 | \\t\\t\\t\\t// Delay to allow mode change to take effect before next tool is executed.\\n1183 | \\t\\t\\t\\tawait delay(500)\\n1184 | \\n1185 | \\t\\t\\t\\tprovider.log(\\n1186 | \\t\\t\\t\\t\\t`[subtasks] task ${this.taskId}.${this.instanceId} has switched back to '${this.pausedModeSlug}' from '${currentMode}'`,\\n1187 | \\t\\t\\t\\t)\\n1188 | \\t\\t\\t}\\n1189 | \\t\\t}\\n1190 | \\n1191 | \\t\\t// Getting verbose details is an expensive operation, it uses ripgrep to\\n1192 | \\t\\t// top-down build file structure of project which for large projects can\\n1193 | \\t\\t// take a few seconds. For the best UX we show a placeholder api_req_started\\n1194 | \\t\\t// message with a loading spinner as this happens.\\n1195 | \\t\\tawait this.say(\\n1196 | \\t\\t\\t\\\"api_req_started\\\",\\n1197 | \\t\\t\\tJSON.stringify({\\n1198 | \\t\\t\\t\\trequest:\\n1199 | \\t\\t\\t\\t\\tuserContent.map((block) => formatContentBlockToMarkdown(block)).join(\\\"\\\\n\\\\n\\\") + \\\"\\\\n\\\\nLoading...\\\",\\n1200 | \\t\\t\\t}),\\n1201 | \\t\\t)\\n1202 | \\n1203 | \\t\\tconst { showRooIgnoredFiles = true } = (await this.providerRef.deref()?.getState()) ?? {}\\n1204 | \\n1205 | \\t\\tconst parsedUserContent = await processUserContentMentions({\\n1206 | \\t\\t\\tuserContent,\\n1207 | \\t\\t\\tcwd: this.cwd,\\n1208 | \\t\\t\\turlContentFetcher: this.urlContentFetcher,\\n1209 | \\t\\t\\tfileContextTracker: this.fileContextTracker,\\n1210 | \\t\\t\\trooIgnoreController: this.rooIgnoreController,\\n1211 | \\t\\t\\tshowRooIgnoredFiles,\\n1212 | \\t\\t})\\n1213 | \\n1214 | \\t\\tconst environmentDetails = await getEnvironmentDetails(this, includeFileDetails)\\n1215 | \\n1216 | \\t\\t// Add environment details as its own text block, separate from tool\\n1217 | \\t\\t// results.\\n1218 | \\t\\tconst finalUserContent = [...parsedUserContent, { type: \\\"text\\\" as const, text: environmentDetails }]\\n1219 | \\n1220 | \\t\\tawait this.addToApiConversationHistory({ role: \\\"user\\\", content: finalUserContent })\\n1221 | \\t\\tTelemetryService.instance.captureConversationMessage(this.taskId, \\\"user\\\")\\n1222 | \\n1223 | \\t\\t// Since we sent off a placeholder api_req_started message to update the\\n1224 | \\t\\t// webview while waiting to actually start the API request (to load\\n1225 | \\t\\t// potential details for example), we need to update the text of that\\n1226 | \\t\\t// message.\\n1227 | \\t\\tconst lastApiReqIndex = findLastIndex(this.clineMessages, (m) => m.say === \\\"api_req_started\\\")\\n1228 | \\n1229 | \\t\\tthis.clineMessages[lastApiReqIndex].text = JSON.stringify({\\n1230 | \\t\\t\\trequest: finalUserContent.map((block) => formatContentBlockToMarkdown(block)).join(\\\"\\\\n\\\\n\\\"),\\n1231 | \\t\\t} satisfies ClineApiReqInfo)\\n1232 | \\n1233 | \\t\\tawait this.saveClineMessages()\\n1234 | \\t\\tawait provider?.postStateToWebview()\\n1235 | \\n1236 | \\t\\ttry {\\n1237 | \\t\\t\\tlet cacheWriteTokens = 0\\n1238 | \\t\\t\\tlet cacheReadTokens = 0\\n1239 | \\t\\t\\tlet inputTokens = 0\\n1240 | \\t\\t\\tlet outputTokens = 0\\n1241 | \\t\\t\\tlet totalCost: number | undefined\\n1242 | \\n1243 | \\t\\t\\t// We can't use `api_req_finished` anymore since it's a unique case\\n1244 | \\t\\t\\t// where it could come after a streaming message (i.e. in the middle\\n1245 | \\t\\t\\t// of being updated or executed).\\n1246 | \\t\\t\\t// Fortunately `api_req_finished` was always parsed out for the GUI\\n1247 | \\t\\t\\t// anyways, so it remains solely for legacy purposes to keep track\\n1248 | \\t\\t\\t// of prices in tasks from history (it's worth removing a few months\\n1249 | \\t\\t\\t// from now).\\n1250 | \\t\\t\\tconst updateApiReqMsg = (cancelReason?: ClineApiReqCancelReason, streamingFailedMessage?: string) => {\\n1251 | \\t\\t\\t\\tthis.clineMessages[lastApiReqIndex].text = JSON.stringify({\\n1252 | \\t\\t\\t\\t\\t...JSON.parse(this.clineMessages[lastApiReqIndex].text || \\\"{}\\\"),\\n1253 | \\t\\t\\t\\t\\ttokensIn: inputTokens,\\n1254 | \\t\\t\\t\\t\\ttokensOut: outputTokens,\\n1255 | \\t\\t\\t\\t\\tcacheWrites: cacheWriteTokens,\\n1256 | \\t\\t\\t\\t\\tcacheReads: cacheReadTokens,\\n1257 | \\t\\t\\t\\t\\tcost:\\n1258 | \\t\\t\\t\\t\\t\\ttotalCost ??\\n1259 | \\t\\t\\t\\t\\t\\tcalculateApiCostAnthropic(\\n1260 | \\t\\t\\t\\t\\t\\t\\tthis.api.getModel().info,\\n1261 | \\t\\t\\t\\t\\t\\t\\tinputTokens,\\n1262 | \\t\\t\\t\\t\\t\\t\\toutputTokens,\\n1263 | \\t\\t\\t\\t\\t\\t\\tcacheWriteTokens,\\n1264 | \\t\\t\\t\\t\\t\\t\\tcacheReadTokens,\\n1265 | \\t\\t\\t\\t\\t\\t),\\n1266 | \\t\\t\\t\\t\\tcancelReason,\\n1267 | \\t\\t\\t\\t\\tstreamingFailedMessage,\\n1268 | \\t\\t\\t\\t} satisfies ClineApiReqInfo)\\n1269 | \\t\\t\\t}\\n1270 | \\n1271 | \\t\\t\\tconst abortStream = async (cancelReason: ClineApiReqCancelReason, streamingFailedMessage?: string) => {\\n1272 | \\t\\t\\t\\tif (this.diffViewProvider.isEditing) {\\n1273 | \\t\\t\\t\\t\\tawait this.diffViewProvider.revertChanges() // closes diff view\\n1274 | \\t\\t\\t\\t}\\n1275 | \\n1276 | \\t\\t\\t\\t// if last message is a partial we need to update and save it\\n1277 | \\t\\t\\t\\tconst lastMessage = this.clineMessages.at(-1)\\n1278 | \\n1279 | \\t\\t\\t\\tif (lastMessage && lastMessage.partial) {\\n1280 | \\t\\t\\t\\t\\t// lastMessage.ts = Date.now() DO NOT update ts since it is used as a key for virtuoso list\\n1281 | \\t\\t\\t\\t\\tlastMessage.partial = false\\n1282 | \\t\\t\\t\\t\\t// instead of streaming partialMessage events, we do a save and post like normal to persist to disk\\n1283 | \\t\\t\\t\\t\\tconsole.log(\\\"updating partial message\\\", lastMessage)\\n1284 | \\t\\t\\t\\t\\t// await this.saveClineMessages()\\n1285 | \\t\\t\\t\\t}\\n1286 | \\n1287 | \\t\\t\\t\\t// Let assistant know their response was interrupted for when task is resumed\\n1288 | \\t\\t\\t\\tawait this.addToApiConversationHistory({\\n1289 | \\t\\t\\t\\t\\trole: \\\"assistant\\\",\\n1290 | \\t\\t\\t\\t\\tcontent: [\\n1291 | \\t\\t\\t\\t\\t\\t{\\n1292 | \\t\\t\\t\\t\\t\\t\\ttype: \\\"text\\\",\\n1293 | \\t\\t\\t\\t\\t\\t\\ttext:\\n1294 | \\t\\t\\t\\t\\t\\t\\t\\tassistantMessage +\\n1295 | \\t\\t\\t\\t\\t\\t\\t\\t`\\\\n\\\\n[${\\n1296 | \\t\\t\\t\\t\\t\\t\\t\\t\\tcancelReason === \\\"streaming_failed\\\"\\n1297 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t? \\\"Response interrupted by API Error\\\"\\n1298 | \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t: \\\"Response interrupted by user\\\"\\n1299 | \\t\\t\\t\\t\\t\\t\\t\\t}]`,\\n1300 | \\t\\t\\t\\t\\t\\t},\\n1301 | \\t\\t\\t\\t\\t],\\n1302 | \\t\\t\\t\\t})\\n1303 | \\n1304 | \\t\\t\\t\\t// Update `api_req_started` to have cancelled and cost, so that\\n1305 | \\t\\t\\t\\t// we can display the cost of the partial stream.\\n1306 | \\t\\t\\t\\tupdateApiReqMsg(cancelReason, streamingFailedMessage)\\n1307 | \\t\\t\\t\\tawait this.saveClineMessages()\\n1308 | \\n1309 | \\t\\t\\t\\t// Signals to provider that it can retrieve the saved messages\\n1310 | \\t\\t\\t\\t// from disk, as abortTask can not be awaited on in nature.\\n1311 | \\t\\t\\t\\tthis.didFinishAbortingStream = true\\n1312 | \\t\\t\\t}\\n1313 | \\n1314 | \\t\\t\\t// Reset streaming state.\\n1315 | \\t\\t\\tthis.currentStreamingContentIndex = 0\\n1316 | \\t\\t\\tthis.assistantMessageContent = []\\n1317 | \\t\\t\\tthis.didCompleteReadingStream = false\\n1318 | \\t\\t\\tthis.userMessageContent = []\\n1319 | \\t\\t\\tthis.userMessageContentReady = false\\n1320 | \\t\\t\\tthis.didRejectTool = false\\n1321 | \\t\\t\\tthis.didAlreadyUseTool = false\\n1322 | \\t\\t\\tthis.presentAssistantMessageLocked = false\\n1323 | \\t\\t\\tthis.presentAssistantMessageHasPendingUpdates = false\\n1324 | \\n1325 | \\t\\t\\tawait this.diffViewProvider.reset()\\n1326 | \\n1327 | \\t\\t\\t// Yields only if the first chunk is successful, otherwise will\\n1328 | \\t\\t\\t// allow the user to retry the request (most likely due to rate\\n1329 | \\t\\t\\t// limit error, which gets thrown on the first chunk).\\n1330 | \\t\\t\\tconst stream = this.attemptApiRequest()\\n1331 | \\t\\t\\tlet assistantMessage = \\\"\\\"\\n1332 | \\t\\t\\tlet reasoningMessage = \\\"\\\"\\n1333 | \\t\\t\\tthis.isStreaming = true\\n1334 | \\n1335 | \\t\\t\\ttry {\\n1336 | \\t\\t\\t\\tfor await (const chunk of stream) {\\n1337 | \\t\\t\\t\\t\\tif (!chunk) {\\n1338 | \\t\\t\\t\\t\\t\\t// Sometimes chunk is undefined, no idea that can cause\\n1339 | \\t\\t\\t\\t\\t\\t// it, but this workaround seems to fix it.\\n1340 | \\t\\t\\t\\t\\t\\tcontinue\\n1341 | \\t\\t\\t\\t\\t}\\n1342 | \\n1343 | \\t\\t\\t\\t\\tswitch (chunk.type) {\\n1344 | \\t\\t\\t\\t\\t\\tcase \\\"reasoning\\\":\\n1345 | \\t\\t\\t\\t\\t\\t\\treasoningMessage += chunk.text\\n1346 | \\t\\t\\t\\t\\t\\t\\tawait this.say(\\\"reasoning\\\", reasoningMessage, undefined, true)\\n1347 | \\t\\t\\t\\t\\t\\t\\tbreak\\n1348 | \\t\\t\\t\\t\\t\\tcase \\\"usage\\\":\\n1349 | \\t\\t\\t\\t\\t\\t\\tinputTokens += chunk.inputTokens\\n1350 | \\t\\t\\t\\t\\t\\t\\toutputTokens += chunk.outputTokens\\n1351 | \\t\\t\\t\\t\\t\\t\\tcacheWriteTokens += chunk.cacheWriteTokens ?? 0\\n1352 | \\t\\t\\t\\t\\t\\t\\tcacheReadTokens += chunk.cacheReadTokens ?? 0\\n1353 | \\t\\t\\t\\t\\t\\t\\ttotalCost = chunk.totalCost\\n1354 | \\t\\t\\t\\t\\t\\t\\tbreak\\n1355 | \\t\\t\\t\\t\\t\\tcase \\\"text\\\": {\\n1356 | \\t\\t\\t\\t\\t\\t\\tassistantMessage += chunk.text\\n1357 | \\n1358 | \\t\\t\\t\\t\\t\\t\\t// Parse raw assistant message into content blocks.\\n1359 | \\t\\t\\t\\t\\t\\t\\tconst prevLength = this.assistantMessageContent.length\\n1360 | \\t\\t\\t\\t\\t\\t\\tthis.assistantMessageContent = parseAssistantMessage(assistantMessage)\\n1361 | \\n1362 | \\t\\t\\t\\t\\t\\t\\tif (this.assistantMessageContent.length > prevLength) {\\n1363 | \\t\\t\\t\\t\\t\\t\\t\\t// New content we need to present, reset to\\n1364 | \\t\\t\\t\\t\\t\\t\\t\\t// false in case previous content set this to true.\\n1365 | \\t\\t\\t\\t\\t\\t\\t\\tthis.userMessageContentReady = false\\n1366 | \\t\\t\\t\\t\\t\\t\\t}\\n1367 | \\n1368 | \\t\\t\\t\\t\\t\\t\\t// Present content to user.\\n1369 | \\t\\t\\t\\t\\t\\t\\tpresentAssistantMessage(this)\\n1370 | \\t\\t\\t\\t\\t\\t\\tbreak\\n1371 | \\t\\t\\t\\t\\t\\t}\\n1372 | \\t\\t\\t\\t\\t}\\n1373 | \\n1374 | \\t\\t\\t\\t\\tif (this.abort) {\\n1375 | \\t\\t\\t\\t\\t\\tconsole.log(`aborting stream, this.abandoned = ${this.abandoned}`)\\n1376 | \\n1377 | \\t\\t\\t\\t\\t\\tif (!this.abandoned) {\\n1378 | \\t\\t\\t\\t\\t\\t\\t// Only need to gracefully abort if this instance\\n1379 | \\t\\t\\t\\t\\t\\t\\t// isn't abandoned (sometimes OpenRouter stream\\n1380 | \\t\\t\\t\\t\\t\\t\\t// hangs, in which case this would affect future\\n1381 | \\t\\t\\t\\t\\t\\t\\t// instances of Cline).\\n1382 | \\t\\t\\t\\t\\t\\t\\tawait abortStream(\\\"user_cancelled\\\")\\n1383 | \\t\\t\\t\\t\\t\\t}\\n1384 | \\n1385 | \\t\\t\\t\\t\\t\\tbreak // Aborts the stream.\\n1386 | \\t\\t\\t\\t\\t}\\n1387 | \\n1388 | \\t\\t\\t\\t\\tif (this.didRejectTool) {\\n1389 | \\t\\t\\t\\t\\t\\t// `userContent` has a tool rejection, so interrupt the\\n1390 | \\t\\t\\t\\t\\t\\t// assistant's response to present the user's feedback.\\n1391 | \\t\\t\\t\\t\\t\\tassistantMessage += \\\"\\\\n\\\\n[Response interrupted by user feedback]\\\"\\n1392 | \\t\\t\\t\\t\\t\\t// Instead of setting this preemptively, we allow the\\n1393 | \\t\\t\\t\\t\\t\\t// present iterator to finish and set\\n1394 | \\t\\t\\t\\t\\t\\t// userMessageContentReady when its ready.\\n1395 | \\t\\t\\t\\t\\t\\t// this.userMessageContentReady = true\\n1396 | \\t\\t\\t\\t\\t\\tbreak\\n1397 | \\t\\t\\t\\t\\t}\\n1398 | \\n1399 | \\t\\t\\t\\t\\t// PREV: We need to let the request finish for openrouter to\\n1400 | \\t\\t\\t\\t\\t// get generation details.\\n1401 | \\t\\t\\t\\t\\t// UPDATE: It's better UX to interrupt the request at the\\n1402 | \\t\\t\\t\\t\\t// cost of the API cost not being retrieved.\\n1403 | \\t\\t\\t\\t\\tif (this.didAlreadyUseTool) {\\n1404 | \\t\\t\\t\\t\\t\\tassistantMessage +=\\n1405 | \\t\\t\\t\\t\\t\\t\\t\\\"\\\\n\\\\n[Response interrupted by a tool use result. Only one tool may be used at a time and should be placed at the end of the message.]\\\"\\n1406 | \\t\\t\\t\\t\\t\\tbreak\\n1407 | \\t\\t\\t\\t\\t}\\n1408 | \\t\\t\\t\\t}\\n1409 | \\t\\t\\t} catch (error) {\\n1410 | \\t\\t\\t\\t// Abandoned happens when extension is no longer waiting for the\\n1411 | \\t\\t\\t\\t// Cline instance to finish aborting (error is thrown here when\\n1412 | \\t\\t\\t\\t// any function in the for loop throws due to this.abort).\\n1413 | \\t\\t\\t\\tif (!this.abandoned) {\\n1414 | \\t\\t\\t\\t\\t// If the stream failed, there's various states the task\\n1415 | \\t\\t\\t\\t\\t// could be in (i.e. could have streamed some tools the user\\n1416 | \\t\\t\\t\\t\\t// may have executed), so we just resort to replicating a\\n1417 | \\t\\t\\t\\t\\t// cancel task.\\n1418 | \\t\\t\\t\\t\\tthis.abortTask()\\n1419 | \\n1420 | \\t\\t\\t\\t\\tawait abortStream(\\n1421 | \\t\\t\\t\\t\\t\\t\\\"streaming_failed\\\",\\n1422 | \\t\\t\\t\\t\\t\\terror.message ?? JSON.stringify(serializeError(error), null, 2),\\n1423 | \\t\\t\\t\\t\\t)\\n1424 | \\n1425 | \\t\\t\\t\\t\\tconst history = await provider?.getTaskWithId(this.taskId)\\n1426 | \\n1427 | \\t\\t\\t\\t\\tif (history) {\\n1428 | \\t\\t\\t\\t\\t\\tawait provider?.initClineWithHistoryItem(history.historyItem)\\n1429 | \\t\\t\\t\\t\\t}\\n1430 | \\t\\t\\t\\t}\\n1431 | \\t\\t\\t} finally {\\n1432 | \\t\\t\\t\\tthis.isStreaming = false\\n1433 | \\t\\t\\t}\\n1434 | \\t\\t\\tif (\\n1435 | \\t\\t\\t\\tinputTokens > 0 ||\\n1436 | \\t\\t\\t\\toutputTokens > 0 ||\\n1437 | \\t\\t\\t\\tcacheWriteTokens > 0 ||\\n1438 | \\t\\t\\t\\tcacheReadTokens > 0 ||\\n1439 | \\t\\t\\t\\ttypeof totalCost !== \\\"undefined\\\"\\n1440 | \\t\\t\\t) {\\n1441 | \\t\\t\\t\\tTelemetryService.instance.captureLlmCompletion(this.taskId, {\\n1442 | \\t\\t\\t\\t\\tinputTokens,\\n1443 | \\t\\t\\t\\t\\toutputTokens,\\n1444 | \\t\\t\\t\\t\\tcacheWriteTokens,\\n1445 | \\t\\t\\t\\t\\tcacheReadTokens,\\n1446 | \\t\\t\\t\\t\\tcost: totalCost,\\n1447 | \\t\\t\\t\\t})\\n1448 | \\t\\t\\t}\\n1449 | \\n1450 | \\t\\t\\t// Need to call here in case the stream was aborted.\\n1451 | \\t\\t\\tif (this.abort || this.abandoned) {\\n1452 | \\t\\t\\t\\tthrow new Error(`[RooCode#recursivelyMakeRooRequests] task ${this.taskId}.${this.instanceId} aborted`)\\n1453 | \\t\\t\\t}\\n1454 | \\n1455 | \\t\\t\\tthis.didCompleteReadingStream = true\\n1456 | \\n1457 | \\t\\t\\t// Set any blocks to be complete to allow `presentAssistantMessage`\\n1458 | \\t\\t\\t// to finish and set `userMessageContentReady` to true.\\n1459 | \\t\\t\\t// (Could be a text block that had no subsequent tool uses, or a\\n1460 | \\t\\t\\t// text block at the very end, or an invalid tool use, etc. Whatever\\n1461 | \\t\\t\\t// the case, `presentAssistantMessage` relies on these blocks either\\n1462 | \\t\\t\\t// to be completed or the user to reject a block in order to proceed\\n1463 | \\t\\t\\t// and eventually set userMessageContentReady to true.)\\n1464 | \\t\\t\\tconst partialBlocks = this.assistantMessageContent.filter((block) => block.partial)\\n1465 | \\t\\t\\tpartialBlocks.forEach((block) => (block.partial = false))\\n1466 | \\n1467 | \\t\\t\\t// Can't just do this b/c a tool could be in the middle of executing.\\n1468 | \\t\\t\\t// this.assistantMessageContent.forEach((e) => (e.partial = false))\\n1469 | \\n1470 | \\t\\t\\tif (partialBlocks.length > 0) {\\n1471 | \\t\\t\\t\\t// If there is content to update then it will complete and\\n1472 | \\t\\t\\t\\t// update `this.userMessageContentReady` to true, which we\\n1473 | \\t\\t\\t\\t// `pWaitFor` before making the next request. All this is really\\n1474 | \\t\\t\\t\\t// doing is presenting the last partial message that we just set\\n1475 | \\t\\t\\t\\t// to complete.\\n1476 | \\t\\t\\t\\tpresentAssistantMessage(this)\\n1477 | \\t\\t\\t}\\n1478 | \\n1479 | \\t\\t\\tupdateApiReqMsg()\\n1480 | \\t\\t\\tawait this.saveClineMessages()\\n1481 | \\t\\t\\tawait this.providerRef.deref()?.postStateToWebview()\\n1482 | \\n1483 | \\t\\t\\t// Now add to apiConversationHistory.\\n1484 | \\t\\t\\t// Need to save assistant responses to file before proceeding to\\n1485 | \\t\\t\\t// tool use since user can exit at any moment and we wouldn't be\\n1486 | \\t\\t\\t// able to save the assistant's response.\\n1487 | \\t\\t\\tlet didEndLoop = false\\n1488 | \\n1489 | \\t\\t\\tif (assistantMessage.length > 0) {\\n1490 | \\t\\t\\t\\tawait this.addToApiConversationHistory({\\n1491 | \\t\\t\\t\\t\\trole: \\\"assistant\\\",\\n1492 | \\t\\t\\t\\t\\tcontent: [{ type: \\\"text\\\", text: assistantMessage }],\\n1493 | \\t\\t\\t\\t})\\n1494 | \\n1495 | \\t\\t\\t\\tTelemetryService.instance.captureConversationMessage(this.taskId, \\\"assistant\\\")\\n1496 | \\n1497 | \\t\\t\\t\\t// NOTE: This comment is here for future reference - this was a\\n1498 | \\t\\t\\t\\t// workaround for `userMessageContent` not getting set to true.\\n1499 | \\t\\t\\t\\t// It was due to it not recursively calling for partial blocks\\n1500 | \\t\\t\\t\\t// when `didRejectTool`, so it would get stuck waiting for a\\n1501 | \\t\\t\\t\\t// partial block to complete before it could continue.\\n1502 | \\t\\t\\t\\t// In case the content blocks finished it may be the api stream\\n1503 | \\t\\t\\t\\t// finished after the last parsed content block was executed, so\\n1504 | \\t\\t\\t\\t// we are able to detect out of bounds and set\\n1505 | \\t\\t\\t\\t// `userMessageContentReady` to true (note you should not call\\n1506 | \\t\\t\\t\\t// `presentAssistantMessage` since if the last block i\\n1507 | \\t\\t\\t\\t//  completed it will be presented again).\\n1508 | \\t\\t\\t\\t// const completeBlocks = this.assistantMessageContent.filter((block) => !block.partial) // If there are any partial blocks after the stream ended we can consider them invalid.\\n1509 | \\t\\t\\t\\t// if (this.currentStreamingContentIndex >= completeBlocks.length) {\\n1510 | \\t\\t\\t\\t// \\tthis.userMessageContentReady = true\\n1511 | \\t\\t\\t\\t// }\\n1512 | \\n1513 | \\t\\t\\t\\tawait pWaitFor(() => this.userMessageContentReady)\\n1514 | \\n1515 | \\t\\t\\t\\t// If the model did not tool use, then we need to tell it to\\n1516 | \\t\\t\\t\\t// either use a tool or attempt_completion.\\n1517 | \\t\\t\\t\\tconst didToolUse = this.assistantMessageContent.some((block) => block.type === \\\"tool_use\\\")\\n1518 | \\n1519 | \\t\\t\\t\\tif (!didToolUse) {\\n1520 | \\t\\t\\t\\t\\tthis.userMessageContent.push({ type: \\\"text\\\", text: formatResponse.noToolsUsed() })\\n1521 | \\t\\t\\t\\t\\tthis.consecutiveMistakeCount++\\n1522 | \\t\\t\\t\\t}\\n1523 | \\n1524 | \\t\\t\\t\\tconst recDidEndLoop = await this.recursivelyMakeClineRequests(this.userMessageContent)\\n1525 | \\t\\t\\t\\tdidEndLoop = recDidEndLoop\\n1526 | \\t\\t\\t} else {\\n1527 | \\t\\t\\t\\t// If there's no assistant_responses, that means we got no text\\n1528 | \\t\\t\\t\\t// or tool_use content blocks from API which we should assume is\\n1529 | \\t\\t\\t\\t// an error.\\n1530 | \\t\\t\\t\\tawait this.say(\\n1531 | \\t\\t\\t\\t\\t\\\"error\\\",\\n1532 | \\t\\t\\t\\t\\t\\\"Unexpected API Response: The language model did not provide any assistant messages. This may indicate an issue with the API or the model's output.\\\",\\n1533 | \\t\\t\\t\\t)\\n1534 | \\n1535 | \\t\\t\\t\\tawait this.addToApiConversationHistory({\\n1536 | \\t\\t\\t\\t\\trole: \\\"assistant\\\",\\n1537 | \\t\\t\\t\\t\\tcontent: [{ type: \\\"text\\\", text: \\\"Failure: I did not provide a response.\\\" }],\\n1538 | \\t\\t\\t\\t})\\n1539 | \\t\\t\\t}\\n1540 | \\n1541 | \\t\\t\\treturn didEndLoop // Will always be false for now.\\n1542 | \\t\\t} catch (error) {\\n1543 | \\t\\t\\t// This should never happen since the only thing that can throw an\\n1544 | \\t\\t\\t// error is the attemptApiRequest, which is wrapped in a try catch\\n1545 | \\t\\t\\t// that sends an ask where if noButtonClicked, will clear current\\n1546 | \\t\\t\\t// task and destroy this instance. However to avoid unhandled\\n1547 | \\t\\t\\t// promise rejection, we will end this loop which will end execution\\n1548 | \\t\\t\\t// of this instance (see `startTask`).\\n1549 | \\t\\t\\treturn true // Needs to be true so parent loop knows to end task.\\n1550 | \\t\\t}\\n1551 | \\t}\\n1552 | \\n1553 | \\tprivate async getSystemPrompt(): Promise<string> {\\n1554 | \\t\\tconst { mcpEnabled } = (await this.providerRef.deref()?.getState()) ?? {}\\n1555 | \\t\\tlet mcpHub: McpHub | undefined\\n1556 | \\t\\tif (mcpEnabled ?? true) {\\n1557 | \\t\\t\\tconst provider = this.providerRef.deref()\\n1558 | \\n1559 | \\t\\t\\tif (!provider) {\\n1560 | \\t\\t\\t\\tthrow new Error(\\\"Provider reference lost during view transition\\\")\\n1561 | \\t\\t\\t}\\n1562 | \\n1563 | \\t\\t\\t// Wait for MCP hub initialization through McpServerManager\\n1564 | \\t\\t\\tmcpHub = await McpServerManager.getInstance(provider.context, provider)\\n1565 | \\n1566 | \\t\\t\\tif (!mcpHub) {\\n1567 | \\t\\t\\t\\tthrow new Error(\\\"Failed to get MCP hub from server manager\\\")\\n1568 | \\t\\t\\t}\\n1569 | \\n1570 | \\t\\t\\t// Wait for MCP servers to be connected before generating system prompt\\n1571 | \\t\\t\\tawait pWaitFor(() => !mcpHub!.isConnecting, { timeout: 10_000 }).catch(() => {\\n1572 | \\t\\t\\t\\tconsole.error(\\\"MCP servers failed to connect in time\\\")\\n1573 | \\t\\t\\t})\\n1574 | \\t\\t}\\n1575 | \\n1576 | \\t\\tconst rooIgnoreInstructions = this.rooIgnoreController?.getInstructions()\\n1577 | \\n1578 | \\t\\tconst state = await this.providerRef.deref()?.getState()\\n1579 | \\n1580 | \\t\\tconst {\\n1581 | \\t\\t\\tbrowserViewportSize,\\n1582 | \\t\\t\\tmode,\\n1583 | \\t\\t\\tcustomModes,\\n1584 | \\t\\t\\tcustomModePrompts,\\n1585 | \\t\\t\\tcustomInstructions,\\n1586 | \\t\\t\\texperiments,\\n1587 | \\t\\t\\tenableMcpServerCreation,\\n1588 | \\t\\t\\tbrowserToolEnabled,\\n1589 | \\t\\t\\tlanguage,\\n1590 | \\t\\t\\tmaxConcurrentFileReads,\\n1591 | \\t\\t\\tmaxReadFileLine,\\n1592 | \\t\\t} = state ?? {}\\n1593 | \\n1594 | \\t\\treturn await (async () => {\\n1595 | \\t\\t\\tconst provider = this.providerRef.deref()\\n1596 | \\n1597 | \\t\\t\\tif (!provider) {\\n1598 | \\t\\t\\t\\tthrow new Error(\\\"Provider not available\\\")\\n1599 | \\t\\t\\t}\\n1600 | \\n1601 | \\t\\t\\treturn SYSTEM_PROMPT(\\n1602 | \\t\\t\\t\\tprovider.context,\\n1603 | \\t\\t\\t\\tthis.cwd,\\n1604 | \\t\\t\\t\\t(this.api.getModel().info.supportsComputerUse ?? false) && (browserToolEnabled ?? true),\\n1605 | \\t\\t\\t\\tmcpHub,\\n1606 | \\t\\t\\t\\tthis.diffStrategy,\\n1607 | \\t\\t\\t\\tbrowserViewportSize,\\n1608 | \\t\\t\\t\\tmode,\\n1609 | \\t\\t\\t\\tcustomModePrompts,\\n1610 | \\t\\t\\t\\tcustomModes,\\n1611 | \\t\\t\\t\\tcustomInstructions,\\n1612 | \\t\\t\\t\\tthis.diffEnabled,\\n1613 | \\t\\t\\t\\texperiments,\\n1614 | \\t\\t\\t\\tenableMcpServerCreation,\\n1615 | \\t\\t\\t\\tlanguage,\\n1616 | \\t\\t\\t\\trooIgnoreInstructions,\\n1617 | \\t\\t\\t\\tmaxReadFileLine !== -1,\\n1618 | \\t\\t\\t\\t{\\n1619 | \\t\\t\\t\\t\\tmaxConcurrentFileReads,\\n1620 | \\t\\t\\t\\t},\\n1621 | \\t\\t\\t)\\n1622 | \\t\\t})()\\n1623 | \\t}\\n1624 | \\n1625 | \\tpublic async *attemptApiRequest(retryAttempt: number = 0): ApiStream {\\n1626 | \\t\\tconst state = await this.providerRef.deref()?.getState()\\n1627 | \\t\\tconst {\\n1628 | \\t\\t\\tapiConfiguration,\\n1629 | \\t\\t\\tautoApprovalEnabled,\\n1630 | \\t\\t\\talwaysApproveResubmit,\\n1631 | \\t\\t\\trequestDelaySeconds,\\n1632 | \\t\\t\\tmode,\\n1633 | \\t\\t\\tautoCondenseContext = true,\\n1634 | \\t\\t\\tautoCondenseContextPercent = 100,\\n1635 | \\t\\t} = state ?? {}\\n1636 | \\n1637 | \\t\\t// Get condensing configuration for automatic triggers\\n1638 | \\t\\tconst customCondensingPrompt = state?.customCondensingPrompt\\n1639 | \\t\\tconst condensingApiConfigId = state?.condensingApiConfigId\\n1640 | \\t\\tconst listApiConfigMeta = state?.listApiConfigMeta\\n1641 | \\n1642 | \\t\\t// Determine API handler to use for condensing\\n1643 | \\t\\tlet condensingApiHandler: ApiHandler | undefined\\n1644 | \\t\\tif (condensingApiConfigId && listApiConfigMeta && Array.isArray(listApiConfigMeta)) {\\n1645 | \\t\\t\\t// Using type assertion for the id property to avoid implicit any\\n1646 | \\t\\t\\tconst matchingConfig = listApiConfigMeta.find((config: any) => config.id === condensingApiConfigId)\\n1647 | \\t\\t\\tif (matchingConfig) {\\n1648 | \\t\\t\\t\\tconst profile = await this.providerRef.deref()?.providerSettingsManager.getProfile({\\n1649 | \\t\\t\\t\\t\\tid: condensingApiConfigId,\\n1650 | \\t\\t\\t\\t})\\n1651 | \\t\\t\\t\\t// Ensure profile and apiProvider exist before trying to build handler\\n1652 | \\t\\t\\t\\tif (profile && profile.apiProvider) {\\n1653 | \\t\\t\\t\\t\\tcondensingApiHandler = buildApiHandler(profile)\\n1654 | \\t\\t\\t\\t}\\n1655 | \\t\\t\\t}\\n1656 | \\t\\t}\\n1657 | \\n1658 | \\t\\tlet rateLimitDelay = 0\\n1659 | \\n1660 | \\t\\t// Only apply rate limiting if this isn't the first request\\n1661 | \\t\\tif (this.lastApiRequestTime) {\\n1662 | \\t\\t\\tconst now = Date.now()\\n1663 | \\t\\t\\tconst timeSinceLastRequest = now - this.lastApiRequestTime\\n1664 | \\t\\t\\tconst rateLimit = apiConfiguration?.rateLimitSeconds || 0\\n1665 | \\t\\t\\trateLimitDelay = Math.ceil(Math.max(0, rateLimit * 1000 - timeSinceLastRequest) / 1000)\\n1666 | \\t\\t}\\n1667 | \\n1668 | \\t\\t// Only show rate limiting message if we're not retrying. If retrying, we'll include the delay there.\\n1669 | \\t\\tif (rateLimitDelay > 0 && retryAttempt === 0) {\\n1670 | \\t\\t\\t// Show countdown timer\\n1671 | \\t\\t\\tfor (let i = rateLimitDelay; i > 0; i--) {\\n1672 | \\t\\t\\t\\tconst delayMessage = `Rate limiting for ${i} seconds...`\\n1673 | \\t\\t\\t\\tawait this.say(\\\"api_req_retry_delayed\\\", delayMessage, undefined, true)\\n1674 | \\t\\t\\t\\tawait delay(1000)\\n1675 | \\t\\t\\t}\\n1676 | \\t\\t}\\n1677 | \\n1678 | \\t\\t// Update last request time before making the request\\n1679 | \\t\\tthis.lastApiRequestTime = Date.now()\\n1680 | \\n1681 | \\t\\tconst systemPrompt = await this.getSystemPrompt()\\n1682 | \\t\\tconst { contextTokens } = this.getTokenUsage()\\n1683 | \\n1684 | \\t\\tif (contextTokens) {\\n1685 | \\t\\t\\t// Default max tokens value for thinking models when no specific\\n1686 | \\t\\t\\t// value is set.\\n1687 | \\t\\t\\tconst DEFAULT_THINKING_MODEL_MAX_TOKENS = 16_384\\n1688 | \\n1689 | \\t\\t\\tconst modelInfo = this.api.getModel().info\\n1690 | \\n1691 | \\t\\t\\tconst maxTokens = modelInfo.supportsReasoningBudget\\n1692 | \\t\\t\\t\\t? this.apiConfiguration.modelMaxTokens || DEFAULT_THINKING_MODEL_MAX_TOKENS\\n1693 | \\t\\t\\t\\t: modelInfo.maxTokens\\n1694 | \\n1695 | \\t\\t\\tconst contextWindow = modelInfo.contextWindow\\n1696 | \\n1697 | \\t\\t\\tconst truncateResult = await truncateConversationIfNeeded({\\n1698 | \\t\\t\\t\\tmessages: this.apiConversationHistory,\\n1699 | \\t\\t\\t\\ttotalTokens: contextTokens,\\n1700 | \\t\\t\\t\\tmaxTokens,\\n1701 | \\t\\t\\t\\tcontextWindow,\\n1702 | \\t\\t\\t\\tapiHandler: this.api,\\n1703 | \\t\\t\\t\\tautoCondenseContext,\\n1704 | \\t\\t\\t\\tautoCondenseContextPercent,\\n1705 | \\t\\t\\t\\tsystemPrompt,\\n1706 | \\t\\t\\t\\ttaskId: this.taskId,\\n1707 | \\t\\t\\t\\tcustomCondensingPrompt,\\n1708 | \\t\\t\\t\\tcondensingApiHandler,\\n1709 | \\t\\t\\t})\\n1710 | \\t\\t\\tif (truncateResult.messages !== this.apiConversationHistory) {\\n1711 | \\t\\t\\t\\tawait this.overwriteApiConversationHistory(truncateResult.messages)\\n1712 | \\t\\t\\t}\\n1713 | \\t\\t\\tif (truncateResult.error) {\\n1714 | \\t\\t\\t\\tawait this.say(\\\"condense_context_error\\\", truncateResult.error)\\n1715 | \\t\\t\\t} else if (truncateResult.summary) {\\n1716 | \\t\\t\\t\\tconst { summary, cost, prevContextTokens, newContextTokens = 0 } = truncateResult\\n1717 | \\t\\t\\t\\tconst contextCondense: ContextCondense = { summary, cost, newContextTokens, prevContextTokens }\\n1718 | \\t\\t\\t\\tawait this.say(\\n1719 | \\t\\t\\t\\t\\t\\\"condense_context\\\",\\n1720 | \\t\\t\\t\\t\\tundefined /* text */,\\n1721 | \\t\\t\\t\\t\\tundefined /* images */,\\n1722 | \\t\\t\\t\\t\\tfalse /* partial */,\\n1723 | \\t\\t\\t\\t\\tundefined /* checkpoint */,\\n1724 | \\t\\t\\t\\t\\tundefined /* progressStatus */,\\n1725 | \\t\\t\\t\\t\\t{ isNonInteractive: true } /* options */,\\n1726 | \\t\\t\\t\\t\\tcontextCondense,\\n1727 | \\t\\t\\t\\t)\\n1728 | \\t\\t\\t}\\n1729 | \\t\\t}\\n1730 | \\n1731 | \\t\\tconst messagesSinceLastSummary = getMessagesSinceLastSummary(this.apiConversationHistory)\\n1732 | \\t\\tconst cleanConversationHistory = maybeRemoveImageBlocks(messagesSinceLastSummary, this.api).map(\\n1733 | \\t\\t\\t({ role, content }) => ({ role, content }),\\n1734 | \\t\\t)\\n1735 | \\n1736 | \\t\\t// Check if we've reached the maximum number of auto-approved requests\\n1737 | \\t\\tconst maxRequests = state?.allowedMaxRequests || Infinity\\n1738 | \\n1739 | \\t\\t// Increment the counter for each new API request\\n1740 | \\t\\tthis.consecutiveAutoApprovedRequestsCount++\\n1741 | \\n1742 | \\t\\tif (this.consecutiveAutoApprovedRequestsCount > maxRequests) {\\n1743 | \\t\\t\\tconst { response } = await this.ask(\\\"auto_approval_max_req_reached\\\", JSON.stringify({ count: maxRequests }))\\n1744 | \\t\\t\\t// If we get past the promise, it means the user approved and did not start a new task\\n1745 | \\t\\t\\tif (response === \\\"yesButtonClicked\\\") {\\n1746 | \\t\\t\\t\\tthis.consecutiveAutoApprovedRequestsCount = 0\\n1747 | \\t\\t\\t}\\n1748 | \\t\\t}\\n1749 | \\n1750 | \\t\\tconst metadata: ApiHandlerCreateMessageMetadata = {\\n1751 | \\t\\t\\tmode: mode,\\n1752 | \\t\\t\\ttaskId: this.taskId,\\n1753 | \\t\\t}\\n1754 | \\n1755 | \\t\\tconst stream = this.api.createMessage(systemPrompt, cleanConversationHistory, metadata)\\n1756 | \\t\\tconst iterator = stream[Symbol.asyncIterator]()\\n1757 | \\n1758 | \\t\\ttry {\\n1759 | \\t\\t\\t// Awaiting first chunk to see if it will throw an error.\\n1760 | \\t\\t\\tthis.isWaitingForFirstChunk = true\\n1761 | \\t\\t\\tconst firstChunk = await iterator.next()\\n1762 | \\t\\t\\tyield firstChunk.value\\n1763 | \\t\\t\\tthis.isWaitingForFirstChunk = false\\n1764 | \\t\\t} catch (error) {\\n1765 | \\t\\t\\tthis.isWaitingForFirstChunk = false\\n1766 | \\t\\t\\t// note that this api_req_failed ask is unique in that we only present this option if the api hasn't streamed any content yet (ie it fails on the first chunk due), as it would allow them to hit a retry button. However if the api failed mid-stream, it could be in any arbitrary state where some tools may have executed, so that error is handled differently and requires cancelling the task entirely.\\n1767 | \\t\\t\\tif (autoApprovalEnabled && alwaysApproveResubmit) {\\n1768 | \\t\\t\\t\\tlet errorMsg\\n1769 | \\n1770 | \\t\\t\\t\\tif (error.error?.metadata?.raw) {\\n1771 | \\t\\t\\t\\t\\terrorMsg = JSON.stringify(error.error.metadata.raw, null, 2)\\n1772 | \\t\\t\\t\\t} else if (error.message) {\\n1773 | \\t\\t\\t\\t\\terrorMsg = error.message\\n1774 | \\t\\t\\t\\t} else {\\n1775 | \\t\\t\\t\\t\\terrorMsg = \\\"Unknown error\\\"\\n1776 | \\t\\t\\t\\t}\\n1777 | \\n1778 | \\t\\t\\t\\tconst baseDelay = requestDelaySeconds || 5\\n1779 | \\t\\t\\t\\tlet exponentialDelay = Math.ceil(baseDelay * Math.pow(2, retryAttempt))\\n1780 | \\n1781 | \\t\\t\\t\\t// If the error is a 429, and the error details contain a retry delay, use that delay instead of exponential backoff\\n1782 | \\t\\t\\t\\tif (error.status === 429) {\\n1783 | \\t\\t\\t\\t\\tconst geminiRetryDetails = error.errorDetails?.find(\\n1784 | \\t\\t\\t\\t\\t\\t(detail: any) => detail[\\\"@type\\\"] === \\\"type.googleapis.com/google.rpc.RetryInfo\\\",\\n1785 | \\t\\t\\t\\t\\t)\\n1786 | \\t\\t\\t\\t\\tif (geminiRetryDetails) {\\n1787 | \\t\\t\\t\\t\\t\\tconst match = geminiRetryDetails?.retryDelay?.match(/^(\\\\d+)s$/)\\n1788 | \\t\\t\\t\\t\\t\\tif (match) {\\n1789 | \\t\\t\\t\\t\\t\\t\\texponentialDelay = Number(match[1]) + 1\\n1790 | \\t\\t\\t\\t\\t\\t}\\n1791 | \\t\\t\\t\\t\\t}\\n1792 | \\t\\t\\t\\t}\\n1793 | \\n1794 | \\t\\t\\t\\t// Wait for the greater of the exponential delay or the rate limit delay\\n1795 | \\t\\t\\t\\tconst finalDelay = Math.max(exponentialDelay, rateLimitDelay)\\n1796 | \\n1797 | \\t\\t\\t\\t// Show countdown timer with exponential backoff\\n1798 | \\t\\t\\t\\tfor (let i = finalDelay; i > 0; i--) {\\n1799 | \\t\\t\\t\\t\\tawait this.say(\\n1800 | \\t\\t\\t\\t\\t\\t\\\"api_req_retry_delayed\\\",\\n1801 | \\t\\t\\t\\t\\t\\t`${errorMsg}\\\\n\\\\nRetry attempt ${retryAttempt + 1}\\\\nRetrying in ${i} seconds...`,\\n1802 | \\t\\t\\t\\t\\t\\tundefined,\\n1803 | \\t\\t\\t\\t\\t\\ttrue,\\n1804 | \\t\\t\\t\\t\\t)\\n1805 | \\t\\t\\t\\t\\tawait delay(1000)\\n1806 | \\t\\t\\t\\t}\\n1807 | \\n1808 | \\t\\t\\t\\tawait this.say(\\n1809 | \\t\\t\\t\\t\\t\\\"api_req_retry_delayed\\\",\\n1810 | \\t\\t\\t\\t\\t`${errorMsg}\\\\n\\\\nRetry attempt ${retryAttempt + 1}\\\\nRetrying now...`,\\n1811 | \\t\\t\\t\\t\\tundefined,\\n1812 | \\t\\t\\t\\t\\tfalse,\\n1813 | \\t\\t\\t\\t)\\n1814 | \\n1815 | \\t\\t\\t\\t// Delegate generator output from the recursive call with\\n1816 | \\t\\t\\t\\t// incremented retry count.\\n1817 | \\t\\t\\t\\tyield* this.attemptApiRequest(retryAttempt + 1)\\n1818 | \\n1819 | \\t\\t\\t\\treturn\\n1820 | \\t\\t\\t} else {\\n1821 | \\t\\t\\t\\tconst { response } = await this.ask(\\n1822 | \\t\\t\\t\\t\\t\\\"api_req_failed\\\",\\n1823 | \\t\\t\\t\\t\\terror.message ?? JSON.stringify(serializeError(error), null, 2),\\n1824 | \\t\\t\\t\\t)\\n1825 | \\n1826 | \\t\\t\\t\\tif (response !== \\\"yesButtonClicked\\\") {\\n1827 | \\t\\t\\t\\t\\t// This will never happen since if noButtonClicked, we will\\n1828 | \\t\\t\\t\\t\\t// clear current task, aborting this instance.\\n1829 | \\t\\t\\t\\t\\tthrow new Error(\\\"API request failed\\\")\\n1830 | \\t\\t\\t\\t}\\n1831 | \\n1832 | \\t\\t\\t\\tawait this.say(\\\"api_req_retried\\\")\\n1833 | \\n1834 | \\t\\t\\t\\t// Delegate generator output from the recursive call.\\n1835 | \\t\\t\\t\\tyield* this.attemptApiRequest()\\n1836 | \\t\\t\\t\\treturn\\n1837 | \\t\\t\\t}\\n1838 | \\t\\t}\\n1839 | \\n1840 | \\t\\t// No error, so we can continue to yield all remaining chunks.\\n1841 | \\t\\t// (Needs to be placed outside of try/catch since it we want caller to\\n1842 | \\t\\t// handle errors not with api_req_failed as that is reserved for first\\n1843 | \\t\\t// chunk failures only.)\\n1844 | \\t\\t// This delegates to another generator or iterable object. In this case,\\n1845 | \\t\\t// it's saying \\\"yield all remaining values from this iterator\\\". This\\n1846 | \\t\\t// effectively passes along all subsequent chunks from the original\\n1847 | \\t\\t// stream.\\n1848 | \\t\\tyield* iterator\\n1849 | \\t}\\n1850 | \\n1851 | \\t// Checkpoints\\n1852 | \\n1853 | \\tpublic async checkpointSave(force: boolean = false) {\\n1854 | \\t\\treturn checkpointSave(this, force)\\n1855 | \\t}\\n1856 | \\n1857 | \\tpublic async checkpointRestore(options: CheckpointRestoreOptions) {\\n1858 | \\t\\treturn checkpointRestore(this, options)\\n1859 | \\t}\\n1860 | \\n1861 | \\tpublic async checkpointDiff(options: CheckpointDiffOptions) {\\n1862 | \\t\\treturn checkpointDiff(this, options)\\n1863 | \\t}\\n1864 | \\n1865 | \\t// Metrics\\n1866 | \\n1867 | \\tpublic combineMessages(messages: ClineMessage[]) {\\n1868 | \\t\\treturn combineApiRequests(combineCommandSequences(messages))\\n1869 | \\t}\\n1870 | \\n1871 | \\tpublic getTokenUsage(): TokenUsage {\\n1872 | \\t\\treturn getApiMetrics(this.combineMessages(this.clineMessages.slice(1)))\\n1873 | \\t}\\n1874 | \\n1875 | \\tpublic recordToolUsage(toolName: ToolName) {\\n1876 | \\t\\tif (!this.toolUsage[toolName]) {\\n1877 | \\t\\t\\tthis.toolUsage[toolName] = { attempts: 0, failures: 0 }\\n1878 | \\t\\t}\\n1879 | \\n1880 | \\t\\tthis.toolUsage[toolName].attempts++\\n1881 | \\t}\\n1882 | \\n1883 | \\tpublic recordToolError(toolName: ToolName, error?: string) {\\n1884 | \\t\\tif (!this.toolUsage[toolName]) {\\n1885 | \\t\\t\\tthis.toolUsage[toolName] = { attempts: 0, failures: 0 }\\n1886 | \\t\\t}\\n1887 | \\n1888 | \\t\\tthis.toolUsage[toolName].failures++\\n1889 | \\n1890 | \\t\\tif (error) {\\n1891 | \\t\\t\\tthis.emit(\\\"taskToolFailed\\\", this.taskId, toolName, error)\\n1892 | \\t\\t}\\n1893 | \\t}\\n1894 | \\n1895 | \\t// Getters\\n1896 | \\n1897 | \\tpublic get cwd() {\\n1898 | \\t\\treturn this.workspacePath\\n1899 | \\t}\\n1900 | }\\n</content>\\n</file>\\n<file><path>src/core/webview/ClineProvider.ts</path>\\n<content lines=\\\"1-1728\\\">\\n   1 | import os from \\\"os\\\"\\n   2 | import * as path from \\\"path\\\"\\n   3 | import fs from \\\"fs/promises\\\"\\n   4 | import EventEmitter from \\\"events\\\"\\n   5 | \\n   6 | import { Anthropic } from \\\"@anthropic-ai/sdk\\\"\\n   7 | import delay from \\\"delay\\\"\\n   8 | import axios from \\\"axios\\\"\\n   9 | import pWaitFor from \\\"p-wait-for\\\"\\n  10 | import * as vscode from \\\"vscode\\\"\\n  11 | \\n  12 | import {\\n  13 | \\ttype GlobalState,\\n  14 | \\ttype ProviderName,\\n  15 | \\ttype ProviderSettings,\\n  16 | \\ttype RooCodeSettings,\\n  17 | \\ttype ProviderSettingsEntry,\\n  18 | \\ttype TelemetryProperties,\\n  19 | \\ttype TelemetryPropertiesProvider,\\n  20 | \\ttype CodeActionId,\\n  21 | \\ttype CodeActionName,\\n  22 | \\ttype TerminalActionId,\\n  23 | \\ttype TerminalActionPromptType,\\n  24 | \\ttype HistoryItem,\\n  25 | \\ttype CloudUserInfo,\\n  26 | \\trequestyDefaultModelId,\\n  27 | \\topenRouterDefaultModelId,\\n  28 | \\tglamaDefaultModelId,\\n  29 | \\tORGANIZATION_ALLOW_ALL,\\n  30 | } from \\\"@roo-code/types\\\"\\n  31 | import { TelemetryService } from \\\"@roo-code/telemetry\\\"\\n  32 | import { CloudService } from \\\"@roo-code/cloud\\\"\\n  33 | \\n  34 | import { t } from \\\"../../i18n\\\"\\n  35 | import { setPanel } from \\\"../../activate/registerCommands\\\"\\n  36 | import { Package } from \\\"../../shared/package\\\"\\n  37 | import { findLast } from \\\"../../shared/array\\\"\\n  38 | import { supportPrompt } from \\\"../../shared/support-prompt\\\"\\n  39 | import { GlobalFileNames } from \\\"../../shared/globalFileNames\\\"\\n  40 | import { ExtensionMessage } from \\\"../../shared/ExtensionMessage\\\"\\n  41 | import { Mode, defaultModeSlug } from \\\"../../shared/modes\\\"\\n  42 | import { experimentDefault, experiments, EXPERIMENT_IDS } from \\\"../../shared/experiments\\\"\\n  43 | import { formatLanguage } from \\\"../../shared/language\\\"\\n  44 | import { Terminal } from \\\"../../integrations/terminal/Terminal\\\"\\n  45 | import { downloadTask } from \\\"../../integrations/misc/export-markdown\\\"\\n  46 | import { getTheme } from \\\"../../integrations/theme/getTheme\\\"\\n  47 | import WorkspaceTracker from \\\"../../integrations/workspace/WorkspaceTracker\\\"\\n  48 | import { McpHub } from \\\"../../services/mcp/McpHub\\\"\\n  49 | import { McpServerManager } from \\\"../../services/mcp/McpServerManager\\\"\\n  50 | import { MarketplaceManager } from \\\"../../services/marketplace\\\"\\n  51 | import { ShadowCheckpointService } from \\\"../../services/checkpoints/ShadowCheckpointService\\\"\\n  52 | import { CodeIndexManager } from \\\"../../services/code-index/manager\\\"\\n  53 | import type { IndexProgressUpdate } from \\\"../../services/code-index/interfaces/manager\\\"\\n  54 | import { fileExistsAtPath } from \\\"../../utils/fs\\\"\\n  55 | import { setTtsEnabled, setTtsSpeed } from \\\"../../utils/tts\\\"\\n  56 | import { ContextProxy } from \\\"../config/ContextProxy\\\"\\n  57 | import { ProviderSettingsManager } from \\\"../config/ProviderSettingsManager\\\"\\n  58 | import { CustomModesManager } from \\\"../config/CustomModesManager\\\"\\n  59 | import { buildApiHandler } from \\\"../../api\\\"\\n  60 | import { Task, TaskOptions } from \\\"../task/Task\\\"\\n  61 | import { getNonce } from \\\"./getNonce\\\"\\n  62 | import { getUri } from \\\"./getUri\\\"\\n  63 | import { getSystemPromptFilePath } from \\\"../prompts/sections/custom-system-prompt\\\"\\n  64 | import { getWorkspacePath } from \\\"../../utils/path\\\"\\n  65 | import { webviewMessageHandler } from \\\"./webviewMessageHandler\\\"\\n  66 | import { WebviewMessage } from \\\"../../shared/WebviewMessage\\\"\\n  67 | import { EMBEDDING_MODEL_PROFILES } from \\\"../../shared/embeddingModels\\\"\\n  68 | import { ProfileValidator } from \\\"../../shared/ProfileValidator\\\"\\n  69 | \\n  70 | /**\\n  71 |  * https://github.com/microsoft/vscode-webview-ui-toolkit-samples/blob/main/default/weather-webview/src/providers/WeatherViewProvider.ts\\n  72 |  * https://github.com/KumarVariable/vscode-extension-sidebar-html/blob/master/src/customSidebarViewProvider.ts\\n  73 |  */\\n  74 | \\n  75 | export type ClineProviderEvents = {\\n  76 | \\tclineCreated: [cline: Task]\\n  77 | }\\n  78 | \\n  79 | class OrganizationAllowListViolationError extends Error {\\n  80 | \\tconstructor(message: string) {\\n  81 | \\t\\tsuper(message)\\n  82 | \\t}\\n  83 | }\\n  84 | \\n  85 | export class ClineProvider\\n  86 | \\textends EventEmitter<ClineProviderEvents>\\n  87 | \\timplements vscode.WebviewViewProvider, TelemetryPropertiesProvider\\n  88 | {\\n  89 | \\t// Used in package.json as the view's id. This value cannot be changed due\\n  90 | \\t// to how VSCode caches views based on their id, and updating the id would\\n  91 | \\t// break existing instances of the extension.\\n  92 | \\tpublic static readonly sideBarId = `${Package.name}.SidebarProvider`\\n  93 | \\tpublic static readonly tabPanelId = `${Package.name}.TabPanelProvider`\\n  94 | \\tprivate static activeInstances: Set<ClineProvider> = new Set()\\n  95 | \\tprivate disposables: vscode.Disposable[] = []\\n  96 | \\tprivate webviewDisposables: vscode.Disposable[] = []\\n  97 | \\tprivate view?: vscode.WebviewView | vscode.WebviewPanel\\n  98 | \\tprivate clineStack: Task[] = []\\n  99 | \\tprivate codeIndexStatusSubscription?: vscode.Disposable\\n 100 | \\tprivate _workspaceTracker?: WorkspaceTracker // workSpaceTracker read-only for access outside this class\\n 101 | \\tpublic get workspaceTracker(): WorkspaceTracker | undefined {\\n 102 | \\t\\treturn this._workspaceTracker\\n 103 | \\t}\\n 104 | \\tprotected mcpHub?: McpHub // Change from private to protected\\n 105 | \\tprivate marketplaceManager: MarketplaceManager\\n 106 | \\n 107 | \\tpublic isViewLaunched = false\\n 108 | \\tpublic settingsImportedAt?: number\\n 109 | \\tpublic readonly latestAnnouncementId = \\\"dec-12-2025-3-20\\\" // Update for v3.20.0 announcement\\n 110 | \\tpublic readonly providerSettingsManager: ProviderSettingsManager\\n 111 | \\tpublic readonly customModesManager: CustomModesManager\\n 112 | \\n 113 | \\tconstructor(\\n 114 | \\t\\treadonly context: vscode.ExtensionContext,\\n 115 | \\t\\tprivate readonly outputChannel: vscode.OutputChannel,\\n 116 | \\t\\tprivate readonly renderContext: \\\"sidebar\\\" | \\\"editor\\\" = \\\"sidebar\\\",\\n 117 | \\t\\tpublic readonly contextProxy: ContextProxy,\\n 118 | \\t\\tpublic readonly codeIndexManager?: CodeIndexManager,\\n 119 | \\t) {\\n 120 | \\t\\tsuper()\\n 121 | \\n 122 | \\t\\tthis.log(\\\"ClineProvider instantiated\\\")\\n 123 | \\t\\tClineProvider.activeInstances.add(this)\\n 124 | \\n 125 | \\t\\tthis.codeIndexManager = codeIndexManager\\n 126 | \\t\\tthis.updateGlobalState(\\\"codebaseIndexModels\\\", EMBEDDING_MODEL_PROFILES)\\n 127 | \\n 128 | \\t\\t// Start configuration loading (which might trigger indexing) in the background.\\n 129 | \\t\\t// Don't await, allowing activation to continue immediately.\\n 130 | \\n 131 | \\t\\t// Register this provider with the telemetry service to enable it to add\\n 132 | \\t\\t// properties like mode and provider.\\n 133 | \\t\\tTelemetryService.instance.setProvider(this)\\n 134 | \\n 135 | \\t\\tthis._workspaceTracker = new WorkspaceTracker(this)\\n 136 | \\n 137 | \\t\\tthis.providerSettingsManager = new ProviderSettingsManager(this.context)\\n 138 | \\n 139 | \\t\\tthis.customModesManager = new CustomModesManager(this.context, async () => {\\n 140 | \\t\\t\\tawait this.postStateToWebview()\\n 141 | \\t\\t})\\n 142 | \\n 143 | \\t\\t// Initialize MCP Hub through the singleton manager\\n 144 | \\t\\tMcpServerManager.getInstance(this.context, this)\\n 145 | \\t\\t\\t.then((hub) => {\\n 146 | \\t\\t\\t\\tthis.mcpHub = hub\\n 147 | \\t\\t\\t\\tthis.mcpHub.registerClient()\\n 148 | \\t\\t\\t})\\n 149 | \\t\\t\\t.catch((error) => {\\n 150 | \\t\\t\\t\\tthis.log(`Failed to initialize MCP Hub: ${error}`)\\n 151 | \\t\\t\\t})\\n 152 | \\n 153 | \\t\\tthis.marketplaceManager = new MarketplaceManager(this.context)\\n 154 | \\t}\\n 155 | \\n 156 | \\t// Adds a new Cline instance to clineStack, marking the start of a new task.\\n 157 | \\t// The instance is pushed to the top of the stack (LIFO order).\\n 158 | \\t// When the task is completed, the top instance is removed, reactivating the previous task.\\n 159 | \\tasync addClineToStack(cline: Task) {\\n 160 | \\t\\tconsole.log(`[subtasks] adding task ${cline.taskId}.${cline.instanceId} to stack`)\\n 161 | \\n 162 | \\t\\t// Add this cline instance into the stack that represents the order of all the called tasks.\\n 163 | \\t\\tthis.clineStack.push(cline)\\n 164 | \\n 165 | \\t\\t// Ensure getState() resolves correctly.\\n 166 | \\t\\tconst state = await this.getState()\\n 167 | \\n 168 | \\t\\tif (!state || typeof state.mode !== \\\"string\\\") {\\n 169 | \\t\\t\\tthrow new Error(t(\\\"common:errors.retrieve_current_mode\\\"))\\n 170 | \\t\\t}\\n 171 | \\t}\\n 172 | \\n 173 | \\t// Removes and destroys the top Cline instance (the current finished task),\\n 174 | \\t// activating the previous one (resuming the parent task).\\n 175 | \\tasync removeClineFromStack() {\\n 176 | \\t\\tif (this.clineStack.length === 0) {\\n 177 | \\t\\t\\treturn\\n 178 | \\t\\t}\\n 179 | \\n 180 | \\t\\t// Pop the top Cline instance from the stack.\\n 181 | \\t\\tlet cline = this.clineStack.pop()\\n 182 | \\n 183 | \\t\\tif (cline) {\\n 184 | \\t\\t\\tconsole.log(`[subtasks] removing task ${cline.taskId}.${cline.instanceId} from stack`)\\n 185 | \\n 186 | \\t\\t\\ttry {\\n 187 | \\t\\t\\t\\t// Abort the running task and set isAbandoned to true so\\n 188 | \\t\\t\\t\\t// all running promises will exit as well.\\n 189 | \\t\\t\\t\\tawait cline.abortTask(true)\\n 190 | \\t\\t\\t} catch (e) {\\n 191 | \\t\\t\\t\\tthis.log(\\n 192 | \\t\\t\\t\\t\\t`[subtasks] encountered error while aborting task ${cline.taskId}.${cline.instanceId}: ${e.message}`,\\n 193 | \\t\\t\\t\\t)\\n 194 | \\t\\t\\t}\\n 195 | \\n 196 | \\t\\t\\t// Make sure no reference kept, once promises end it will be\\n 197 | \\t\\t\\t// garbage collected.\\n 198 | \\t\\t\\tcline = undefined\\n 199 | \\t\\t}\\n 200 | \\t}\\n 201 | \\n 202 | \\t// returns the current cline object in the stack (the top one)\\n 203 | \\t// if the stack is empty, returns undefined\\n 204 | \\tgetCurrentCline(): Task | undefined {\\n 205 | \\t\\tif (this.clineStack.length === 0) {\\n 206 | \\t\\t\\treturn undefined\\n 207 | \\t\\t}\\n 208 | \\t\\treturn this.clineStack[this.clineStack.length - 1]\\n 209 | \\t}\\n 210 | \\n 211 | \\t// returns the current clineStack length (how many cline objects are in the stack)\\n 212 | \\tgetClineStackSize(): number {\\n 213 | \\t\\treturn this.clineStack.length\\n 214 | \\t}\\n 215 | \\n 216 | \\tpublic getCurrentTaskStack(): string[] {\\n 217 | \\t\\treturn this.clineStack.map((cline) => cline.taskId)\\n 218 | \\t}\\n 219 | \\n 220 | \\t// remove the current task/cline instance (at the top of the stack), so this task is finished\\n 221 | \\t// and resume the previous task/cline instance (if it exists)\\n 222 | \\t// this is used when a sub task is finished and the parent task needs to be resumed\\n 223 | \\tasync finishSubTask(lastMessage: string) {\\n 224 | \\t\\tconsole.log(`[subtasks] finishing subtask ${lastMessage}`)\\n 225 | \\t\\t// remove the last cline instance from the stack (this is the finished sub task)\\n 226 | \\t\\tawait this.removeClineFromStack()\\n 227 | \\t\\t// resume the last cline instance in the stack (if it exists - this is the 'parent' calling task)\\n 228 | \\t\\tawait this.getCurrentCline()?.resumePausedTask(lastMessage)\\n 229 | \\t}\\n 230 | \\n 231 | \\t/*\\n 232 | \\tVSCode extensions use the disposable pattern to clean up resources when the sidebar/editor tab is closed by the user or system. This applies to event listening, commands, interacting with the UI, etc.\\n 233 | \\t- https://vscode-docs.readthedocs.io/en/stable/extensions/patterns-and-principles/\\n 234 | \\t- https://github.com/microsoft/vscode-extension-samples/blob/main/webview-sample/src/extension.ts\\n 235 | \\t*/\\n 236 | \\tprivate clearWebviewResources() {\\n 237 | \\t\\twhile (this.webviewDisposables.length) {\\n 238 | \\t\\t\\tconst x = this.webviewDisposables.pop()\\n 239 | \\t\\t\\tif (x) {\\n 240 | \\t\\t\\t\\tx.dispose()\\n 241 | \\t\\t\\t}\\n 242 | \\t\\t}\\n 243 | \\t}\\n 244 | \\n 245 | \\tasync dispose() {\\n 246 | \\t\\tthis.log(\\\"Disposing ClineProvider...\\\")\\n 247 | \\t\\tawait this.removeClineFromStack()\\n 248 | \\t\\tthis.log(\\\"Cleared task\\\")\\n 249 | \\n 250 | \\t\\tif (this.view && \\\"dispose\\\" in this.view) {\\n 251 | \\t\\t\\tthis.view.dispose()\\n 252 | \\t\\t\\tthis.log(\\\"Disposed webview\\\")\\n 253 | \\t\\t}\\n 254 | \\n 255 | \\t\\tthis.clearWebviewResources()\\n 256 | \\n 257 | \\t\\twhile (this.disposables.length) {\\n 258 | \\t\\t\\tconst x = this.disposables.pop()\\n 259 | \\n 260 | \\t\\t\\tif (x) {\\n 261 | \\t\\t\\t\\tx.dispose()\\n 262 | \\t\\t\\t}\\n 263 | \\t\\t}\\n 264 | \\n 265 | \\t\\tthis._workspaceTracker?.dispose()\\n 266 | \\t\\tthis._workspaceTracker = undefined\\n 267 | \\t\\tawait this.mcpHub?.unregisterClient()\\n 268 | \\t\\tthis.mcpHub = undefined\\n 269 | \\t\\tthis.marketplaceManager?.cleanup()\\n 270 | \\t\\tthis.customModesManager?.dispose()\\n 271 | \\t\\tthis.log(\\\"Disposed all disposables\\\")\\n 272 | \\t\\tClineProvider.activeInstances.delete(this)\\n 273 | \\n 274 | \\t\\tMcpServerManager.unregisterProvider(this)\\n 275 | \\t}\\n 276 | \\n 277 | \\tpublic static getVisibleInstance(): ClineProvider | undefined {\\n 278 | \\t\\treturn findLast(Array.from(this.activeInstances), (instance) => instance.view?.visible === true)\\n 279 | \\t}\\n 280 | \\n 281 | \\tpublic static async getInstance(): Promise<ClineProvider | undefined> {\\n 282 | \\t\\tlet visibleProvider = ClineProvider.getVisibleInstance()\\n 283 | \\n 284 | \\t\\t// If no visible provider, try to show the sidebar view\\n 285 | \\t\\tif (!visibleProvider) {\\n 286 | \\t\\t\\tawait vscode.commands.executeCommand(`${Package.name}.SidebarProvider.focus`)\\n 287 | \\t\\t\\t// Wait briefly for the view to become visible\\n 288 | \\t\\t\\tawait delay(100)\\n 289 | \\t\\t\\tvisibleProvider = ClineProvider.getVisibleInstance()\\n 290 | \\t\\t}\\n 291 | \\n 292 | \\t\\t// If still no visible provider, return\\n 293 | \\t\\tif (!visibleProvider) {\\n 294 | \\t\\t\\treturn\\n 295 | \\t\\t}\\n 296 | \\n 297 | \\t\\treturn visibleProvider\\n 298 | \\t}\\n 299 | \\n 300 | \\tpublic static async isActiveTask(): Promise<boolean> {\\n 301 | \\t\\tconst visibleProvider = await ClineProvider.getInstance()\\n 302 | \\t\\tif (!visibleProvider) {\\n 303 | \\t\\t\\treturn false\\n 304 | \\t\\t}\\n 305 | \\n 306 | \\t\\t// Check if there is a cline instance in the stack (if this provider has an active task)\\n 307 | \\t\\tif (visibleProvider.getCurrentCline()) {\\n 308 | \\t\\t\\treturn true\\n 309 | \\t\\t}\\n 310 | \\n 311 | \\t\\treturn false\\n 312 | \\t}\\n 313 | \\n 314 | \\tpublic static async handleCodeAction(\\n 315 | \\t\\tcommand: CodeActionId,\\n 316 | \\t\\tpromptType: CodeActionName,\\n 317 | \\t\\tparams: Record<string, string | any[]>,\\n 318 | \\t): Promise<void> {\\n 319 | \\t\\t// Capture telemetry for code action usage\\n 320 | \\t\\tTelemetryService.instance.captureCodeActionUsed(promptType)\\n 321 | \\n 322 | \\t\\tconst visibleProvider = await ClineProvider.getInstance()\\n 323 | \\n 324 | \\t\\tif (!visibleProvider) {\\n 325 | \\t\\t\\treturn\\n 326 | \\t\\t}\\n 327 | \\n 328 | \\t\\tconst { customSupportPrompts } = await visibleProvider.getState()\\n 329 | \\n 330 | \\t\\t// TODO: Improve type safety for promptType.\\n 331 | \\t\\tconst prompt = supportPrompt.create(promptType, params, customSupportPrompts)\\n 332 | \\n 333 | \\t\\tif (command === \\\"addToContext\\\") {\\n 334 | \\t\\t\\tawait visibleProvider.postMessageToWebview({ type: \\\"invoke\\\", invoke: \\\"setChatBoxMessage\\\", text: prompt })\\n 335 | \\t\\t\\treturn\\n 336 | \\t\\t}\\n 337 | \\n 338 | \\t\\tawait visibleProvider.initClineWithTask(prompt)\\n 339 | \\t}\\n 340 | \\n 341 | \\tpublic static async handleTerminalAction(\\n 342 | \\t\\tcommand: TerminalActionId,\\n 343 | \\t\\tpromptType: TerminalActionPromptType,\\n 344 | \\t\\tparams: Record<string, string | any[]>,\\n 345 | \\t): Promise<void> {\\n 346 | \\t\\tTelemetryService.instance.captureCodeActionUsed(promptType)\\n 347 | \\n 348 | \\t\\tconst visibleProvider = await ClineProvider.getInstance()\\n 349 | \\n 350 | \\t\\tif (!visibleProvider) {\\n 351 | \\t\\t\\treturn\\n 352 | \\t\\t}\\n 353 | \\n 354 | \\t\\tconst { customSupportPrompts } = await visibleProvider.getState()\\n 355 | \\t\\tconst prompt = supportPrompt.create(promptType, params, customSupportPrompts)\\n 356 | \\n 357 | \\t\\tif (command === \\\"terminalAddToContext\\\") {\\n 358 | \\t\\t\\tawait visibleProvider.postMessageToWebview({ type: \\\"invoke\\\", invoke: \\\"setChatBoxMessage\\\", text: prompt })\\n 359 | \\t\\t\\treturn\\n 360 | \\t\\t}\\n 361 | \\n 362 | \\t\\ttry {\\n 363 | \\t\\t\\tawait visibleProvider.initClineWithTask(prompt)\\n 364 | \\t\\t} catch (error) {\\n 365 | \\t\\t\\tif (error instanceof OrganizationAllowListViolationError) {\\n 366 | \\t\\t\\t\\t// Errors from terminal commands seem to get swallowed / ignored.\\n 367 | \\t\\t\\t\\tvscode.window.showErrorMessage(error.message)\\n 368 | \\t\\t\\t}\\n 369 | \\t\\t\\tthrow error\\n 370 | \\t\\t}\\n 371 | \\t}\\n 372 | \\n 373 | \\tasync resolveWebviewView(webviewView: vscode.WebviewView | vscode.WebviewPanel) {\\n 374 | \\t\\tthis.log(\\\"Resolving webview view\\\")\\n 375 | \\n 376 | \\t\\tthis.view = webviewView\\n 377 | \\n 378 | \\t\\t// Set panel reference according to webview type\\n 379 | \\t\\tconst inTabMode = \\\"onDidChangeViewState\\\" in webviewView\\n 380 | \\t\\tif (inTabMode) {\\n 381 | \\t\\t\\t// Tag page type\\n 382 | \\t\\t\\tsetPanel(webviewView, \\\"tab\\\")\\n 383 | \\t\\t} else if (\\\"onDidChangeVisibility\\\" in webviewView) {\\n 384 | \\t\\t\\t// Sidebar Type\\n 385 | \\t\\t\\tsetPanel(webviewView, \\\"sidebar\\\")\\n 386 | \\t\\t}\\n 387 | \\n 388 | \\t\\t// Initialize out-of-scope variables that need to receive persistent global state values\\n 389 | \\t\\tthis.getState().then(\\n 390 | \\t\\t\\t({\\n 391 | \\t\\t\\t\\tterminalShellIntegrationTimeout = Terminal.defaultShellIntegrationTimeout,\\n 392 | \\t\\t\\t\\tterminalShellIntegrationDisabled = false,\\n 393 | \\t\\t\\t\\tterminalCommandDelay = 0,\\n 394 | \\t\\t\\t\\tterminalZshClearEolMark = true,\\n 395 | \\t\\t\\t\\tterminalZshOhMy = false,\\n 396 | \\t\\t\\t\\tterminalZshP10k = false,\\n 397 | \\t\\t\\t\\tterminalPowershellCounter = false,\\n 398 | \\t\\t\\t\\tterminalZdotdir = false,\\n 399 | \\t\\t\\t}) => {\\n 400 | \\t\\t\\t\\tTerminal.setShellIntegrationTimeout(terminalShellIntegrationTimeout)\\n 401 | \\t\\t\\t\\tTerminal.setShellIntegrationDisabled(terminalShellIntegrationDisabled)\\n 402 | \\t\\t\\t\\tTerminal.setCommandDelay(terminalCommandDelay)\\n 403 | \\t\\t\\t\\tTerminal.setTerminalZshClearEolMark(terminalZshClearEolMark)\\n 404 | \\t\\t\\t\\tTerminal.setTerminalZshOhMy(terminalZshOhMy)\\n 405 | \\t\\t\\t\\tTerminal.setTerminalZshP10k(terminalZshP10k)\\n 406 | \\t\\t\\t\\tTerminal.setPowershellCounter(terminalPowershellCounter)\\n 407 | \\t\\t\\t\\tTerminal.setTerminalZdotdir(terminalZdotdir)\\n 408 | \\t\\t\\t},\\n 409 | \\t\\t)\\n 410 | \\n 411 | \\t\\t// Initialize tts enabled state\\n 412 | \\t\\tthis.getState().then(({ ttsEnabled }) => {\\n 413 | \\t\\t\\tsetTtsEnabled(ttsEnabled ?? false)\\n 414 | \\t\\t})\\n 415 | \\n 416 | \\t\\t// Initialize tts speed state\\n 417 | \\t\\tthis.getState().then(({ ttsSpeed }) => {\\n 418 | \\t\\t\\tsetTtsSpeed(ttsSpeed ?? 1)\\n 419 | \\t\\t})\\n 420 | \\n 421 | \\t\\twebviewView.webview.options = {\\n 422 | \\t\\t\\t// Allow scripts in the webview\\n 423 | \\t\\t\\tenableScripts: true,\\n 424 | \\t\\t\\tlocalResourceRoots: [this.contextProxy.extensionUri],\\n 425 | \\t\\t}\\n 426 | \\n 427 | \\t\\twebviewView.webview.html =\\n 428 | \\t\\t\\tthis.contextProxy.extensionMode === vscode.ExtensionMode.Development\\n 429 | \\t\\t\\t\\t? await this.getHMRHtmlContent(webviewView.webview)\\n 430 | \\t\\t\\t\\t: this.getHtmlContent(webviewView.webview)\\n 431 | \\n 432 | \\t\\t// Sets up an event listener to listen for messages passed from the webview view context\\n 433 | \\t\\t// and executes code based on the message that is received\\n 434 | \\t\\tthis.setWebviewMessageListener(webviewView.webview)\\n 435 | \\n 436 | \\t\\t// Subscribe to code index status updates if the manager exists\\n 437 | \\t\\tif (this.codeIndexManager) {\\n 438 | \\t\\t\\tthis.codeIndexStatusSubscription = this.codeIndexManager.onProgressUpdate((update: IndexProgressUpdate) => {\\n 439 | \\t\\t\\t\\tthis.postMessageToWebview({\\n 440 | \\t\\t\\t\\t\\ttype: \\\"indexingStatusUpdate\\\",\\n 441 | \\t\\t\\t\\t\\tvalues: update,\\n 442 | \\t\\t\\t\\t})\\n 443 | \\t\\t\\t})\\n 444 | \\t\\t\\tthis.webviewDisposables.push(this.codeIndexStatusSubscription)\\n 445 | \\t\\t}\\n 446 | \\n 447 | \\t\\t// Logs show up in bottom panel > Debug Console\\n 448 | \\t\\t//console.log(\\\"registering listener\\\")\\n 449 | \\n 450 | \\t\\t// Listen for when the panel becomes visible\\n 451 | \\t\\t// https://github.com/microsoft/vscode-discussions/discussions/840\\n 452 | \\t\\tif (\\\"onDidChangeViewState\\\" in webviewView) {\\n 453 | \\t\\t\\t// WebviewView and WebviewPanel have all the same properties except for this visibility listener\\n 454 | \\t\\t\\t// panel\\n 455 | \\t\\t\\tconst viewStateDisposable = webviewView.onDidChangeViewState(() => {\\n 456 | \\t\\t\\t\\tif (this.view?.visible) {\\n 457 | \\t\\t\\t\\t\\tthis.postMessageToWebview({ type: \\\"action\\\", action: \\\"didBecomeVisible\\\" })\\n 458 | \\t\\t\\t\\t}\\n 459 | \\t\\t\\t})\\n 460 | \\t\\t\\tthis.webviewDisposables.push(viewStateDisposable)\\n 461 | \\t\\t} else if (\\\"onDidChangeVisibility\\\" in webviewView) {\\n 462 | \\t\\t\\t// sidebar\\n 463 | \\t\\t\\tconst visibilityDisposable = webviewView.onDidChangeVisibility(() => {\\n 464 | \\t\\t\\t\\tif (this.view?.visible) {\\n 465 | \\t\\t\\t\\t\\tthis.postMessageToWebview({ type: \\\"action\\\", action: \\\"didBecomeVisible\\\" })\\n 466 | \\t\\t\\t\\t}\\n 467 | \\t\\t\\t})\\n 468 | \\t\\t\\tthis.webviewDisposables.push(visibilityDisposable)\\n 469 | \\t\\t}\\n 470 | \\n 471 | \\t\\t// Listen for when the view is disposed\\n 472 | \\t\\t// This happens when the user closes the view or when the view is closed programmatically\\n 473 | \\t\\twebviewView.onDidDispose(\\n 474 | \\t\\t\\tasync () => {\\n 475 | \\t\\t\\t\\tif (inTabMode) {\\n 476 | \\t\\t\\t\\t\\tthis.log(\\\"Disposing ClineProvider instance for tab view\\\")\\n 477 | \\t\\t\\t\\t\\tawait this.dispose()\\n 478 | \\t\\t\\t\\t} else {\\n 479 | \\t\\t\\t\\t\\tthis.log(\\\"Clearing webview resources for sidebar view\\\")\\n 480 | \\t\\t\\t\\t\\tthis.clearWebviewResources()\\n 481 | \\t\\t\\t\\t\\tthis.codeIndexStatusSubscription?.dispose()\\n 482 | \\t\\t\\t\\t\\tthis.codeIndexStatusSubscription = undefined\\n 483 | \\t\\t\\t\\t}\\n 484 | \\t\\t\\t},\\n 485 | \\t\\t\\tnull,\\n 486 | \\t\\t\\tthis.disposables,\\n 487 | \\t\\t)\\n 488 | \\n 489 | \\t\\t// Listen for when color changes\\n 490 | \\t\\tconst configDisposable = vscode.workspace.onDidChangeConfiguration(async (e) => {\\n 491 | \\t\\t\\tif (e && e.affectsConfiguration(\\\"workbench.colorTheme\\\")) {\\n 492 | \\t\\t\\t\\t// Sends latest theme name to webview\\n 493 | \\t\\t\\t\\tawait this.postMessageToWebview({ type: \\\"theme\\\", text: JSON.stringify(await getTheme()) })\\n 494 | \\t\\t\\t}\\n 495 | \\t\\t})\\n 496 | \\t\\tthis.webviewDisposables.push(configDisposable)\\n 497 | \\n 498 | \\t\\t// If the extension is starting a new session, clear previous task state.\\n 499 | \\t\\tawait this.removeClineFromStack()\\n 500 | \\n 501 | \\t\\t// Set initial VSCode context for experiments\\n 502 | \\t\\tawait this.updateVSCodeContext()\\n 503 | \\n 504 | \\t\\tthis.log(\\\"Webview view resolved\\\")\\n 505 | \\t}\\n 506 | \\n 507 | \\tpublic async initClineWithSubTask(parent: Task, task?: string, images?: string[]) {\\n 508 | \\t\\treturn this.initClineWithTask(task, images, parent)\\n 509 | \\t}\\n 510 | \\n 511 | \\t// When initializing a new task, (not from history but from a tool command\\n 512 | \\t// new_task) there is no need to remove the previous task since the new\\n 513 | \\t// task is a subtask of the previous one, and when it finishes it is removed\\n 514 | \\t// from the stack and the caller is resumed in this way we can have a chain\\n 515 | \\t// of tasks, each one being a sub task of the previous one until the main\\n 516 | \\t// task is finished.\\n 517 | \\tpublic async initClineWithTask(\\n 518 | \\t\\ttask?: string,\\n 519 | \\t\\timages?: string[],\\n 520 | \\t\\tparentTask?: Task,\\n 521 | \\t\\toptions: Partial<\\n 522 | \\t\\t\\tPick<\\n 523 | \\t\\t\\t\\tTaskOptions,\\n 524 | \\t\\t\\t\\t\\\"enableDiff\\\" | \\\"enableCheckpoints\\\" | \\\"fuzzyMatchThreshold\\\" | \\\"consecutiveMistakeLimit\\\" | \\\"experiments\\\"\\n 525 | \\t\\t\\t>\\n 526 | \\t\\t> = {},\\n 527 | \\t) {\\n 528 | \\t\\tconst {\\n 529 | \\t\\t\\tapiConfiguration,\\n 530 | \\t\\t\\torganizationAllowList,\\n 531 | \\t\\t\\tdiffEnabled: enableDiff,\\n 532 | \\t\\t\\tenableCheckpoints,\\n 533 | \\t\\t\\tfuzzyMatchThreshold,\\n 534 | \\t\\t\\texperiments,\\n 535 | \\t\\t} = await this.getState()\\n 536 | \\n 537 | \\t\\tif (!ProfileValidator.isProfileAllowed(apiConfiguration, organizationAllowList)) {\\n 538 | \\t\\t\\tthrow new OrganizationAllowListViolationError(t(\\\"common:errors.violated_organization_allowlist\\\"))\\n 539 | \\t\\t}\\n 540 | \\n 541 | \\t\\tconst cline = new Task({\\n 542 | \\t\\t\\tprovider: this,\\n 543 | \\t\\t\\tapiConfiguration,\\n 544 | \\t\\t\\tenableDiff,\\n 545 | \\t\\t\\tenableCheckpoints,\\n 546 | \\t\\t\\tfuzzyMatchThreshold,\\n 547 | \\t\\t\\ttask,\\n 548 | \\t\\t\\timages,\\n 549 | \\t\\t\\texperiments,\\n 550 | \\t\\t\\trootTask: this.clineStack.length > 0 ? this.clineStack[0] : undefined,\\n 551 | \\t\\t\\tparentTask,\\n 552 | \\t\\t\\ttaskNumber: this.clineStack.length + 1,\\n 553 | \\t\\t\\tonCreated: (cline) => this.emit(\\\"clineCreated\\\", cline),\\n 554 | \\t\\t\\t...options,\\n 555 | \\t\\t})\\n 556 | \\n 557 | \\t\\tawait this.addClineToStack(cline)\\n 558 | \\n 559 | \\t\\tthis.log(\\n 560 | \\t\\t\\t`[subtasks] ${cline.parentTask ? \\\"child\\\" : \\\"parent\\\"} task ${cline.taskId}.${cline.instanceId} instantiated`,\\n 561 | \\t\\t)\\n 562 | \\n 563 | \\t\\treturn cline\\n 564 | \\t}\\n 565 | \\n 566 | \\tpublic async initClineWithHistoryItem(historyItem: HistoryItem & { rootTask?: Task; parentTask?: Task }) {\\n 567 | \\t\\tawait this.removeClineFromStack()\\n 568 | \\n 569 | \\t\\tconst {\\n 570 | \\t\\t\\tapiConfiguration,\\n 571 | \\t\\t\\tdiffEnabled: enableDiff,\\n 572 | \\t\\t\\tenableCheckpoints,\\n 573 | \\t\\t\\tfuzzyMatchThreshold,\\n 574 | \\t\\t\\texperiments,\\n 575 | \\t\\t} = await this.getState()\\n 576 | \\n 577 | \\t\\tconst cline = new Task({\\n 578 | \\t\\t\\tprovider: this,\\n 579 | \\t\\t\\tapiConfiguration,\\n 580 | \\t\\t\\tenableDiff,\\n 581 | \\t\\t\\tenableCheckpoints,\\n 582 | \\t\\t\\tfuzzyMatchThreshold,\\n 583 | \\t\\t\\thistoryItem,\\n 584 | \\t\\t\\texperiments,\\n 585 | \\t\\t\\trootTask: historyItem.rootTask,\\n 586 | \\t\\t\\tparentTask: historyItem.parentTask,\\n 587 | \\t\\t\\ttaskNumber: historyItem.number,\\n 588 | \\t\\t\\tonCreated: (cline) => this.emit(\\\"clineCreated\\\", cline),\\n 589 | \\t\\t})\\n 590 | \\n 591 | \\t\\tawait this.addClineToStack(cline)\\n 592 | \\t\\tthis.log(\\n 593 | \\t\\t\\t`[subtasks] ${cline.parentTask ? \\\"child\\\" : \\\"parent\\\"} task ${cline.taskId}.${cline.instanceId} instantiated`,\\n 594 | \\t\\t)\\n 595 | \\t\\treturn cline\\n 596 | \\t}\\n 597 | \\n 598 | \\tpublic async postMessageToWebview(message: ExtensionMessage) {\\n 599 | \\t\\tawait this.view?.webview.postMessage(message)\\n 600 | \\t}\\n 601 | \\n 602 | \\tprivate async getHMRHtmlContent(webview: vscode.Webview): Promise<string> {\\n 603 | \\t\\t// Try to read the port from the file\\n 604 | \\t\\tlet localPort = \\\"5173\\\" // Default fallback\\n 605 | \\t\\ttry {\\n 606 | \\t\\t\\tconst fs = require(\\\"fs\\\")\\n 607 | \\t\\t\\tconst path = require(\\\"path\\\")\\n 608 | \\t\\t\\tconst portFilePath = path.resolve(__dirname, \\\"../../.vite-port\\\")\\n 609 | \\n 610 | \\t\\t\\tif (fs.existsSync(portFilePath)) {\\n 611 | \\t\\t\\t\\tlocalPort = fs.readFileSync(portFilePath, \\\"utf8\\\").trim()\\n 612 | \\t\\t\\t\\tconsole.log(`[ClineProvider:Vite] Using Vite server port from ${portFilePath}: ${localPort}`)\\n 613 | \\t\\t\\t} else {\\n 614 | \\t\\t\\t\\tconsole.log(\\n 615 | \\t\\t\\t\\t\\t`[ClineProvider:Vite] Port file not found at ${portFilePath}, using default port: ${localPort}`,\\n 616 | \\t\\t\\t\\t)\\n 617 | \\t\\t\\t}\\n 618 | \\t\\t} catch (err) {\\n 619 | \\t\\t\\tconsole.error(\\\"[ClineProvider:Vite] Failed to read Vite port file:\\\", err)\\n 620 | \\t\\t\\t// Continue with default port if file reading fails\\n 621 | \\t\\t}\\n 622 | \\n 623 | \\t\\tconst localServerUrl = `localhost:${localPort}`\\n 624 | \\n 625 | \\t\\t// Check if local dev server is running.\\n 626 | \\t\\ttry {\\n 627 | \\t\\t\\tawait axios.get(`http://${localServerUrl}`)\\n 628 | \\t\\t} catch (error) {\\n 629 | \\t\\t\\tvscode.window.showErrorMessage(t(\\\"common:errors.hmr_not_running\\\"))\\n 630 | \\n 631 | \\t\\t\\treturn this.getHtmlContent(webview)\\n 632 | \\t\\t}\\n 633 | \\n 634 | \\t\\tconst nonce = getNonce()\\n 635 | \\n 636 | \\t\\tconst stylesUri = getUri(webview, this.contextProxy.extensionUri, [\\n 637 | \\t\\t\\t\\\"webview-ui\\\",\\n 638 | \\t\\t\\t\\\"build\\\",\\n 639 | \\t\\t\\t\\\"assets\\\",\\n 640 | \\t\\t\\t\\\"index.css\\\",\\n 641 | \\t\\t])\\n 642 | \\n 643 | \\t\\tconst codiconsUri = getUri(webview, this.contextProxy.extensionUri, [\\\"assets\\\", \\\"codicons\\\", \\\"codicon.css\\\"])\\n 644 | \\t\\tconst materialIconsUri = getUri(webview, this.contextProxy.extensionUri, [\\n 645 | \\t\\t\\t\\\"assets\\\",\\n 646 | \\t\\t\\t\\\"vscode-material-icons\\\",\\n 647 | \\t\\t\\t\\\"icons\\\",\\n 648 | \\t\\t])\\n 649 | \\t\\tconst imagesUri = getUri(webview, this.contextProxy.extensionUri, [\\\"assets\\\", \\\"images\\\"])\\n 650 | \\t\\tconst audioUri = getUri(webview, this.contextProxy.extensionUri, [\\\"webview-ui\\\", \\\"audio\\\"])\\n 651 | \\n 652 | \\t\\tconst file = \\\"src/index.tsx\\\"\\n 653 | \\t\\tconst scriptUri = `http://${localServerUrl}/${file}`\\n 654 | \\n 655 | \\t\\tconst reactRefresh = /*html*/ `\\n 656 | \\t\\t\\t<script nonce=\\\"${nonce}\\\" type=\\\"module\\\">\\n 657 | \\t\\t\\t\\timport RefreshRuntime from \\\"http://localhost:${localPort}/@react-refresh\\\"\\n 658 | \\t\\t\\t\\tRefreshRuntime.injectIntoGlobalHook(window)\\n 659 | \\t\\t\\t\\twindow.$RefreshReg$ = () => {}\\n 660 | \\t\\t\\t\\twindow.$RefreshSig$ = () => (type) => type\\n 661 | \\t\\t\\t\\twindow.__vite_plugin_react_preamble_installed__ = true\\n 662 | \\t\\t\\t</script>\\n 663 | \\t\\t`\\n 664 | \\n 665 | \\t\\tconst csp = [\\n 666 | \\t\\t\\t\\\"default-src 'none'\\\",\\n 667 | \\t\\t\\t`font-src ${webview.cspSource}`,\\n 668 | \\t\\t\\t`style-src ${webview.cspSource} 'unsafe-inline' https://* http://${localServerUrl} http://0.0.0.0:${localPort}`,\\n 669 | \\t\\t\\t`img-src ${webview.cspSource} https://storage.googleapis.com https://img.clerk.com data:`,\\n 670 | \\t\\t\\t`media-src ${webview.cspSource}`,\\n 671 | \\t\\t\\t`script-src 'unsafe-eval' ${webview.cspSource} https://* https://*.posthog.com http://${localServerUrl} http://0.0.0.0:${localPort} 'nonce-${nonce}'`,\\n 672 | \\t\\t\\t`connect-src https://* https://*.posthog.com ws://${localServerUrl} ws://0.0.0.0:${localPort} http://${localServerUrl} http://0.0.0.0:${localPort}`,\\n 673 | \\t\\t]\\n 674 | \\n 675 | \\t\\treturn /*html*/ `\\n 676 | \\t\\t\\t<!DOCTYPE html>\\n 677 | \\t\\t\\t<html lang=\\\"en\\\">\\n 678 | \\t\\t\\t\\t<head>\\n 679 | \\t\\t\\t\\t\\t<meta charset=\\\"utf-8\\\">\\n 680 | \\t\\t\\t\\t\\t<meta name=\\\"viewport\\\" content=\\\"width=device-width,initial-scale=1,shrink-to-fit=no\\\">\\n 681 | \\t\\t\\t\\t\\t<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"${csp.join(\\\"; \\\")}\\\">\\n 682 | \\t\\t\\t\\t\\t<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"${stylesUri}\\\">\\n 683 | \\t\\t\\t\\t\\t<link href=\\\"${codiconsUri}\\\" rel=\\\"stylesheet\\\" />\\n 684 | \\t\\t\\t\\t\\t<script nonce=\\\"${nonce}\\\">\\n 685 | \\t\\t\\t\\t\\t\\twindow.IMAGES_BASE_URI = \\\"${imagesUri}\\\"\\n 686 | \\t\\t\\t\\t\\t\\twindow.AUDIO_BASE_URI = \\\"${audioUri}\\\"\\n 687 | \\t\\t\\t\\t\\t\\twindow.MATERIAL_ICONS_BASE_URI = \\\"${materialIconsUri}\\\"\\n 688 | \\t\\t\\t\\t\\t</script>\\n 689 | \\t\\t\\t\\t\\t<title>Roo Code</title>\\n 690 | \\t\\t\\t\\t</head>\\n 691 | \\t\\t\\t\\t<body>\\n 692 | \\t\\t\\t\\t\\t<div id=\\\"root\\\"></div>\\n 693 | \\t\\t\\t\\t\\t${reactRefresh}\\n 694 | \\t\\t\\t\\t\\t<script type=\\\"module\\\" src=\\\"${scriptUri}\\\"></script>\\n 695 | \\t\\t\\t\\t</body>\\n 696 | \\t\\t\\t</html>\\n 697 | \\t\\t`\\n 698 | \\t}\\n 699 | \\n 700 | \\t/**\\n 701 | \\t * Defines and returns the HTML that should be rendered within the webview panel.\\n 702 | \\t *\\n 703 | \\t * @remarks This is also the place where references to the React webview build files\\n 704 | \\t * are created and inserted into the webview HTML.\\n 705 | \\t *\\n 706 | \\t * @param webview A reference to the extension webview\\n 707 | \\t * @param extensionUri The URI of the directory containing the extension\\n 708 | \\t * @returns A template string literal containing the HTML that should be\\n 709 | \\t * rendered within the webview panel\\n 710 | \\t */\\n 711 | \\tprivate getHtmlContent(webview: vscode.Webview): string {\\n 712 | \\t\\t// Get the local path to main script run in the webview,\\n 713 | \\t\\t// then convert it to a uri we can use in the webview.\\n 714 | \\n 715 | \\t\\t// The CSS file from the React build output\\n 716 | \\t\\tconst stylesUri = getUri(webview, this.contextProxy.extensionUri, [\\n 717 | \\t\\t\\t\\\"webview-ui\\\",\\n 718 | \\t\\t\\t\\\"build\\\",\\n 719 | \\t\\t\\t\\\"assets\\\",\\n 720 | \\t\\t\\t\\\"index.css\\\",\\n 721 | \\t\\t])\\n 722 | \\n 723 | \\t\\tconst scriptUri = getUri(webview, this.contextProxy.extensionUri, [\\\"webview-ui\\\", \\\"build\\\", \\\"assets\\\", \\\"index.js\\\"])\\n 724 | \\t\\tconst codiconsUri = getUri(webview, this.contextProxy.extensionUri, [\\\"assets\\\", \\\"codicons\\\", \\\"codicon.css\\\"])\\n 725 | \\t\\tconst materialIconsUri = getUri(webview, this.contextProxy.extensionUri, [\\n 726 | \\t\\t\\t\\\"assets\\\",\\n 727 | \\t\\t\\t\\\"vscode-material-icons\\\",\\n 728 | \\t\\t\\t\\\"icons\\\",\\n 729 | \\t\\t])\\n 730 | \\t\\tconst imagesUri = getUri(webview, this.contextProxy.extensionUri, [\\\"assets\\\", \\\"images\\\"])\\n 731 | \\t\\tconst audioUri = getUri(webview, this.contextProxy.extensionUri, [\\\"webview-ui\\\", \\\"audio\\\"])\\n 732 | \\n 733 | \\t\\t// Use a nonce to only allow a specific script to be run.\\n 734 | \\t\\t/*\\n 735 | \\t\\tcontent security policy of your webview to only allow scripts that have a specific nonce\\n 736 | \\t\\tcreate a content security policy meta tag so that only loading scripts with a nonce is allowed\\n 737 | \\t\\tAs your extension grows you will likely want to add custom styles, fonts, and/or images to your webview. If you do, you will need to update the content security policy meta tag to explicitly allow for these resources. E.g.\\n 738 | \\t\\t\\t\\t<meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'none'; style-src ${webview.cspSource}; font-src ${webview.cspSource}; img-src ${webview.cspSource} https:; script-src 'nonce-${nonce}';\\\">\\n 739 | \\t\\t- 'unsafe-inline' is required for styles due to vscode-webview-toolkit's dynamic style injection\\n 740 | \\t\\t- since we pass base64 images to the webview, we need to specify img-src ${webview.cspSource} data:;\\n 741 | \\n 742 | \\t\\tin meta tag we add nonce attribute: A cryptographic nonce (only used once) to allow scripts. The server must generate a unique nonce value each time it transmits a policy. It is critical to provide a nonce that cannot be guessed as bypassing a resource's policy is otherwise trivial.\\n 743 | \\t\\t*/\\n 744 | \\t\\tconst nonce = getNonce()\\n 745 | \\n 746 | \\t\\t// Tip: Install the es6-string-html VS Code extension to enable code highlighting below\\n 747 | \\t\\treturn /*html*/ `\\n 748 |         <!DOCTYPE html>\\n 749 |         <html lang=\\\"en\\\">\\n 750 |           <head>\\n 751 |             <meta charset=\\\"utf-8\\\">\\n 752 |             <meta name=\\\"viewport\\\" content=\\\"width=device-width,initial-scale=1,shrink-to-fit=no\\\">\\n 753 |             <meta name=\\\"theme-color\\\" content=\\\"#000000\\\">\\n 754 |             <meta http-equiv=\\\"Content-Security-Policy\\\" content=\\\"default-src 'none'; font-src ${webview.cspSource}; style-src ${webview.cspSource} 'unsafe-inline'; img-src ${webview.cspSource} https://storage.googleapis.com https://img.clerk.com data:; media-src ${webview.cspSource}; script-src ${webview.cspSource} 'wasm-unsafe-eval' 'nonce-${nonce}' https://us-assets.i.posthog.com 'strict-dynamic'; connect-src https://openrouter.ai https://api.requesty.ai https://us.i.posthog.com https://us-assets.i.posthog.com;\\\">\\n 755 |             <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"${stylesUri}\\\">\\n 756 | \\t\\t\\t<link href=\\\"${codiconsUri}\\\" rel=\\\"stylesheet\\\" />\\n 757 | \\t\\t\\t<script nonce=\\\"${nonce}\\\">\\n 758 | \\t\\t\\t\\twindow.IMAGES_BASE_URI = \\\"${imagesUri}\\\"\\n 759 | \\t\\t\\t\\twindow.AUDIO_BASE_URI = \\\"${audioUri}\\\"\\n 760 | \\t\\t\\t\\twindow.MATERIAL_ICONS_BASE_URI = \\\"${materialIconsUri}\\\"\\n 761 | \\t\\t\\t</script>\\n 762 |             <title>Roo Code</title>\\n 763 |           </head>\\n 764 |           <body>\\n 765 |             <noscript>You need to enable JavaScript to run this app.</noscript>\\n 766 |             <div id=\\\"root\\\"></div>\\n 767 |             <script nonce=\\\"${nonce}\\\" type=\\\"module\\\" src=\\\"${scriptUri}\\\"></script>\\n 768 |           </body>\\n 769 |         </html>\\n 770 |       `\\n 771 | \\t}\\n 772 | \\n 773 | \\t/**\\n 774 | \\t * Sets up an event listener to listen for messages passed from the webview context and\\n 775 | \\t * executes code based on the message that is received.\\n 776 | \\t *\\n 777 | \\t * @param webview A reference to the extension webview\\n 778 | \\t */\\n 779 | \\tprivate setWebviewMessageListener(webview: vscode.Webview) {\\n 780 | \\t\\tconst onReceiveMessage = async (message: WebviewMessage) =>\\n 781 | \\t\\t\\twebviewMessageHandler(this, message, this.marketplaceManager)\\n 782 | \\n 783 | \\t\\tconst messageDisposable = webview.onDidReceiveMessage(onReceiveMessage)\\n 784 | \\t\\tthis.webviewDisposables.push(messageDisposable)\\n 785 | \\t}\\n 786 | \\n 787 | \\t/**\\n 788 | \\t * Handle switching to a new mode, including updating the associated API configuration\\n 789 | \\t * @param newMode The mode to switch to\\n 790 | \\t */\\n 791 | \\tpublic async handleModeSwitch(newMode: Mode) {\\n 792 | \\t\\tconst cline = this.getCurrentCline()\\n 793 | \\n 794 | \\t\\tif (cline) {\\n 795 | \\t\\t\\tTelemetryService.instance.captureModeSwitch(cline.taskId, newMode)\\n 796 | \\t\\t\\tcline.emit(\\\"taskModeSwitched\\\", cline.taskId, newMode)\\n 797 | \\t\\t}\\n 798 | \\n 799 | \\t\\tawait this.updateGlobalState(\\\"mode\\\", newMode)\\n 800 | \\n 801 | \\t\\t// Load the saved API config for the new mode if it exists\\n 802 | \\t\\tconst savedConfigId = await this.providerSettingsManager.getModeConfigId(newMode)\\n 803 | \\t\\tconst listApiConfig = await this.providerSettingsManager.listConfig()\\n 804 | \\n 805 | \\t\\t// Update listApiConfigMeta first to ensure UI has latest data\\n 806 | \\t\\tawait this.updateGlobalState(\\\"listApiConfigMeta\\\", listApiConfig)\\n 807 | \\n 808 | \\t\\t// If this mode has a saved config, use it.\\n 809 | \\t\\tif (savedConfigId) {\\n 810 | \\t\\t\\tconst profile = listApiConfig.find(({ id }) => id === savedConfigId)\\n 811 | \\n 812 | \\t\\t\\tif (profile?.name) {\\n 813 | \\t\\t\\t\\tawait this.activateProviderProfile({ name: profile.name })\\n 814 | \\t\\t\\t}\\n 815 | \\t\\t} else {\\n 816 | \\t\\t\\t// If no saved config for this mode, save current config as default.\\n 817 | \\t\\t\\tconst currentApiConfigName = this.getGlobalState(\\\"currentApiConfigName\\\")\\n 818 | \\n 819 | \\t\\t\\tif (currentApiConfigName) {\\n 820 | \\t\\t\\t\\tconst config = listApiConfig.find((c) => c.name === currentApiConfigName)\\n 821 | \\n 822 | \\t\\t\\t\\tif (config?.id) {\\n 823 | \\t\\t\\t\\t\\tawait this.providerSettingsManager.setModeConfig(newMode, config.id)\\n 824 | \\t\\t\\t\\t}\\n 825 | \\t\\t\\t}\\n 826 | \\t\\t}\\n 827 | \\n 828 | \\t\\tawait this.postStateToWebview()\\n 829 | \\t}\\n 830 | \\n 831 | \\t// Provider Profile Management\\n 832 | \\n 833 | \\tgetProviderProfileEntries(): ProviderSettingsEntry[] {\\n 834 | \\t\\treturn this.contextProxy.getValues().listApiConfigMeta || []\\n 835 | \\t}\\n 836 | \\n 837 | \\tgetProviderProfileEntry(name: string): ProviderSettingsEntry | undefined {\\n 838 | \\t\\treturn this.getProviderProfileEntries().find((profile) => profile.name === name)\\n 839 | \\t}\\n 840 | \\n 841 | \\tpublic hasProviderProfileEntry(name: string): boolean {\\n 842 | \\t\\treturn !!this.getProviderProfileEntry(name)\\n 843 | \\t}\\n 844 | \\n 845 | \\tasync upsertProviderProfile(\\n 846 | \\t\\tname: string,\\n 847 | \\t\\tproviderSettings: ProviderSettings,\\n 848 | \\t\\tactivate: boolean = true,\\n 849 | \\t): Promise<string | undefined> {\\n 850 | \\t\\ttry {\\n 851 | \\t\\t\\t// TODO: Do we need to be calling `activateProfile`? It's not\\n 852 | \\t\\t\\t// clear to me what the source of truth should be; in some cases\\n 853 | \\t\\t\\t// we rely on the `ContextProxy`'s data store and in other cases\\n 854 | \\t\\t\\t// we rely on the `ProviderSettingsManager`'s data store. It might\\n 855 | \\t\\t\\t// be simpler to unify these two.\\n 856 | \\t\\t\\tconst id = await this.providerSettingsManager.saveConfig(name, providerSettings)\\n 857 | \\n 858 | \\t\\t\\tif (activate) {\\n 859 | \\t\\t\\t\\tconst { mode } = await this.getState()\\n 860 | \\n 861 | \\t\\t\\t\\t// These promises do the following:\\n 862 | \\t\\t\\t\\t// 1. Adds or updates the list of provider profiles.\\n 863 | \\t\\t\\t\\t// 2. Sets the current provider profile.\\n 864 | \\t\\t\\t\\t// 3. Sets the current mode's provider profile.\\n 865 | \\t\\t\\t\\t// 4. Copies the provider settings to the context.\\n 866 | \\t\\t\\t\\t//\\n 867 | \\t\\t\\t\\t// Note: 1, 2, and 4 can be done in one `ContextProxy` call:\\n 868 | \\t\\t\\t\\t// this.contextProxy.setValues({ ...providerSettings, listApiConfigMeta: ..., currentApiConfigName: ... })\\n 869 | \\t\\t\\t\\t// We should probably switch to that and verify that it works.\\n 870 | \\t\\t\\t\\t// I left the original implementation in just to be safe.\\n 871 | \\t\\t\\t\\tawait Promise.all([\\n 872 | \\t\\t\\t\\t\\tthis.updateGlobalState(\\\"listApiConfigMeta\\\", await this.providerSettingsManager.listConfig()),\\n 873 | \\t\\t\\t\\t\\tthis.updateGlobalState(\\\"currentApiConfigName\\\", name),\\n 874 | \\t\\t\\t\\t\\tthis.providerSettingsManager.setModeConfig(mode, id),\\n 875 | \\t\\t\\t\\t\\tthis.contextProxy.setProviderSettings(providerSettings),\\n 876 | \\t\\t\\t\\t])\\n 877 | \\n 878 | \\t\\t\\t\\t// Notify CodeIndexManager about the settings change\\n 879 | \\t\\t\\t\\tif (this.codeIndexManager) {\\n 880 | \\t\\t\\t\\t\\tawait this.codeIndexManager.handleExternalSettingsChange()\\n 881 | \\t\\t\\t\\t}\\n 882 | \\n 883 | \\t\\t\\t\\t// Change the provider for the current task.\\n 884 | \\t\\t\\t\\t// TODO: We should rename `buildApiHandler` for clarity (e.g. `getProviderClient`).\\n 885 | \\t\\t\\t\\tconst task = this.getCurrentCline()\\n 886 | \\n 887 | \\t\\t\\t\\tif (task) {\\n 888 | \\t\\t\\t\\t\\ttask.api = buildApiHandler(providerSettings)\\n 889 | \\t\\t\\t\\t}\\n 890 | \\t\\t\\t} else {\\n 891 | \\t\\t\\t\\tawait this.updateGlobalState(\\\"listApiConfigMeta\\\", await this.providerSettingsManager.listConfig())\\n 892 | \\t\\t\\t}\\n 893 | \\n 894 | \\t\\t\\tawait this.postStateToWebview()\\n 895 | \\t\\t\\treturn id\\n 896 | \\t\\t} catch (error) {\\n 897 | \\t\\t\\tthis.log(\\n 898 | \\t\\t\\t\\t`Error create new api configuration: ${JSON.stringify(error, Object.getOwnPropertyNames(error), 2)}`,\\n 899 | \\t\\t\\t)\\n 900 | \\n 901 | \\t\\t\\tvscode.window.showErrorMessage(t(\\\"common:errors.create_api_config\\\"))\\n 902 | \\t\\t\\treturn undefined\\n 903 | \\t\\t}\\n 904 | \\t}\\n 905 | \\n 906 | \\tasync deleteProviderProfile(profileToDelete: ProviderSettingsEntry) {\\n 907 | \\t\\tconst globalSettings = this.contextProxy.getValues()\\n 908 | \\t\\tlet profileToActivate: string | undefined = globalSettings.currentApiConfigName\\n 909 | \\n 910 | \\t\\tif (profileToDelete.name === profileToActivate) {\\n 911 | \\t\\t\\tprofileToActivate = this.getProviderProfileEntries().find(({ name }) => name !== profileToDelete.name)?.name\\n 912 | \\t\\t}\\n 913 | \\n 914 | \\t\\tif (!profileToActivate) {\\n 915 | \\t\\t\\tthrow new Error(\\\"You cannot delete the last profile\\\")\\n 916 | \\t\\t}\\n 917 | \\n 918 | \\t\\tconst entries = this.getProviderProfileEntries().filter(({ name }) => name !== profileToDelete.name)\\n 919 | \\n 920 | \\t\\tawait this.contextProxy.setValues({\\n 921 | \\t\\t\\t...globalSettings,\\n 922 | \\t\\t\\tcurrentApiConfigName: profileToActivate,\\n 923 | \\t\\t\\tlistApiConfigMeta: entries,\\n 924 | \\t\\t})\\n 925 | \\n 926 | \\t\\tawait this.postStateToWebview()\\n 927 | \\t}\\n 928 | \\n 929 | \\tasync activateProviderProfile(args: { name: string } | { id: string }) {\\n 930 | \\t\\tconst { name, id, ...providerSettings } = await this.providerSettingsManager.activateProfile(args)\\n 931 | \\n 932 | \\t\\t// See `upsertProviderProfile` for a description of what this is doing.\\n 933 | \\t\\tawait Promise.all([\\n 934 | \\t\\t\\tthis.contextProxy.setValue(\\\"listApiConfigMeta\\\", await this.providerSettingsManager.listConfig()),\\n 935 | \\t\\t\\tthis.contextProxy.setValue(\\\"currentApiConfigName\\\", name),\\n 936 | \\t\\t\\tthis.contextProxy.setProviderSettings(providerSettings),\\n 937 | \\t\\t])\\n 938 | \\n 939 | \\t\\tconst { mode } = await this.getState()\\n 940 | \\n 941 | \\t\\tif (id) {\\n 942 | \\t\\t\\tawait this.providerSettingsManager.setModeConfig(mode, id)\\n 943 | \\t\\t}\\n 944 | \\n 945 | \\t\\t// Change the provider for the current task.\\n 946 | \\t\\tconst task = this.getCurrentCline()\\n 947 | \\n 948 | \\t\\tif (task) {\\n 949 | \\t\\t\\ttask.api = buildApiHandler(providerSettings)\\n 950 | \\t\\t}\\n 951 | \\n 952 | \\t\\tawait this.postStateToWebview()\\n 953 | \\t}\\n 954 | \\n 955 | \\t// Task Management\\n 956 | \\n 957 | \\tasync cancelTask() {\\n 958 | \\t\\tconst cline = this.getCurrentCline()\\n 959 | \\n 960 | \\t\\tif (!cline) {\\n 961 | \\t\\t\\treturn\\n 962 | \\t\\t}\\n 963 | \\n 964 | \\t\\tconsole.log(`[subtasks] cancelling task ${cline.taskId}.${cline.instanceId}`)\\n 965 | \\n 966 | \\t\\tconst { historyItem } = await this.getTaskWithId(cline.taskId)\\n 967 | \\t\\t// Preserve parent and root task information for history item.\\n 968 | \\t\\tconst rootTask = cline.rootTask\\n 969 | \\t\\tconst parentTask = cline.parentTask\\n 970 | \\n 971 | \\t\\tcline.abortTask()\\n 972 | \\n 973 | \\t\\tawait pWaitFor(\\n 974 | \\t\\t\\t() =>\\n 975 | \\t\\t\\t\\tthis.getCurrentCline()! === undefined ||\\n 976 | \\t\\t\\t\\tthis.getCurrentCline()!.isStreaming === false ||\\n 977 | \\t\\t\\t\\tthis.getCurrentCline()!.didFinishAbortingStream ||\\n 978 | \\t\\t\\t\\t// If only the first chunk is processed, then there's no\\n 979 | \\t\\t\\t\\t// need to wait for graceful abort (closes edits, browser,\\n 980 | \\t\\t\\t\\t// etc).\\n 981 | \\t\\t\\t\\tthis.getCurrentCline()!.isWaitingForFirstChunk,\\n 982 | \\t\\t\\t{\\n 983 | \\t\\t\\t\\ttimeout: 3_000,\\n 984 | \\t\\t\\t},\\n 985 | \\t\\t).catch(() => {\\n 986 | \\t\\t\\tconsole.error(\\\"Failed to abort task\\\")\\n 987 | \\t\\t})\\n 988 | \\n 989 | \\t\\tif (this.getCurrentCline()) {\\n 990 | \\t\\t\\t// 'abandoned' will prevent this Cline instance from affecting\\n 991 | \\t\\t\\t// future Cline instances. This may happen if its hanging on a\\n 992 | \\t\\t\\t// streaming request.\\n 993 | \\t\\t\\tthis.getCurrentCline()!.abandoned = true\\n 994 | \\t\\t}\\n 995 | \\n 996 | \\t\\t// Clears task again, so we need to abortTask manually above.\\n 997 | \\t\\tawait this.initClineWithHistoryItem({ ...historyItem, rootTask, parentTask })\\n 998 | \\t}\\n 999 | \\n1000 | \\tasync updateCustomInstructions(instructions?: string) {\\n1001 | \\t\\t// User may be clearing the field.\\n1002 | \\t\\tawait this.updateGlobalState(\\\"customInstructions\\\", instructions || undefined)\\n1003 | \\t\\tawait this.postStateToWebview()\\n1004 | \\t}\\n1005 | \\n1006 | \\t// MCP\\n1007 | \\n1008 | \\tasync ensureMcpServersDirectoryExists(): Promise<string> {\\n1009 | \\t\\t// Get platform-specific application data directory\\n1010 | \\t\\tlet mcpServersDir: string\\n1011 | \\t\\tif (process.platform === \\\"win32\\\") {\\n1012 | \\t\\t\\t// Windows: %APPDATA%\\\\Roo-Code\\\\MCP\\n1013 | \\t\\t\\tmcpServersDir = path.join(os.homedir(), \\\"AppData\\\", \\\"Roaming\\\", \\\"Roo-Code\\\", \\\"MCP\\\")\\n1014 | \\t\\t} else if (process.platform === \\\"darwin\\\") {\\n1015 | \\t\\t\\t// macOS: ~/Documents/Cline/MCP\\n1016 | \\t\\t\\tmcpServersDir = path.join(os.homedir(), \\\"Documents\\\", \\\"Cline\\\", \\\"MCP\\\")\\n1017 | \\t\\t} else {\\n1018 | \\t\\t\\t// Linux: ~/.local/share/Cline/MCP\\n1019 | \\t\\t\\tmcpServersDir = path.join(os.homedir(), \\\".local\\\", \\\"share\\\", \\\"Roo-Code\\\", \\\"MCP\\\")\\n1020 | \\t\\t}\\n1021 | \\n1022 | \\t\\ttry {\\n1023 | \\t\\t\\tawait fs.mkdir(mcpServersDir, { recursive: true })\\n1024 | \\t\\t} catch (error) {\\n1025 | \\t\\t\\t// Fallback to a relative path if directory creation fails\\n1026 | \\t\\t\\treturn path.join(os.homedir(), \\\".roo-code\\\", \\\"mcp\\\")\\n1027 | \\t\\t}\\n1028 | \\t\\treturn mcpServersDir\\n1029 | \\t}\\n1030 | \\n1031 | \\tasync ensureSettingsDirectoryExists(): Promise<string> {\\n1032 | \\t\\tconst { getSettingsDirectoryPath } = await import(\\\"../../utils/storage\\\")\\n1033 | \\t\\tconst globalStoragePath = this.contextProxy.globalStorageUri.fsPath\\n1034 | \\t\\treturn getSettingsDirectoryPath(globalStoragePath)\\n1035 | \\t}\\n1036 | \\n1037 | \\t// OpenRouter\\n1038 | \\n1039 | \\tasync handleOpenRouterCallback(code: string) {\\n1040 | \\t\\tlet { apiConfiguration, currentApiConfigName } = await this.getState()\\n1041 | \\n1042 | \\t\\tlet apiKey: string\\n1043 | \\t\\ttry {\\n1044 | \\t\\t\\tconst baseUrl = apiConfiguration.openRouterBaseUrl || \\\"https://openrouter.ai/api/v1\\\"\\n1045 | \\t\\t\\t// Extract the base domain for the auth endpoint\\n1046 | \\t\\t\\tconst baseUrlDomain = baseUrl.match(/^(https?:\\\\/\\\\/[^\\\\/]+)/)?.[1] || \\\"https://openrouter.ai\\\"\\n1047 | \\t\\t\\tconst response = await axios.post(`${baseUrlDomain}/api/v1/auth/keys`, { code })\\n1048 | \\t\\t\\tif (response.data && response.data.key) {\\n1049 | \\t\\t\\t\\tapiKey = response.data.key\\n1050 | \\t\\t\\t} else {\\n1051 | \\t\\t\\t\\tthrow new Error(\\\"Invalid response from OpenRouter API\\\")\\n1052 | \\t\\t\\t}\\n1053 | \\t\\t} catch (error) {\\n1054 | \\t\\t\\tthis.log(\\n1055 | \\t\\t\\t\\t`Error exchanging code for API key: ${JSON.stringify(error, Object.getOwnPropertyNames(error), 2)}`,\\n1056 | \\t\\t\\t)\\n1057 | \\t\\t\\tthrow error\\n1058 | \\t\\t}\\n1059 | \\n1060 | \\t\\tconst newConfiguration: ProviderSettings = {\\n1061 | \\t\\t\\t...apiConfiguration,\\n1062 | \\t\\t\\tapiProvider: \\\"openrouter\\\",\\n1063 | \\t\\t\\topenRouterApiKey: apiKey,\\n1064 | \\t\\t\\topenRouterModelId: apiConfiguration?.openRouterModelId || openRouterDefaultModelId,\\n1065 | \\t\\t}\\n1066 | \\n1067 | \\t\\tawait this.upsertProviderProfile(currentApiConfigName, newConfiguration)\\n1068 | \\t}\\n1069 | \\n1070 | \\t// Glama\\n1071 | \\n1072 | \\tasync handleGlamaCallback(code: string) {\\n1073 | \\t\\tlet apiKey: string\\n1074 | \\t\\ttry {\\n1075 | \\t\\t\\tconst response = await axios.post(\\\"https://glama.ai/api/gateway/v1/auth/exchange-code\\\", { code })\\n1076 | \\t\\t\\tif (response.data && response.data.apiKey) {\\n1077 | \\t\\t\\t\\tapiKey = response.data.apiKey\\n1078 | \\t\\t\\t} else {\\n1079 | \\t\\t\\t\\tthrow new Error(\\\"Invalid response from Glama API\\\")\\n1080 | \\t\\t\\t}\\n1081 | \\t\\t} catch (error) {\\n1082 | \\t\\t\\tthis.log(\\n1083 | \\t\\t\\t\\t`Error exchanging code for API key: ${JSON.stringify(error, Object.getOwnPropertyNames(error), 2)}`,\\n1084 | \\t\\t\\t)\\n1085 | \\t\\t\\tthrow error\\n1086 | \\t\\t}\\n1087 | \\n1088 | \\t\\tconst { apiConfiguration, currentApiConfigName } = await this.getState()\\n1089 | \\n1090 | \\t\\tconst newConfiguration: ProviderSettings = {\\n1091 | \\t\\t\\t...apiConfiguration,\\n1092 | \\t\\t\\tapiProvider: \\\"glama\\\",\\n1093 | \\t\\t\\tglamaApiKey: apiKey,\\n1094 | \\t\\t\\tglamaModelId: apiConfiguration?.glamaModelId || glamaDefaultModelId,\\n1095 | \\t\\t}\\n1096 | \\n1097 | \\t\\tawait this.upsertProviderProfile(currentApiConfigName, newConfiguration)\\n1098 | \\t}\\n1099 | \\n1100 | \\t// Requesty\\n1101 | \\n1102 | \\tasync handleRequestyCallback(code: string) {\\n1103 | \\t\\tlet { apiConfiguration, currentApiConfigName } = await this.getState()\\n1104 | \\n1105 | \\t\\tconst newConfiguration: ProviderSettings = {\\n1106 | \\t\\t\\t...apiConfiguration,\\n1107 | \\t\\t\\tapiProvider: \\\"requesty\\\",\\n1108 | \\t\\t\\trequestyApiKey: code,\\n1109 | \\t\\t\\trequestyModelId: apiConfiguration?.requestyModelId || requestyDefaultModelId,\\n1110 | \\t\\t}\\n1111 | \\n1112 | \\t\\tawait this.upsertProviderProfile(currentApiConfigName, newConfiguration)\\n1113 | \\t}\\n1114 | \\n1115 | \\t// Task history\\n1116 | \\n1117 | \\tasync getTaskWithId(id: string): Promise<{\\n1118 | \\t\\thistoryItem: HistoryItem\\n1119 | \\t\\ttaskDirPath: string\\n1120 | \\t\\tapiConversationHistoryFilePath: string\\n1121 | \\t\\tuiMessagesFilePath: string\\n1122 | \\t\\tapiConversationHistory: Anthropic.MessageParam[]\\n1123 | \\t}> {\\n1124 | \\t\\tconst history = this.getGlobalState(\\\"taskHistory\\\") ?? []\\n1125 | \\t\\tconst historyItem = history.find((item) => item.id === id)\\n1126 | \\n1127 | \\t\\tif (historyItem) {\\n1128 | \\t\\t\\tconst { getTaskDirectoryPath } = await import(\\\"../../utils/storage\\\")\\n1129 | \\t\\t\\tconst globalStoragePath = this.contextProxy.globalStorageUri.fsPath\\n1130 | \\t\\t\\tconst taskDirPath = await getTaskDirectoryPath(globalStoragePath, id)\\n1131 | \\t\\t\\tconst apiConversationHistoryFilePath = path.join(taskDirPath, GlobalFileNames.apiConversationHistory)\\n1132 | \\t\\t\\tconst uiMessagesFilePath = path.join(taskDirPath, GlobalFileNames.uiMessages)\\n1133 | \\t\\t\\tconst fileExists = await fileExistsAtPath(apiConversationHistoryFilePath)\\n1134 | \\n1135 | \\t\\t\\tif (fileExists) {\\n1136 | \\t\\t\\t\\tconst apiConversationHistory = JSON.parse(await fs.readFile(apiConversationHistoryFilePath, \\\"utf8\\\"))\\n1137 | \\n1138 | \\t\\t\\t\\treturn {\\n1139 | \\t\\t\\t\\t\\thistoryItem,\\n1140 | \\t\\t\\t\\t\\ttaskDirPath,\\n1141 | \\t\\t\\t\\t\\tapiConversationHistoryFilePath,\\n1142 | \\t\\t\\t\\t\\tuiMessagesFilePath,\\n1143 | \\t\\t\\t\\t\\tapiConversationHistory,\\n1144 | \\t\\t\\t\\t}\\n1145 | \\t\\t\\t}\\n1146 | \\t\\t}\\n1147 | \\n1148 | \\t\\t// if we tried to get a task that doesn't exist, remove it from state\\n1149 | \\t\\t// FIXME: this seems to happen sometimes when the json file doesnt save to disk for some reason\\n1150 | \\t\\tawait this.deleteTaskFromState(id)\\n1151 | \\t\\tthrow new Error(\\\"Task not found\\\")\\n1152 | \\t}\\n1153 | \\n1154 | \\tasync showTaskWithId(id: string) {\\n1155 | \\t\\tif (id !== this.getCurrentCline()?.taskId) {\\n1156 | \\t\\t\\t// Non-current task.\\n1157 | \\t\\t\\tconst { historyItem } = await this.getTaskWithId(id)\\n1158 | \\t\\t\\tawait this.initClineWithHistoryItem(historyItem) // Clears existing task.\\n1159 | \\t\\t}\\n1160 | \\n1161 | \\t\\tawait this.postMessageToWebview({ type: \\\"action\\\", action: \\\"chatButtonClicked\\\" })\\n1162 | \\t}\\n1163 | \\n1164 | \\tasync exportTaskWithId(id: string) {\\n1165 | \\t\\tconst { historyItem, apiConversationHistory } = await this.getTaskWithId(id)\\n1166 | \\t\\tawait downloadTask(historyItem.ts, apiConversationHistory)\\n1167 | \\t}\\n1168 | \\n1169 | \\t/* Condenses a task's message history to use fewer tokens. */\\n1170 | \\tasync condenseTaskContext(taskId: string) {\\n1171 | \\t\\tlet task: Task | undefined\\n1172 | \\t\\tfor (let i = this.clineStack.length - 1; i >= 0; i--) {\\n1173 | \\t\\t\\tif (this.clineStack[i].taskId === taskId) {\\n1174 | \\t\\t\\t\\ttask = this.clineStack[i]\\n1175 | \\t\\t\\t\\tbreak\\n1176 | \\t\\t\\t}\\n1177 | \\t\\t}\\n1178 | \\t\\tif (!task) {\\n1179 | \\t\\t\\tthrow new Error(`Task with id ${taskId} not found in stack`)\\n1180 | \\t\\t}\\n1181 | \\t\\tawait task.condenseContext()\\n1182 | \\t\\tawait this.postMessageToWebview({ type: \\\"condenseTaskContextResponse\\\", text: taskId })\\n1183 | \\t}\\n1184 | \\n1185 | \\t// this function deletes a task from task hidtory, and deletes it's checkpoints and delete the task folder\\n1186 | \\tasync deleteTaskWithId(id: string) {\\n1187 | \\t\\ttry {\\n1188 | \\t\\t\\t// get the task directory full path\\n1189 | \\t\\t\\tconst { taskDirPath } = await this.getTaskWithId(id)\\n1190 | \\n1191 | \\t\\t\\t// remove task from stack if it's the current task\\n1192 | \\t\\t\\tif (id === this.getCurrentCline()?.taskId) {\\n1193 | \\t\\t\\t\\t// if we found the taskid to delete - call finish to abort this task and allow a new task to be started,\\n1194 | \\t\\t\\t\\t// if we are deleting a subtask and parent task is still waiting for subtask to finish - it allows the parent to resume (this case should neve exist)\\n1195 | \\t\\t\\t\\tawait this.finishSubTask(t(\\\"common:tasks.deleted\\\"))\\n1196 | \\t\\t\\t}\\n1197 | \\n1198 | \\t\\t\\t// delete task from the task history state\\n1199 | \\t\\t\\tawait this.deleteTaskFromState(id)\\n1200 | \\n1201 | \\t\\t\\t// Delete associated shadow repository or branch.\\n1202 | \\t\\t\\t// TODO: Store `workspaceDir` in the `HistoryItem` object.\\n1203 | \\t\\t\\tconst globalStorageDir = this.contextProxy.globalStorageUri.fsPath\\n1204 | \\t\\t\\tconst workspaceDir = this.cwd\\n1205 | \\n1206 | \\t\\t\\ttry {\\n1207 | \\t\\t\\t\\tawait ShadowCheckpointService.deleteTask({ taskId: id, globalStorageDir, workspaceDir })\\n1208 | \\t\\t\\t} catch (error) {\\n1209 | \\t\\t\\t\\tconsole.error(\\n1210 | \\t\\t\\t\\t\\t`[deleteTaskWithId${id}] failed to delete associated shadow repository or branch: ${error instanceof Error ? error.message : String(error)}`,\\n1211 | \\t\\t\\t\\t)\\n1212 | \\t\\t\\t}\\n1213 | \\n1214 | \\t\\t\\t// delete the entire task directory including checkpoints and all content\\n1215 | \\t\\t\\ttry {\\n1216 | \\t\\t\\t\\tawait fs.rm(taskDirPath, { recursive: true, force: true })\\n1217 | \\t\\t\\t\\tconsole.log(`[deleteTaskWithId${id}] removed task directory`)\\n1218 | \\t\\t\\t} catch (error) {\\n1219 | \\t\\t\\t\\tconsole.error(\\n1220 | \\t\\t\\t\\t\\t`[deleteTaskWithId${id}] failed to remove task directory: ${error instanceof Error ? error.message : String(error)}`,\\n1221 | \\t\\t\\t\\t)\\n1222 | \\t\\t\\t}\\n1223 | \\t\\t} catch (error) {\\n1224 | \\t\\t\\t// If task is not found, just remove it from state\\n1225 | \\t\\t\\tif (error instanceof Error && error.message === \\\"Task not found\\\") {\\n1226 | \\t\\t\\t\\tawait this.deleteTaskFromState(id)\\n1227 | \\t\\t\\t\\treturn\\n1228 | \\t\\t\\t}\\n1229 | \\t\\t\\tthrow error\\n1230 | \\t\\t}\\n1231 | \\t}\\n1232 | \\n1233 | \\tasync deleteTaskFromState(id: string) {\\n1234 | \\t\\tconst taskHistory = this.getGlobalState(\\\"taskHistory\\\") ?? []\\n1235 | \\t\\tconst updatedTaskHistory = taskHistory.filter((task) => task.id !== id)\\n1236 | \\t\\tawait this.updateGlobalState(\\\"taskHistory\\\", updatedTaskHistory)\\n1237 | \\t\\tawait this.postStateToWebview()\\n1238 | \\t}\\n1239 | \\n1240 | \\tasync postStateToWebview() {\\n1241 | \\t\\tconst state = await this.getStateToPostToWebview()\\n1242 | \\t\\tthis.postMessageToWebview({ type: \\\"state\\\", state })\\n1243 | \\n1244 | \\t\\t// Update VSCode context for experiments\\n1245 | \\t\\tawait this.updateVSCodeContext()\\n1246 | \\t}\\n1247 | \\n1248 | \\t/**\\n1249 | \\t * Updates VSCode context variables for experiments so they can be used in when clauses\\n1250 | \\t */\\n1251 | \\tprivate async updateVSCodeContext() {\\n1252 | \\t\\tconst { experiments } = await this.getState()\\n1253 | \\n1254 | \\t\\t// Set context for marketplace experiment\\n1255 | \\t\\tawait vscode.commands.executeCommand(\\n1256 | \\t\\t\\t\\\"setContext\\\",\\n1257 | \\t\\t\\t`${Package.name}.marketplaceEnabled`,\\n1258 | \\t\\t\\texperiments.marketplace ?? false,\\n1259 | \\t\\t)\\n1260 | \\t}\\n1261 | \\n1262 | \\t/**\\n1263 | \\t * Checks if there is a file-based system prompt override for the given mode\\n1264 | \\t */\\n1265 | \\tasync hasFileBasedSystemPromptOverride(mode: Mode): Promise<boolean> {\\n1266 | \\t\\tconst promptFilePath = getSystemPromptFilePath(this.cwd, mode)\\n1267 | \\t\\treturn await fileExistsAtPath(promptFilePath)\\n1268 | \\t}\\n1269 | \\n1270 | \\tasync getStateToPostToWebview() {\\n1271 | \\t\\tconst {\\n1272 | \\t\\t\\tapiConfiguration,\\n1273 | \\t\\t\\tlastShownAnnouncementId,\\n1274 | \\t\\t\\tcustomInstructions,\\n1275 | \\t\\t\\talwaysAllowReadOnly,\\n1276 | \\t\\t\\talwaysAllowReadOnlyOutsideWorkspace,\\n1277 | \\t\\t\\talwaysAllowWrite,\\n1278 | \\t\\t\\talwaysAllowWriteOutsideWorkspace,\\n1279 | \\t\\t\\talwaysAllowWriteProtected,\\n1280 | \\t\\t\\talwaysAllowExecute,\\n1281 | \\t\\t\\talwaysAllowBrowser,\\n1282 | \\t\\t\\talwaysAllowMcp,\\n1283 | \\t\\t\\talwaysAllowModeSwitch,\\n1284 | \\t\\t\\talwaysAllowSubtasks,\\n1285 | \\t\\t\\tallowedMaxRequests,\\n1286 | \\t\\t\\tautoCondenseContext,\\n1287 | \\t\\t\\tautoCondenseContextPercent,\\n1288 | \\t\\t\\tsoundEnabled,\\n1289 | \\t\\t\\tttsEnabled,\\n1290 | \\t\\t\\tttsSpeed,\\n1291 | \\t\\t\\tdiffEnabled,\\n1292 | \\t\\t\\tenableCheckpoints,\\n1293 | \\t\\t\\ttaskHistory,\\n1294 | \\t\\t\\tsoundVolume,\\n1295 | \\t\\t\\tbrowserViewportSize,\\n1296 | \\t\\t\\tscreenshotQuality,\\n1297 | \\t\\t\\tremoteBrowserHost,\\n1298 | \\t\\t\\tremoteBrowserEnabled,\\n1299 | \\t\\t\\tcachedChromeHostUrl,\\n1300 | \\t\\t\\twriteDelayMs,\\n1301 | \\t\\t\\tterminalOutputLineLimit,\\n1302 | \\t\\t\\tterminalShellIntegrationTimeout,\\n1303 | \\t\\t\\tterminalShellIntegrationDisabled,\\n1304 | \\t\\t\\tterminalCommandDelay,\\n1305 | \\t\\t\\tterminalPowershellCounter,\\n1306 | \\t\\t\\tterminalZshClearEolMark,\\n1307 | \\t\\t\\tterminalZshOhMy,\\n1308 | \\t\\t\\tterminalZshP10k,\\n1309 | \\t\\t\\tterminalZdotdir,\\n1310 | \\t\\t\\tfuzzyMatchThreshold,\\n1311 | \\t\\t\\tmcpEnabled,\\n1312 | \\t\\t\\tenableMcpServerCreation,\\n1313 | \\t\\t\\talwaysApproveResubmit,\\n1314 | \\t\\t\\trequestDelaySeconds,\\n1315 | \\t\\t\\tcurrentApiConfigName,\\n1316 | \\t\\t\\tlistApiConfigMeta,\\n1317 | \\t\\t\\tpinnedApiConfigs,\\n1318 | \\t\\t\\tmode,\\n1319 | \\t\\t\\tcustomModePrompts,\\n1320 | \\t\\t\\tcustomSupportPrompts,\\n1321 | \\t\\t\\tenhancementApiConfigId,\\n1322 | \\t\\t\\tautoApprovalEnabled,\\n1323 | \\t\\t\\tcustomModes,\\n1324 | \\t\\t\\texperiments,\\n1325 | \\t\\t\\tmaxOpenTabsContext,\\n1326 | \\t\\t\\tmaxWorkspaceFiles,\\n1327 | \\t\\t\\tbrowserToolEnabled,\\n1328 | \\t\\t\\ttelemetrySetting,\\n1329 | \\t\\t\\tshowRooIgnoredFiles,\\n1330 | \\t\\t\\tlanguage,\\n1331 | \\t\\t\\tmaxReadFileLine,\\n1332 | \\t\\t\\tterminalCompressProgressBar,\\n1333 | \\t\\t\\thistoryPreviewCollapsed,\\n1334 | \\t\\t\\tcloudUserInfo,\\n1335 | \\t\\t\\tcloudIsAuthenticated,\\n1336 | \\t\\t\\tsharingEnabled,\\n1337 | \\t\\t\\torganizationAllowList,\\n1338 | \\t\\t\\tmaxConcurrentFileReads,\\n1339 | \\t\\t\\tcondensingApiConfigId,\\n1340 | \\t\\t\\tcustomCondensingPrompt,\\n1341 | \\t\\t\\tcodebaseIndexConfig,\\n1342 | \\t\\t\\tcodebaseIndexModels,\\n1343 | \\t\\t} = await this.getState()\\n1344 | \\n1345 | \\t\\tconst telemetryKey = process.env.POSTHOG_API_KEY\\n1346 | \\t\\tconst machineId = vscode.env.machineId\\n1347 | \\t\\tconst allowedCommands = vscode.workspace.getConfiguration(Package.name).get<string[]>(\\\"allowedCommands\\\") || []\\n1348 | \\t\\tconst cwd = this.cwd\\n1349 | \\n1350 | \\t\\t// Only fetch marketplace data if the feature is enabled\\n1351 | \\t\\tlet marketplaceItems: any[] = []\\n1352 | \\t\\tlet marketplaceInstalledMetadata: any = { project: {}, global: {} }\\n1353 | \\n1354 | \\t\\tif (experiments.marketplace) {\\n1355 | \\t\\t\\tmarketplaceItems = (await this.marketplaceManager.getCurrentItems()) || []\\n1356 | \\t\\t\\tmarketplaceInstalledMetadata = await this.marketplaceManager.getInstallationMetadata()\\n1357 | \\t\\t}\\n1358 | \\n1359 | \\t\\t// Check if there's a system prompt override for the current mode\\n1360 | \\t\\tconst currentMode = mode ?? defaultModeSlug\\n1361 | \\t\\tconst hasSystemPromptOverride = await this.hasFileBasedSystemPromptOverride(currentMode)\\n1362 | \\n1363 | \\t\\treturn {\\n1364 | \\t\\t\\tversion: this.context.extension?.packageJSON?.version ?? \\\"\\\",\\n1365 | \\t\\t\\tmarketplaceItems,\\n1366 | \\t\\t\\tmarketplaceInstalledMetadata,\\n1367 | \\t\\t\\tapiConfiguration,\\n1368 | \\t\\t\\tcustomInstructions,\\n1369 | \\t\\t\\talwaysAllowReadOnly: alwaysAllowReadOnly ?? false,\\n1370 | \\t\\t\\talwaysAllowReadOnlyOutsideWorkspace: alwaysAllowReadOnlyOutsideWorkspace ?? false,\\n1371 | \\t\\t\\talwaysAllowWrite: alwaysAllowWrite ?? false,\\n1372 | \\t\\t\\talwaysAllowWriteOutsideWorkspace: alwaysAllowWriteOutsideWorkspace ?? false,\\n1373 | \\t\\t\\talwaysAllowWriteProtected: alwaysAllowWriteProtected ?? false,\\n1374 | \\t\\t\\talwaysAllowExecute: alwaysAllowExecute ?? false,\\n1375 | \\t\\t\\talwaysAllowBrowser: alwaysAllowBrowser ?? false,\\n1376 | \\t\\t\\talwaysAllowMcp: alwaysAllowMcp ?? false,\\n1377 | \\t\\t\\talwaysAllowModeSwitch: alwaysAllowModeSwitch ?? false,\\n1378 | \\t\\t\\talwaysAllowSubtasks: alwaysAllowSubtasks ?? false,\\n1379 | \\t\\t\\tallowedMaxRequests,\\n1380 | \\t\\t\\tautoCondenseContext: autoCondenseContext ?? true,\\n1381 | \\t\\t\\tautoCondenseContextPercent: autoCondenseContextPercent ?? 100,\\n1382 | \\t\\t\\turiScheme: vscode.env.uriScheme,\\n1383 | \\t\\t\\tcurrentTaskItem: this.getCurrentCline()?.taskId\\n1384 | \\t\\t\\t\\t? (taskHistory || []).find((item: HistoryItem) => item.id === this.getCurrentCline()?.taskId)\\n1385 | \\t\\t\\t\\t: undefined,\\n1386 | \\t\\t\\tclineMessages: this.getCurrentCline()?.clineMessages || [],\\n1387 | \\t\\t\\ttaskHistory: (taskHistory || [])\\n1388 | \\t\\t\\t\\t.filter((item: HistoryItem) => item.ts && item.task)\\n1389 | \\t\\t\\t\\t.sort((a: HistoryItem, b: HistoryItem) => b.ts - a.ts),\\n1390 | \\t\\t\\tsoundEnabled: soundEnabled ?? false,\\n1391 | \\t\\t\\tttsEnabled: ttsEnabled ?? false,\\n1392 | \\t\\t\\tttsSpeed: ttsSpeed ?? 1.0,\\n1393 | \\t\\t\\tdiffEnabled: diffEnabled ?? true,\\n1394 | \\t\\t\\tenableCheckpoints: enableCheckpoints ?? true,\\n1395 | \\t\\t\\tshouldShowAnnouncement:\\n1396 | \\t\\t\\t\\ttelemetrySetting !== \\\"unset\\\" && lastShownAnnouncementId !== this.latestAnnouncementId,\\n1397 | \\t\\t\\tallowedCommands,\\n1398 | \\t\\t\\tsoundVolume: soundVolume ?? 0.5,\\n1399 | \\t\\t\\tbrowserViewportSize: browserViewportSize ?? \\\"900x600\\\",\\n1400 | \\t\\t\\tscreenshotQuality: screenshotQuality ?? 75,\\n1401 | \\t\\t\\tremoteBrowserHost,\\n1402 | \\t\\t\\tremoteBrowserEnabled: remoteBrowserEnabled ?? false,\\n1403 | \\t\\t\\tcachedChromeHostUrl: cachedChromeHostUrl,\\n1404 | \\t\\t\\twriteDelayMs: writeDelayMs ?? 1000,\\n1405 | \\t\\t\\tterminalOutputLineLimit: terminalOutputLineLimit ?? 500,\\n1406 | \\t\\t\\tterminalShellIntegrationTimeout: terminalShellIntegrationTimeout ?? Terminal.defaultShellIntegrationTimeout,\\n1407 | \\t\\t\\tterminalShellIntegrationDisabled: terminalShellIntegrationDisabled ?? false,\\n1408 | \\t\\t\\tterminalCommandDelay: terminalCommandDelay ?? 0,\\n1409 | \\t\\t\\tterminalPowershellCounter: terminalPowershellCounter ?? false,\\n1410 | \\t\\t\\tterminalZshClearEolMark: terminalZshClearEolMark ?? true,\\n1411 | \\t\\t\\tterminalZshOhMy: terminalZshOhMy ?? false,\\n1412 | \\t\\t\\tterminalZshP10k: terminalZshP10k ?? false,\\n1413 | \\t\\t\\tterminalZdotdir: terminalZdotdir ?? false,\\n1414 | \\t\\t\\tfuzzyMatchThreshold: fuzzyMatchThreshold ?? 1.0,\\n1415 | \\t\\t\\tmcpEnabled: mcpEnabled ?? true,\\n1416 | \\t\\t\\tenableMcpServerCreation: enableMcpServerCreation ?? true,\\n1417 | \\t\\t\\talwaysApproveResubmit: alwaysApproveResubmit ?? false,\\n1418 | \\t\\t\\trequestDelaySeconds: requestDelaySeconds ?? 10,\\n1419 | \\t\\t\\tcurrentApiConfigName: currentApiConfigName ?? \\\"default\\\",\\n1420 | \\t\\t\\tlistApiConfigMeta: listApiConfigMeta ?? [],\\n1421 | \\t\\t\\tpinnedApiConfigs: pinnedApiConfigs ?? {},\\n1422 | \\t\\t\\tmode: mode ?? defaultModeSlug,\\n1423 | \\t\\t\\tcustomModePrompts: customModePrompts ?? {},\\n1424 | \\t\\t\\tcustomSupportPrompts: customSupportPrompts ?? {},\\n1425 | \\t\\t\\tenhancementApiConfigId,\\n1426 | \\t\\t\\tautoApprovalEnabled: autoApprovalEnabled ?? false,\\n1427 | \\t\\t\\tcustomModes,\\n1428 | \\t\\t\\texperiments: experiments ?? experimentDefault,\\n1429 | \\t\\t\\tmcpServers: this.mcpHub?.getAllServers() ?? [],\\n1430 | \\t\\t\\tmaxOpenTabsContext: maxOpenTabsContext ?? 20,\\n1431 | \\t\\t\\tmaxWorkspaceFiles: maxWorkspaceFiles ?? 200,\\n1432 | \\t\\t\\tcwd,\\n1433 | \\t\\t\\tbrowserToolEnabled: browserToolEnabled ?? true,\\n1434 | \\t\\t\\ttelemetrySetting,\\n1435 | \\t\\t\\ttelemetryKey,\\n1436 | \\t\\t\\tmachineId,\\n1437 | \\t\\t\\tshowRooIgnoredFiles: showRooIgnoredFiles ?? true,\\n1438 | \\t\\t\\tlanguage: language ?? formatLanguage(vscode.env.language),\\n1439 | \\t\\t\\trenderContext: this.renderContext,\\n1440 | \\t\\t\\tmaxReadFileLine: maxReadFileLine ?? -1,\\n1441 | \\t\\t\\tmaxConcurrentFileReads: maxConcurrentFileReads ?? 5,\\n1442 | \\t\\t\\tsettingsImportedAt: this.settingsImportedAt,\\n1443 | \\t\\t\\tterminalCompressProgressBar: terminalCompressProgressBar ?? true,\\n1444 | \\t\\t\\thasSystemPromptOverride,\\n1445 | \\t\\t\\thistoryPreviewCollapsed: historyPreviewCollapsed ?? false,\\n1446 | \\t\\t\\tcloudUserInfo,\\n1447 | \\t\\t\\tcloudIsAuthenticated: cloudIsAuthenticated ?? false,\\n1448 | \\t\\t\\tsharingEnabled: sharingEnabled ?? false,\\n1449 | \\t\\t\\torganizationAllowList,\\n1450 | \\t\\t\\tcondensingApiConfigId,\\n1451 | \\t\\t\\tcustomCondensingPrompt,\\n1452 | \\t\\t\\tcodebaseIndexModels: codebaseIndexModels ?? EMBEDDING_MODEL_PROFILES,\\n1453 | \\t\\t\\tcodebaseIndexConfig: codebaseIndexConfig ?? {\\n1454 | \\t\\t\\t\\tcodebaseIndexEnabled: false,\\n1455 | \\t\\t\\t\\tcodebaseIndexQdrantUrl: \\\"http://localhost:6333\\\",\\n1456 | \\t\\t\\t\\tcodebaseIndexEmbedderProvider: \\\"openai\\\",\\n1457 | \\t\\t\\t\\tcodebaseIndexEmbedderBaseUrl: \\\"\\\",\\n1458 | \\t\\t\\t\\tcodebaseIndexEmbedderModelId: \\\"\\\",\\n1459 | \\t\\t\\t},\\n1460 | \\t\\t}\\n1461 | \\t}\\n1462 | \\n1463 | \\t/**\\n1464 | \\t * Storage\\n1465 | \\t * https://dev.to/kompotkot/how-to-use-secretstorage-in-your-vscode-extensions-2hco\\n1466 | \\t * https://www.eliostruyf.com/devhack-code-extension-storage-options/\\n1467 | \\t */\\n1468 | \\n1469 | \\tasync getState() {\\n1470 | \\t\\tconst stateValues = this.contextProxy.getValues()\\n1471 | \\t\\tconst customModes = await this.customModesManager.getCustomModes()\\n1472 | \\n1473 | \\t\\t// Determine apiProvider with the same logic as before.\\n1474 | \\t\\tconst apiProvider: ProviderName = stateValues.apiProvider ? stateValues.apiProvider : \\\"anthropic\\\"\\n1475 | \\n1476 | \\t\\t// Build the apiConfiguration object combining state values and secrets.\\n1477 | \\t\\tconst providerSettings = this.contextProxy.getProviderSettings()\\n1478 | \\n1479 | \\t\\t// Ensure apiProvider is set properly if not already in state\\n1480 | \\t\\tif (!providerSettings.apiProvider) {\\n1481 | \\t\\t\\tproviderSettings.apiProvider = apiProvider\\n1482 | \\t\\t}\\n1483 | \\n1484 | \\t\\tlet organizationAllowList = ORGANIZATION_ALLOW_ALL\\n1485 | \\n1486 | \\t\\ttry {\\n1487 | \\t\\t\\torganizationAllowList = await CloudService.instance.getAllowList()\\n1488 | \\t\\t} catch (error) {\\n1489 | \\t\\t\\tconsole.error(\\n1490 | \\t\\t\\t\\t`[getState] failed to get organization allow list: ${error instanceof Error ? error.message : String(error)}`,\\n1491 | \\t\\t\\t)\\n1492 | \\t\\t}\\n1493 | \\n1494 | \\t\\tlet cloudUserInfo: CloudUserInfo | null = null\\n1495 | \\n1496 | \\t\\ttry {\\n1497 | \\t\\t\\tcloudUserInfo = CloudService.instance.getUserInfo()\\n1498 | \\t\\t} catch (error) {\\n1499 | \\t\\t\\tconsole.error(\\n1500 | \\t\\t\\t\\t`[getState] failed to get cloud user info: ${error instanceof Error ? error.message : String(error)}`,\\n1501 | \\t\\t\\t)\\n1502 | \\t\\t}\\n1503 | \\n1504 | \\t\\tlet cloudIsAuthenticated: boolean = false\\n1505 | \\n1506 | \\t\\ttry {\\n1507 | \\t\\t\\tcloudIsAuthenticated = CloudService.instance.isAuthenticated()\\n1508 | \\t\\t} catch (error) {\\n1509 | \\t\\t\\tconsole.error(\\n1510 | \\t\\t\\t\\t`[getState] failed to get cloud authentication state: ${error instanceof Error ? error.message : String(error)}`,\\n1511 | \\t\\t\\t)\\n1512 | \\t\\t}\\n1513 | \\n1514 | \\t\\tlet sharingEnabled: boolean = false\\n1515 | \\n1516 | \\t\\ttry {\\n1517 | \\t\\t\\tsharingEnabled = await CloudService.instance.canShareTask()\\n1518 | \\t\\t} catch (error) {\\n1519 | \\t\\t\\tconsole.error(\\n1520 | \\t\\t\\t\\t`[getState] failed to get sharing enabled state: ${error instanceof Error ? error.message : String(error)}`,\\n1521 | \\t\\t\\t)\\n1522 | \\t\\t}\\n1523 | \\n1524 | \\t\\t// Return the same structure as before\\n1525 | \\t\\treturn {\\n1526 | \\t\\t\\tapiConfiguration: providerSettings,\\n1527 | \\t\\t\\tlastShownAnnouncementId: stateValues.lastShownAnnouncementId,\\n1528 | \\t\\t\\tcustomInstructions: stateValues.customInstructions,\\n1529 | \\t\\t\\tapiModelId: stateValues.apiModelId,\\n1530 | \\t\\t\\talwaysAllowReadOnly: stateValues.alwaysAllowReadOnly ?? false,\\n1531 | \\t\\t\\talwaysAllowReadOnlyOutsideWorkspace: stateValues.alwaysAllowReadOnlyOutsideWorkspace ?? false,\\n1532 | \\t\\t\\talwaysAllowWrite: stateValues.alwaysAllowWrite ?? false,\\n1533 | \\t\\t\\talwaysAllowWriteOutsideWorkspace: stateValues.alwaysAllowWriteOutsideWorkspace ?? false,\\n1534 | \\t\\t\\talwaysAllowWriteProtected: stateValues.alwaysAllowWriteProtected ?? false,\\n1535 | \\t\\t\\talwaysAllowExecute: stateValues.alwaysAllowExecute ?? false,\\n1536 | \\t\\t\\talwaysAllowBrowser: stateValues.alwaysAllowBrowser ?? false,\\n1537 | \\t\\t\\talwaysAllowMcp: stateValues.alwaysAllowMcp ?? false,\\n1538 | \\t\\t\\talwaysAllowModeSwitch: stateValues.alwaysAllowModeSwitch ?? false,\\n1539 | \\t\\t\\talwaysAllowSubtasks: stateValues.alwaysAllowSubtasks ?? false,\\n1540 | \\t\\t\\tallowedMaxRequests: stateValues.allowedMaxRequests,\\n1541 | \\t\\t\\tautoCondenseContext: stateValues.autoCondenseContext ?? true,\\n1542 | \\t\\t\\tautoCondenseContextPercent: stateValues.autoCondenseContextPercent ?? 100,\\n1543 | \\t\\t\\ttaskHistory: stateValues.taskHistory,\\n1544 | \\t\\t\\tallowedCommands: stateValues.allowedCommands,\\n1545 | \\t\\t\\tsoundEnabled: stateValues.soundEnabled ?? false,\\n1546 | \\t\\t\\tttsEnabled: stateValues.ttsEnabled ?? false,\\n1547 | \\t\\t\\tttsSpeed: stateValues.ttsSpeed ?? 1.0,\\n1548 | \\t\\t\\tdiffEnabled: stateValues.diffEnabled ?? true,\\n1549 | \\t\\t\\tenableCheckpoints: stateValues.enableCheckpoints ?? true,\\n1550 | \\t\\t\\tsoundVolume: stateValues.soundVolume,\\n1551 | \\t\\t\\tbrowserViewportSize: stateValues.browserViewportSize ?? \\\"900x600\\\",\\n1552 | \\t\\t\\tscreenshotQuality: stateValues.screenshotQuality ?? 75,\\n1553 | \\t\\t\\tremoteBrowserHost: stateValues.remoteBrowserHost,\\n1554 | \\t\\t\\tremoteBrowserEnabled: stateValues.remoteBrowserEnabled ?? false,\\n1555 | \\t\\t\\tcachedChromeHostUrl: stateValues.cachedChromeHostUrl as string | undefined,\\n1556 | \\t\\t\\tfuzzyMatchThreshold: stateValues.fuzzyMatchThreshold ?? 1.0,\\n1557 | \\t\\t\\twriteDelayMs: stateValues.writeDelayMs ?? 1000,\\n1558 | \\t\\t\\tterminalOutputLineLimit: stateValues.terminalOutputLineLimit ?? 500,\\n1559 | \\t\\t\\tterminalShellIntegrationTimeout:\\n1560 | \\t\\t\\t\\tstateValues.terminalShellIntegrationTimeout ?? Terminal.defaultShellIntegrationTimeout,\\n1561 | \\t\\t\\tterminalShellIntegrationDisabled: stateValues.terminalShellIntegrationDisabled ?? false,\\n1562 | \\t\\t\\tterminalCommandDelay: stateValues.terminalCommandDelay ?? 0,\\n1563 | \\t\\t\\tterminalPowershellCounter: stateValues.terminalPowershellCounter ?? false,\\n1564 | \\t\\t\\tterminalZshClearEolMark: stateValues.terminalZshClearEolMark ?? true,\\n1565 | \\t\\t\\tterminalZshOhMy: stateValues.terminalZshOhMy ?? false,\\n1566 | \\t\\t\\tterminalZshP10k: stateValues.terminalZshP10k ?? false,\\n1567 | \\t\\t\\tterminalZdotdir: stateValues.terminalZdotdir ?? false,\\n1568 | \\t\\t\\tterminalCompressProgressBar: stateValues.terminalCompressProgressBar ?? true,\\n1569 | \\t\\t\\tmode: stateValues.mode ?? defaultModeSlug,\\n1570 | \\t\\t\\tlanguage: stateValues.language ?? formatLanguage(vscode.env.language),\\n1571 | \\t\\t\\tmcpEnabled: stateValues.mcpEnabled ?? true,\\n1572 | \\t\\t\\tenableMcpServerCreation: stateValues.enableMcpServerCreation ?? true,\\n1573 | \\t\\t\\talwaysApproveResubmit: stateValues.alwaysApproveResubmit ?? false,\\n1574 | \\t\\t\\trequestDelaySeconds: Math.max(5, stateValues.requestDelaySeconds ?? 10),\\n1575 | \\t\\t\\tcurrentApiConfigName: stateValues.currentApiConfigName ?? \\\"default\\\",\\n1576 | \\t\\t\\tlistApiConfigMeta: stateValues.listApiConfigMeta ?? [],\\n1577 | \\t\\t\\tpinnedApiConfigs: stateValues.pinnedApiConfigs ?? {},\\n1578 | \\t\\t\\tmodeApiConfigs: stateValues.modeApiConfigs ?? ({} as Record<Mode, string>),\\n1579 | \\t\\t\\tcustomModePrompts: stateValues.customModePrompts ?? {},\\n1580 | \\t\\t\\tcustomSupportPrompts: stateValues.customSupportPrompts ?? {},\\n1581 | \\t\\t\\tenhancementApiConfigId: stateValues.enhancementApiConfigId,\\n1582 | \\t\\t\\texperiments: stateValues.experiments ?? experimentDefault,\\n1583 | \\t\\t\\tautoApprovalEnabled: stateValues.autoApprovalEnabled ?? false,\\n1584 | \\t\\t\\tcustomModes,\\n1585 | \\t\\t\\tmaxOpenTabsContext: stateValues.maxOpenTabsContext ?? 20,\\n1586 | \\t\\t\\tmaxWorkspaceFiles: stateValues.maxWorkspaceFiles ?? 200,\\n1587 | \\t\\t\\topenRouterUseMiddleOutTransform: stateValues.openRouterUseMiddleOutTransform ?? true,\\n1588 | \\t\\t\\tbrowserToolEnabled: stateValues.browserToolEnabled ?? true,\\n1589 | \\t\\t\\ttelemetrySetting: stateValues.telemetrySetting || \\\"unset\\\",\\n1590 | \\t\\t\\tshowRooIgnoredFiles: stateValues.showRooIgnoredFiles ?? true,\\n1591 | \\t\\t\\tmaxReadFileLine: stateValues.maxReadFileLine ?? -1,\\n1592 | \\t\\t\\tmaxConcurrentFileReads: stateValues.maxConcurrentFileReads ?? 5,\\n1593 | \\t\\t\\thistoryPreviewCollapsed: stateValues.historyPreviewCollapsed ?? false,\\n1594 | \\t\\t\\tcloudUserInfo,\\n1595 | \\t\\t\\tcloudIsAuthenticated,\\n1596 | \\t\\t\\tsharingEnabled,\\n1597 | \\t\\t\\torganizationAllowList,\\n1598 | \\t\\t\\t// Explicitly add condensing settings\\n1599 | \\t\\t\\tcondensingApiConfigId: stateValues.condensingApiConfigId,\\n1600 | \\t\\t\\tcustomCondensingPrompt: stateValues.customCondensingPrompt,\\n1601 | \\t\\t\\tcodebaseIndexModels: stateValues.codebaseIndexModels ?? EMBEDDING_MODEL_PROFILES,\\n1602 | \\t\\t\\tcodebaseIndexConfig: stateValues.codebaseIndexConfig ?? {\\n1603 | \\t\\t\\t\\tcodebaseIndexEnabled: false,\\n1604 | \\t\\t\\t\\tcodebaseIndexQdrantUrl: \\\"http://localhost:6333\\\",\\n1605 | \\t\\t\\t\\tcodebaseIndexEmbedderProvider: \\\"openai\\\",\\n1606 | \\t\\t\\t\\tcodebaseIndexEmbedderBaseUrl: \\\"\\\",\\n1607 | \\t\\t\\t\\tcodebaseIndexEmbedderModelId: \\\"\\\",\\n1608 | \\t\\t\\t},\\n1609 | \\t\\t}\\n1610 | \\t}\\n1611 | \\n1612 | \\tasync updateTaskHistory(item: HistoryItem): Promise<HistoryItem[]> {\\n1613 | \\t\\tconst history = (this.getGlobalState(\\\"taskHistory\\\") as HistoryItem[] | undefined) || []\\n1614 | \\t\\tconst existingItemIndex = history.findIndex((h) => h.id === item.id)\\n1615 | \\n1616 | \\t\\tif (existingItemIndex !== -1) {\\n1617 | \\t\\t\\thistory[existingItemIndex] = item\\n1618 | \\t\\t} else {\\n1619 | \\t\\t\\thistory.push(item)\\n1620 | \\t\\t}\\n1621 | \\n1622 | \\t\\tawait this.updateGlobalState(\\\"taskHistory\\\", history)\\n1623 | \\t\\treturn history\\n1624 | \\t}\\n1625 | \\n1626 | \\t// ContextProxy\\n1627 | \\n1628 | \\t// @deprecated - Use `ContextProxy#setValue` instead.\\n1629 | \\tprivate async updateGlobalState<K extends keyof GlobalState>(key: K, value: GlobalState[K]) {\\n1630 | \\t\\tawait this.contextProxy.setValue(key, value)\\n1631 | \\t}\\n1632 | \\n1633 | \\t// @deprecated - Use `ContextProxy#getValue` instead.\\n1634 | \\tprivate getGlobalState<K extends keyof GlobalState>(key: K) {\\n1635 | \\t\\treturn this.contextProxy.getValue(key)\\n1636 | \\t}\\n1637 | \\n1638 | \\tpublic async setValue<K extends keyof RooCodeSettings>(key: K, value: RooCodeSettings[K]) {\\n1639 | \\t\\tawait this.contextProxy.setValue(key, value)\\n1640 | \\t}\\n1641 | \\n1642 | \\tpublic getValue<K extends keyof RooCodeSettings>(key: K) {\\n1643 | \\t\\treturn this.contextProxy.getValue(key)\\n1644 | \\t}\\n1645 | \\n1646 | \\tpublic getValues() {\\n1647 | \\t\\treturn this.contextProxy.getValues()\\n1648 | \\t}\\n1649 | \\n1650 | \\tpublic async setValues(values: RooCodeSettings) {\\n1651 | \\t\\tawait this.contextProxy.setValues(values)\\n1652 | \\t}\\n1653 | \\n1654 | \\t// cwd\\n1655 | \\n1656 | \\tget cwd() {\\n1657 | \\t\\treturn getWorkspacePath()\\n1658 | \\t}\\n1659 | \\n1660 | \\t// dev\\n1661 | \\n1662 | \\tasync resetState() {\\n1663 | \\t\\tconst answer = await vscode.window.showInformationMessage(\\n1664 | \\t\\t\\tt(\\\"common:confirmation.reset_state\\\"),\\n1665 | \\t\\t\\t{ modal: true },\\n1666 | \\t\\t\\tt(\\\"common:answers.yes\\\"),\\n1667 | \\t\\t)\\n1668 | \\n1669 | \\t\\tif (answer !== t(\\\"common:answers.yes\\\")) {\\n1670 | \\t\\t\\treturn\\n1671 | \\t\\t}\\n1672 | \\n1673 | \\t\\tawait this.contextProxy.resetAllState()\\n1674 | \\t\\tawait this.providerSettingsManager.resetAllConfigs()\\n1675 | \\t\\tawait this.customModesManager.resetCustomModes()\\n1676 | \\t\\tawait this.removeClineFromStack()\\n1677 | \\t\\tawait this.postStateToWebview()\\n1678 | \\t\\tawait this.postMessageToWebview({ type: \\\"action\\\", action: \\\"chatButtonClicked\\\" })\\n1679 | \\t}\\n1680 | \\n1681 | \\t// logging\\n1682 | \\n1683 | \\tpublic log(message: string) {\\n1684 | \\t\\tthis.outputChannel.appendLine(message)\\n1685 | \\t\\tconsole.log(message)\\n1686 | \\t}\\n1687 | \\n1688 | \\t// integration tests\\n1689 | \\n1690 | \\tget viewLaunched() {\\n1691 | \\t\\treturn this.isViewLaunched\\n1692 | \\t}\\n1693 | \\n1694 | \\tget messages() {\\n1695 | \\t\\treturn this.getCurrentCline()?.clineMessages || []\\n1696 | \\t}\\n1697 | \\n1698 | \\t// Add public getter\\n1699 | \\tpublic getMcpHub(): McpHub | undefined {\\n1700 | \\t\\treturn this.mcpHub\\n1701 | \\t}\\n1702 | \\n1703 | \\t/**\\n1704 | \\t * Returns properties to be included in every telemetry event\\n1705 | \\t * This method is called by the telemetry service to get context information\\n1706 | \\t * like the current mode, API provider, etc.\\n1707 | \\t */\\n1708 | \\tpublic async getTelemetryProperties(): Promise<TelemetryProperties> {\\n1709 | \\t\\tconst { mode, apiConfiguration, language } = await this.getState()\\n1710 | \\t\\tconst task = this.getCurrentCline()\\n1711 | \\n1712 | \\t\\tconst packageJSON = this.context.extension?.packageJSON\\n1713 | \\n1714 | \\t\\treturn {\\n1715 | \\t\\t\\tappName: packageJSON?.name ?? Package.name,\\n1716 | \\t\\t\\tappVersion: packageJSON?.version ?? Package.version,\\n1717 | \\t\\t\\tvscodeVersion: vscode.version,\\n1718 | \\t\\t\\tplatform: process.platform,\\n1719 | \\t\\t\\teditorName: vscode.env.appName,\\n1720 | \\t\\t\\tlanguage,\\n1721 | \\t\\t\\tmode,\\n1722 | \\t\\t\\tapiProvider: apiConfiguration?.apiProvider,\\n1723 | \\t\\t\\tmodelId: task?.api?.getModel().id,\\n1724 | \\t\\t\\tdiffStrategy: task?.diffStrategy?.getName(),\\n1725 | \\t\\t\\tisSubtask: task ? !!task.parentTask : undefined,\\n1726 | \\t\\t}\\n1727 | \\t}\\n1728 | }\\n</content>\\n</file>\\n</files>\\n\\nLoading...\"}"
}
[2025-06-16T20:27:05.588Z] {
  "ts": 1750105624749,
  "type": "say",
  "say": "text",
  "text": "Now let me search for context management and token handling to understand where I should implement the context overflow contingency feature.",
  "partial": false
}
[2025-06-16T20:27:06.289Z] {
  "ts": 1750105625588,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"searchFiles\",\"path\":\"src\",\"regex\":\"context.*overflow|token.*overflow|context.*window|truncate.*conversation\",\"filePattern\":\"*.ts\",\"isOutsideWorkspace\":false,\"content\":\"Found 31 results.\\n\\n# src/extension.ts\\n146 | \\n147 | \\tcontext.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))\\n148 | \\n----\\n\\n# src/api/providers/bedrock.ts\\n436 | \\t\\t\\t\\t\\t\\t//update the in-use model info to be based on the invoked Model Id for the router\\n437 | \\t\\t\\t\\t\\t\\t//so that pricing, context window, caching etc have values that can be used\\n438 | \\t\\t\\t\\t\\t\\t//However, we want to keep the id of the model to be the ID for the router for\\n----\\n1052 | Possible Causes:\\n1053 | 1. Input exceeds model's context window limit\\n1054 | 2. Rate limiting (too many tokens per minute)\\n----\\n1060 | 2. Split your request into smaller chunks\\n1061 | 3. Use a model with a larger context window\\n1062 | 4. If rate limited, reduce request frequency\\n----\\n\\n# src/api/providers/fetchers/requesty.ts\\n 32 | \\t\\t\\t\\tmaxTokens: rawModel.max_output_tokens,\\n 33 | \\t\\t\\t\\tcontextWindow: rawModel.context_window,\\n 34 | \\t\\t\\t\\tsupportsPromptCache: rawModel.supports_caching,\\n----\\n\\n# src/api/transform/cache-strategy/types.ts\\n  9 | \\tmaxTokens: number\\n 10 | \\t/** Maximum context window size in tokens */\\n 11 | \\tcontextWindow: number\\n----\\n\\n# src/shared/embeddingModels.ts\\n  8 | \\tdimension: number\\n  9 | \\t// Add other model-specific properties if needed, e.g., context window size\\n 10 | }\\n----\\n\\n# src/core/sliding-window/__tests__/sliding-window.test.ts\\n251 | \\n252 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n253 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n282 | \\n283 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n284 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n321 | \\n322 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n323 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n487 | \\n488 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n489 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n705 | \\t\\t\\tconst contextWindow = modelInfo.contextWindow\\n706 | \\t\\t\\tconst totalTokens = 60000 // Below allowedTokens but 60% of context window\\n707 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n755 | \\t\\t\\tconst contextWindow = modelInfo.contextWindow\\n756 | \\t\\t\\tconst totalTokens = 40000 // 40% of context window\\n757 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n813 | \\n814 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n815 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n819 | \\n820 | \\t\\t\\t// Account for the dynamic buffer which is 10% of context window (10,000 tokens)\\n821 | \\t\\t\\t// Below max tokens and buffer - no truncation\\n----\\n858 | \\n859 | \\t\\tit(\\\"should use 20% of context window as buffer when maxTokens is undefined\\\", async () => {\\n860 | \\t\\t\\tconst modelInfo = createModelInfo(100000, undefined)\\n----\\n862 | \\n863 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n864 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n868 | \\n869 | \\t\\t\\t// Account for the dynamic buffer which is 10% of context window (10,000 tokens)\\n870 | \\t\\t\\t// Below max tokens and buffer - no truncation\\n----\\n907 | \\n908 | \\t\\tit(\\\"should handle small context windows appropriately\\\", async () => {\\n909 | \\t\\t\\tconst modelInfo = createModelInfo(50000, 10000)\\n----\\n911 | \\n912 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n913 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n947 | \\n948 | \\t\\tit(\\\"should handle large context windows appropriately\\\", async () => {\\n949 | \\t\\t\\tconst modelInfo = createModelInfo(200000, 30000)\\n----\\n951 | \\n952 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n953 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n957 | \\n958 | \\t\\t\\t// Account for the dynamic buffer which is 10% of context window (20,000 tokens for this test)\\n959 | \\t\\t\\t// Below max tokens and buffer - no truncation\\n----\\n\\n# src/core/sliding-window/index.ts\\n  9 | /**\\n 10 |  * Default percentage of the context window to use as a buffer when deciding when to truncate\\n 11 |  */\\n----\\n 37 |  * @param {string} taskId - The task ID for the conversation, used for telemetry\\n 38 |  * @returns {ApiMessage[]} The truncated conversation messages.\\n 39 |  */\\n----\\n 51 | /**\\n 52 |  * Conditionally truncates the conversation messages if the total token count\\n 53 |  * exceeds the model's limit, considering the size of incoming content.\\n----\\n 56 |  * @param {number} totalTokens - The total number of tokens in the conversation (excluding the last user message).\\n 57 |  * @param {number} contextWindow - The context window size.\\n 58 |  * @param {number} maxTokens - The maximum number of tokens allowed.\\n----\\n 61 |  * @param {string} systemPrompt - The system prompt, used for estimating the new context size after summarizing.\\n 62 |  * @returns {ApiMessage[]} The original or truncated conversation messages.\\n 63 |  */\\n----\\n 81 | /**\\n 82 |  * Conditionally truncates the conversation messages if the total token count\\n 83 |  * exceeds the model's limit, considering the size of incoming content.\\n----\\n 85 |  * @param {TruncateOptions} options - The options for truncation\\n 86 |  * @returns {Promise<ApiMessage[]>} The original or truncated conversation messages.\\n 87 |  */\\n----\\n116 | \\t// Calculate available tokens for conversation history\\n117 | \\t// Truncate if we're within TOKEN_BUFFER_PERCENTAGE of the context window\\n118 | \\tconst allowedTokens = contextWindow * (1 - TOKEN_BUFFER_PERCENTAGE) - reservedTokens\\n----\"}",
  "partial": false,
  "isProtected": false
}
[2025-06-16T20:27:06.693Z] {
  "ts": 1750105626684,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[search_files for 'context.*overflow|token.*overflow|context.*window|truncate.*conversation' in '*.ts'] Result:\\n\\nFound 31 results.\\n\\n# src/extension.ts\\n146 | \\n147 | \\tcontext.subscriptions.push(vscode.window.registerUriHandler({ handleUri }))\\n148 | \\n----\\n\\n# src/api/providers/bedrock.ts\\n436 | \\t\\t\\t\\t\\t\\t//update the in-use model info to be based on the invoked Model Id for the router\\n437 | \\t\\t\\t\\t\\t\\t//so that pricing, context window, caching etc have values that can be used\\n438 | \\t\\t\\t\\t\\t\\t//However, we want to keep the id of the model to be the ID for the router for\\n----\\n1052 | Possible Causes:\\n1053 | 1. Input exceeds model's context window limit\\n1054 | 2. Rate limiting (too many tokens per minute)\\n----\\n1060 | 2. Split your request into smaller chunks\\n1061 | 3. Use a model with a larger context window\\n1062 | 4. If rate limited, reduce request frequency\\n----\\n\\n# src/api/providers/fetchers/requesty.ts\\n 32 | \\t\\t\\t\\tmaxTokens: rawModel.max_output_tokens,\\n 33 | \\t\\t\\t\\tcontextWindow: rawModel.context_window,\\n 34 | \\t\\t\\t\\tsupportsPromptCache: rawModel.supports_caching,\\n----\\n\\n# src/api/transform/cache-strategy/types.ts\\n  9 | \\tmaxTokens: number\\n 10 | \\t/** Maximum context window size in tokens */\\n 11 | \\tcontextWindow: number\\n----\\n\\n# src/shared/embeddingModels.ts\\n  8 | \\tdimension: number\\n  9 | \\t// Add other model-specific properties if needed, e.g., context window size\\n 10 | }\\n----\\n\\n# src/core/sliding-window/__tests__/sliding-window.test.ts\\n251 | \\n252 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n253 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n282 | \\n283 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n284 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n321 | \\n322 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n323 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n487 | \\n488 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n489 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n705 | \\t\\t\\tconst contextWindow = modelInfo.contextWindow\\n706 | \\t\\t\\tconst totalTokens = 60000 // Below allowedTokens but 60% of context window\\n707 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n755 | \\t\\t\\tconst contextWindow = modelInfo.contextWindow\\n756 | \\t\\t\\tconst totalTokens = 40000 // 40% of context window\\n757 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n813 | \\n814 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n815 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n819 | \\n820 | \\t\\t\\t// Account for the dynamic buffer which is 10% of context window (10,000 tokens)\\n821 | \\t\\t\\t// Below max tokens and buffer - no truncation\\n----\\n858 | \\n859 | \\t\\tit(\\\"should use 20% of context window as buffer when maxTokens is undefined\\\", async () => {\\n860 | \\t\\t\\tconst modelInfo = createModelInfo(100000, undefined)\\n----\\n862 | \\n863 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n864 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n868 | \\n869 | \\t\\t\\t// Account for the dynamic buffer which is 10% of context window (10,000 tokens)\\n870 | \\t\\t\\t// Below max tokens and buffer - no truncation\\n----\\n907 | \\n908 | \\t\\tit(\\\"should handle small context windows appropriately\\\", async () => {\\n909 | \\t\\t\\tconst modelInfo = createModelInfo(50000, 10000)\\n----\\n911 | \\n912 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n913 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n947 | \\n948 | \\t\\tit(\\\"should handle large context windows appropriately\\\", async () => {\\n949 | \\t\\t\\tconst modelInfo = createModelInfo(200000, 30000)\\n----\\n951 | \\n952 | \\t\\t\\t// Create messages with very small content in the last one to avoid token overflow\\n953 | \\t\\t\\tconst messagesWithSmallContent = [\\n----\\n957 | \\n958 | \\t\\t\\t// Account for the dynamic buffer which is 10% of context window (20,000 tokens for this test)\\n959 | \\t\\t\\t// Below max tokens and buffer - no truncation\\n----\\n\\n# src/core/sliding-window/index.ts\\n  9 | /**\\n 10 |  * Default percentage of the context window to use as a buffer when deciding when to truncate\\n 11 |  */\\n----\\n 37 |  * @param {string} taskId - The task ID for the conversation, used for telemetry\\n 38 |  * @returns {ApiMessage[]} The truncated conversation messages.\\n 39 |  */\\n----\\n 51 | /**\\n 52 |  * Conditionally truncates the conversation messages if the total token count\\n 53 |  * exceeds the model's limit, considering the size of incoming content.\\n----\\n 56 |  * @param {number} totalTokens - The total number of tokens in the conversation (excluding the last user message).\\n 57 |  * @param {number} contextWindow - The context window size.\\n 58 |  * @param {number} maxTokens - The maximum number of tokens allowed.\\n----\\n 61 |  * @param {string} systemPrompt - The system prompt, used for estimating the new context size after summarizing.\\n 62 |  * @returns {ApiMessage[]} The original or truncated conversation messages.\\n 63 |  */\\n----\\n 81 | /**\\n 82 |  * Conditionally truncates the conversation messages if the total token count\\n 83 |  * exceeds the model's limit, considering the size of incoming content.\\n----\\n 85 |  * @param {TruncateOptions} options - The options for truncation\\n 86 |  * @returns {Promise<ApiMessage[]>} The original or truncated conversation messages.\\n 87 |  */\\n----\\n116 | \\t// Calculate available tokens for conversation history\\n117 | \\t// Truncate if we're within TOKEN_BUFFER_PERCENTAGE of the context window\\n118 | \\tconst allowedTokens = contextWindow * (1 - TOKEN_BUFFER_PERCENTAGE) - reservedTokens\\n----\\n\\nLoading...\"}"
}
[2025-06-16T20:27:10.056Z] {
  "ts": 1750105629421,
  "type": "say",
  "say": "text",
  "text": "Now let me examine the sliding window implementation and the mode configuration to understand how to implement the context overflow contingency feature.",
  "partial": false
}
[2025-06-16T20:27:10.794Z] {
  "ts": 1750105630056,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"readFile\",\"batchFiles\":[{\"path\":\"src/core/sliding-window/index.ts\",\"lineSnippet\":\"\",\"isOutsideWorkspace\":false,\"key\":\"src/core/sliding-window/index.ts\",\"content\":\"/roo/repos/Roo-Code/src/core/sliding-window/index.ts\"},{\"path\":\"packages/types/src/mode.ts\",\"lineSnippet\":\"\",\"isOutsideWorkspace\":false,\"key\":\"packages/types/src/mode.ts\",\"content\":\"/roo/repos/Roo-Code/packages/types/src/mode.ts\"}]}",
  "partial": false
}
[2025-06-16T20:27:11.061Z] {
  "ts": 1750105631051,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[read_file for 'src/core/sliding-window/index.ts', 'packages/types/src/mode.ts'] Result:\\n\\n<files>\\n<file><path>src/core/sliding-window/index.ts</path>\\n<content lines=\\\"1-150\\\">\\n  1 | import { Anthropic } from \\\"@anthropic-ai/sdk\\\"\\n  2 | \\n  3 | import { TelemetryService } from \\\"@roo-code/telemetry\\\"\\n  4 | \\n  5 | import { ApiHandler } from \\\"../../api\\\"\\n  6 | import { summarizeConversation, SummarizeResponse } from \\\"../condense\\\"\\n  7 | import { ApiMessage } from \\\"../task-persistence/apiMessages\\\"\\n  8 | \\n  9 | /**\\n 10 |  * Default percentage of the context window to use as a buffer when deciding when to truncate\\n 11 |  */\\n 12 | export const TOKEN_BUFFER_PERCENTAGE = 0.1\\n 13 | \\n 14 | /**\\n 15 |  * Counts tokens for user content using the provider's token counting implementation.\\n 16 |  *\\n 17 |  * @param {Array<Anthropic.Messages.ContentBlockParam>} content - The content to count tokens for\\n 18 |  * @param {ApiHandler} apiHandler - The API handler to use for token counting\\n 19 |  * @returns {Promise<number>} A promise resolving to the token count\\n 20 |  */\\n 21 | export async function estimateTokenCount(\\n 22 | \\tcontent: Array<Anthropic.Messages.ContentBlockParam>,\\n 23 | \\tapiHandler: ApiHandler,\\n 24 | ): Promise<number> {\\n 25 | \\tif (!content || content.length === 0) return 0\\n 26 | \\treturn apiHandler.countTokens(content)\\n 27 | }\\n 28 | \\n 29 | /**\\n 30 |  * Truncates a conversation by removing a fraction of the messages.\\n 31 |  *\\n 32 |  * The first message is always retained, and a specified fraction (rounded to an even number)\\n 33 |  * of messages from the beginning (excluding the first) is removed.\\n 34 |  *\\n 35 |  * @param {ApiMessage[]} messages - The conversation messages.\\n 36 |  * @param {number} fracToRemove - The fraction (between 0 and 1) of messages (excluding the first) to remove.\\n 37 |  * @param {string} taskId - The task ID for the conversation, used for telemetry\\n 38 |  * @returns {ApiMessage[]} The truncated conversation messages.\\n 39 |  */\\n 40 | export function truncateConversation(messages: ApiMessage[], fracToRemove: number, taskId: string): ApiMessage[] {\\n 41 | \\tTelemetryService.instance.captureSlidingWindowTruncation(taskId)\\n 42 | \\tconst truncatedMessages = [messages[0]]\\n 43 | \\tconst rawMessagesToRemove = Math.floor((messages.length - 1) * fracToRemove)\\n 44 | \\tconst messagesToRemove = rawMessagesToRemove - (rawMessagesToRemove % 2)\\n 45 | \\tconst remainingMessages = messages.slice(messagesToRemove + 1)\\n 46 | \\ttruncatedMessages.push(...remainingMessages)\\n 47 | \\n 48 | \\treturn truncatedMessages\\n 49 | }\\n 50 | \\n 51 | /**\\n 52 |  * Conditionally truncates the conversation messages if the total token count\\n 53 |  * exceeds the model's limit, considering the size of incoming content.\\n 54 |  *\\n 55 |  * @param {ApiMessage[]} messages - The conversation messages.\\n 56 |  * @param {number} totalTokens - The total number of tokens in the conversation (excluding the last user message).\\n 57 |  * @param {number} contextWindow - The context window size.\\n 58 |  * @param {number} maxTokens - The maximum number of tokens allowed.\\n 59 |  * @param {ApiHandler} apiHandler - The API handler to use for token counting.\\n 60 |  * @param {boolean} autoCondenseContext - Whether to use LLM summarization or sliding window implementation\\n 61 |  * @param {string} systemPrompt - The system prompt, used for estimating the new context size after summarizing.\\n 62 |  * @returns {ApiMessage[]} The original or truncated conversation messages.\\n 63 |  */\\n 64 | \\n 65 | type TruncateOptions = {\\n 66 | \\tmessages: ApiMessage[]\\n 67 | \\ttotalTokens: number\\n 68 | \\tcontextWindow: number\\n 69 | \\tmaxTokens?: number | null\\n 70 | \\tapiHandler: ApiHandler\\n 71 | \\tautoCondenseContext: boolean\\n 72 | \\tautoCondenseContextPercent: number\\n 73 | \\tsystemPrompt: string\\n 74 | \\ttaskId: string\\n 75 | \\tcustomCondensingPrompt?: string\\n 76 | \\tcondensingApiHandler?: ApiHandler\\n 77 | }\\n 78 | \\n 79 | type TruncateResponse = SummarizeResponse & { prevContextTokens: number }\\n 80 | \\n 81 | /**\\n 82 |  * Conditionally truncates the conversation messages if the total token count\\n 83 |  * exceeds the model's limit, considering the size of incoming content.\\n 84 |  *\\n 85 |  * @param {TruncateOptions} options - The options for truncation\\n 86 |  * @returns {Promise<ApiMessage[]>} The original or truncated conversation messages.\\n 87 |  */\\n 88 | export async function truncateConversationIfNeeded({\\n 89 | \\tmessages,\\n 90 | \\ttotalTokens,\\n 91 | \\tcontextWindow,\\n 92 | \\tmaxTokens,\\n 93 | \\tapiHandler,\\n 94 | \\tautoCondenseContext,\\n 95 | \\tautoCondenseContextPercent,\\n 96 | \\tsystemPrompt,\\n 97 | \\ttaskId,\\n 98 | \\tcustomCondensingPrompt,\\n 99 | \\tcondensingApiHandler,\\n100 | }: TruncateOptions): Promise<TruncateResponse> {\\n101 | \\tlet error: string | undefined\\n102 | \\tlet cost = 0\\n103 | \\t// Calculate the maximum tokens reserved for response\\n104 | \\tconst reservedTokens = maxTokens || contextWindow * 0.2\\n105 | \\n106 | \\t// Estimate tokens for the last message (which is always a user message)\\n107 | \\tconst lastMessage = messages[messages.length - 1]\\n108 | \\tconst lastMessageContent = lastMessage.content\\n109 | \\tconst lastMessageTokens = Array.isArray(lastMessageContent)\\n110 | \\t\\t? await estimateTokenCount(lastMessageContent, apiHandler)\\n111 | \\t\\t: await estimateTokenCount([{ type: \\\"text\\\", text: lastMessageContent as string }], apiHandler)\\n112 | \\n113 | \\t// Calculate total effective tokens (totalTokens never includes the last message)\\n114 | \\tconst prevContextTokens = totalTokens + lastMessageTokens\\n115 | \\n116 | \\t// Calculate available tokens for conversation history\\n117 | \\t// Truncate if we're within TOKEN_BUFFER_PERCENTAGE of the context window\\n118 | \\tconst allowedTokens = contextWindow * (1 - TOKEN_BUFFER_PERCENTAGE) - reservedTokens\\n119 | \\n120 | \\tif (autoCondenseContext) {\\n121 | \\t\\tconst contextPercent = (100 * prevContextTokens) / contextWindow\\n122 | \\t\\tif (contextPercent >= autoCondenseContextPercent || prevContextTokens > allowedTokens) {\\n123 | \\t\\t\\t// Attempt to intelligently condense the context\\n124 | \\t\\t\\tconst result = await summarizeConversation(\\n125 | \\t\\t\\t\\tmessages,\\n126 | \\t\\t\\t\\tapiHandler,\\n127 | \\t\\t\\t\\tsystemPrompt,\\n128 | \\t\\t\\t\\ttaskId,\\n129 | \\t\\t\\t\\tprevContextTokens,\\n130 | \\t\\t\\t\\ttrue, // automatic trigger\\n131 | \\t\\t\\t\\tcustomCondensingPrompt,\\n132 | \\t\\t\\t\\tcondensingApiHandler,\\n133 | \\t\\t\\t)\\n134 | \\t\\t\\tif (result.error) {\\n135 | \\t\\t\\t\\terror = result.error\\n136 | \\t\\t\\t\\tcost = result.cost\\n137 | \\t\\t\\t} else {\\n138 | \\t\\t\\t\\treturn { ...result, prevContextTokens }\\n139 | \\t\\t\\t}\\n140 | \\t\\t}\\n141 | \\t}\\n142 | \\n143 | \\t// Fall back to sliding window truncation if needed\\n144 | \\tif (prevContextTokens > allowedTokens) {\\n145 | \\t\\tconst truncatedMessages = truncateConversation(messages, 0.5, taskId)\\n146 | \\t\\treturn { messages: truncatedMessages, prevContextTokens, summary: \\\"\\\", cost, error }\\n147 | \\t}\\n148 | \\t// No truncation or condensation needed\\n149 | \\treturn { messages, summary: \\\"\\\", cost, prevContextTokens, error }\\n150 | }\\n</content>\\n</file>\\n<file><path>packages/types/src/mode.ts</path>\\n<content lines=\\\"1-128\\\">\\n  1 | import { z } from \\\"zod\\\"\\n  2 | \\n  3 | import { toolGroupsSchema } from \\\"./tool.js\\\"\\n  4 | \\n  5 | /**\\n  6 |  * GroupOptions\\n  7 |  */\\n  8 | \\n  9 | export const groupOptionsSchema = z.object({\\n 10 | \\tfileRegex: z\\n 11 | \\t\\t.string()\\n 12 | \\t\\t.optional()\\n 13 | \\t\\t.refine(\\n 14 | \\t\\t\\t(pattern) => {\\n 15 | \\t\\t\\t\\tif (!pattern) {\\n 16 | \\t\\t\\t\\t\\treturn true // Optional, so empty is valid.\\n 17 | \\t\\t\\t\\t}\\n 18 | \\n 19 | \\t\\t\\t\\ttry {\\n 20 | \\t\\t\\t\\t\\tnew RegExp(pattern)\\n 21 | \\t\\t\\t\\t\\treturn true\\n 22 | \\t\\t\\t\\t} catch {\\n 23 | \\t\\t\\t\\t\\treturn false\\n 24 | \\t\\t\\t\\t}\\n 25 | \\t\\t\\t},\\n 26 | \\t\\t\\t{ message: \\\"Invalid regular expression pattern\\\" },\\n 27 | \\t\\t),\\n 28 | \\tdescription: z.string().optional(),\\n 29 | })\\n 30 | \\n 31 | export type GroupOptions = z.infer<typeof groupOptionsSchema>\\n 32 | \\n 33 | /**\\n 34 |  * GroupEntry\\n 35 |  */\\n 36 | \\n 37 | export const groupEntrySchema = z.union([toolGroupsSchema, z.tuple([toolGroupsSchema, groupOptionsSchema])])\\n 38 | \\n 39 | export type GroupEntry = z.infer<typeof groupEntrySchema>\\n 40 | \\n 41 | /**\\n 42 |  * ModeConfig\\n 43 |  */\\n 44 | \\n 45 | const groupEntryArraySchema = z.array(groupEntrySchema).refine(\\n 46 | \\t(groups) => {\\n 47 | \\t\\tconst seen = new Set()\\n 48 | \\n 49 | \\t\\treturn groups.every((group) => {\\n 50 | \\t\\t\\t// For tuples, check the group name (first element).\\n 51 | \\t\\t\\tconst groupName = Array.isArray(group) ? group[0] : group\\n 52 | \\n 53 | \\t\\t\\tif (seen.has(groupName)) {\\n 54 | \\t\\t\\t\\treturn false\\n 55 | \\t\\t\\t}\\n 56 | \\n 57 | \\t\\t\\tseen.add(groupName)\\n 58 | \\t\\t\\treturn true\\n 59 | \\t\\t})\\n 60 | \\t},\\n 61 | \\t{ message: \\\"Duplicate groups are not allowed\\\" },\\n 62 | )\\n 63 | \\n 64 | export const modeConfigSchema = z.object({\\n 65 | \\tslug: z.string().regex(/^[a-zA-Z0-9-]+$/, \\\"Slug must contain only letters numbers and dashes\\\"),\\n 66 | \\tname: z.string().min(1, \\\"Name is required\\\"),\\n 67 | \\troleDefinition: z.string().min(1, \\\"Role definition is required\\\"),\\n 68 | \\twhenToUse: z.string().optional(),\\n 69 | \\tcustomInstructions: z.string().optional(),\\n 70 | \\tgroups: groupEntryArraySchema,\\n 71 | \\tsource: z.enum([\\\"global\\\", \\\"project\\\"]).optional(),\\n 72 | })\\n 73 | \\n 74 | export type ModeConfig = z.infer<typeof modeConfigSchema>\\n 75 | \\n 76 | /**\\n 77 |  * CustomModesSettings\\n 78 |  */\\n 79 | \\n 80 | export const customModesSettingsSchema = z.object({\\n 81 | \\tcustomModes: z.array(modeConfigSchema).refine(\\n 82 | \\t\\t(modes) => {\\n 83 | \\t\\t\\tconst slugs = new Set()\\n 84 | \\n 85 | \\t\\t\\treturn modes.every((mode) => {\\n 86 | \\t\\t\\t\\tif (slugs.has(mode.slug)) {\\n 87 | \\t\\t\\t\\t\\treturn false\\n 88 | \\t\\t\\t\\t}\\n 89 | \\n 90 | \\t\\t\\t\\tslugs.add(mode.slug)\\n 91 | \\t\\t\\t\\treturn true\\n 92 | \\t\\t\\t})\\n 93 | \\t\\t},\\n 94 | \\t\\t{\\n 95 | \\t\\t\\tmessage: \\\"Duplicate mode slugs are not allowed\\\",\\n 96 | \\t\\t},\\n 97 | \\t),\\n 98 | })\\n 99 | \\n100 | export type CustomModesSettings = z.infer<typeof customModesSettingsSchema>\\n101 | \\n102 | /**\\n103 |  * PromptComponent\\n104 |  */\\n105 | \\n106 | export const promptComponentSchema = z.object({\\n107 | \\troleDefinition: z.string().optional(),\\n108 | \\twhenToUse: z.string().optional(),\\n109 | \\tcustomInstructions: z.string().optional(),\\n110 | })\\n111 | \\n112 | export type PromptComponent = z.infer<typeof promptComponentSchema>\\n113 | \\n114 | /**\\n115 |  * CustomModePrompts\\n116 |  */\\n117 | \\n118 | export const customModePromptsSchema = z.record(z.string(), promptComponentSchema.optional())\\n119 | \\n120 | export type CustomModePrompts = z.infer<typeof customModePromptsSchema>\\n121 | \\n122 | /**\\n123 |  * CustomSupportPrompts\\n124 |  */\\n125 | \\n126 | export const customSupportPromptsSchema = z.record(z.string(), z.string().optional())\\n127 | \\n128 | export type CustomSupportPrompts = z.infer<typeof customSupportPromptsSchema>\\n</content>\\n</file>\\n</files>\\n\\nLoading...\"}"
}
[2025-06-16T20:27:14.568Z] {
  "ts": 1750105633624,
  "type": "say",
  "say": "text",
  "text": "Now let me examine the attempt completion tool to understand how subtasks are completed, and then I'll implement the context overflow contingency feature.",
  "partial": false
}
[2025-06-16T20:27:14.956Z] {
  "ts": 1750105634568,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"readFile\",\"path\":\"src/core/tools/attemptCompletionTool.ts\",\"isOutsideWorkspace\":false,\"content\":\"/roo/repos/Roo-Code/src/core/tools/attemptCompletionTool.ts\",\"reason\":\"\"}",
  "partial": false
}
[2025-06-16T20:27:15.114Z] {
  "ts": 1750105635102,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[read_file for 'src/core/tools/attemptCompletionTool.ts'. Reading multiple files at once is more efficient for the LLM. If other files are relevant to your current task, please read them simultaneously.] Result:\\n\\n<files>\\n<file><path>src/core/tools/attemptCompletionTool.ts</path>\\n<content lines=\\\"1-164\\\">\\n  1 | import Anthropic from \\\"@anthropic-ai/sdk\\\"\\n  2 | \\n  3 | import { TelemetryService } from \\\"@roo-code/telemetry\\\"\\n  4 | \\n  5 | import { Task } from \\\"../task/Task\\\"\\n  6 | import {\\n  7 | \\tToolResponse,\\n  8 | \\tToolUse,\\n  9 | \\tAskApproval,\\n 10 | \\tHandleError,\\n 11 | \\tPushToolResult,\\n 12 | \\tRemoveClosingTag,\\n 13 | \\tToolDescription,\\n 14 | \\tAskFinishSubTaskApproval,\\n 15 | } from \\\"../../shared/tools\\\"\\n 16 | import { formatResponse } from \\\"../prompts/responses\\\"\\n 17 | import { type ExecuteCommandOptions, executeCommand } from \\\"./executeCommandTool\\\"\\n 18 | import { EXPERIMENT_IDS, experiments, experimentDefault } from \\\"../../shared/experiments\\\"\\n 19 | \\n 20 | export async function attemptCompletionTool(\\n 21 | \\tcline: Task,\\n 22 | \\tblock: ToolUse,\\n 23 | \\taskApproval: AskApproval,\\n 24 | \\thandleError: HandleError,\\n 25 | \\tpushToolResult: PushToolResult,\\n 26 | \\tremoveClosingTag: RemoveClosingTag,\\n 27 | \\ttoolDescription: ToolDescription,\\n 28 | \\taskFinishSubTaskApproval: AskFinishSubTaskApproval,\\n 29 | ) {\\n 30 | \\tconst result: string | undefined = block.params.result\\n 31 | \\tconst command: string | undefined = block.params.command\\n 32 | \\n 33 | \\ttry {\\n 34 | \\t\\tconst lastMessage = cline.clineMessages.at(-1)\\n 35 | \\n 36 | \\t\\tif (block.partial) {\\n 37 | \\t\\t\\tif (command) {\\n 38 | \\t\\t\\t\\t// the attempt_completion text is done, now we're getting command\\n 39 | \\t\\t\\t\\t// remove the previous partial attempt_completion ask, replace with say, post state to webview, then stream command\\n 40 | \\n 41 | \\t\\t\\t\\t// const secondLastMessage = cline.clineMessages.at(-2)\\n 42 | \\t\\t\\t\\tif (lastMessage && lastMessage.ask === \\\"command\\\") {\\n 43 | \\t\\t\\t\\t\\t// update command\\n 44 | \\t\\t\\t\\t\\tawait cline.ask(\\\"command\\\", removeClosingTag(\\\"command\\\", command), block.partial).catch(() => {})\\n 45 | \\t\\t\\t\\t} else {\\n 46 | \\t\\t\\t\\t\\t// last message is completion_result\\n 47 | \\t\\t\\t\\t\\t// we have command string, which means we have the result as well, so finish it (doesnt have to exist yet)\\n 48 | \\t\\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", removeClosingTag(\\\"result\\\", result), undefined, false)\\n 49 | \\n 50 | \\t\\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n 51 | \\t\\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n 52 | \\n 53 | \\t\\t\\t\\t\\tawait cline.ask(\\\"command\\\", removeClosingTag(\\\"command\\\", command), block.partial).catch(() => {})\\n 54 | \\t\\t\\t\\t}\\n 55 | \\t\\t\\t} else {\\n 56 | \\t\\t\\t\\t// no command, still outputting partial result\\n 57 | \\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", removeClosingTag(\\\"result\\\", result), undefined, block.partial)\\n 58 | \\t\\t\\t}\\n 59 | \\t\\t\\treturn\\n 60 | \\t\\t} else {\\n 61 | \\t\\t\\tif (!result) {\\n 62 | \\t\\t\\t\\tcline.consecutiveMistakeCount++\\n 63 | \\t\\t\\t\\tcline.recordToolError(\\\"attempt_completion\\\")\\n 64 | \\t\\t\\t\\tpushToolResult(await cline.sayAndCreateMissingParamError(\\\"attempt_completion\\\", \\\"result\\\"))\\n 65 | \\t\\t\\t\\treturn\\n 66 | \\t\\t\\t}\\n 67 | \\n 68 | \\t\\t\\tcline.consecutiveMistakeCount = 0\\n 69 | \\n 70 | \\t\\t\\tlet commandResult: ToolResponse | undefined\\n 71 | \\n 72 | \\t\\t\\t// Check if command execution is disabled via experiment\\n 73 | \\t\\t\\tconst state = await cline.providerRef.deref()?.getState()\\n 74 | \\t\\t\\tconst experimentsConfig = state?.experiments ?? experimentDefault\\n 75 | \\t\\t\\tconst isCommandDisabled = experiments.isEnabled(\\n 76 | \\t\\t\\t\\texperimentsConfig,\\n 77 | \\t\\t\\t\\tEXPERIMENT_IDS.DISABLE_COMPLETION_COMMAND,\\n 78 | \\t\\t\\t)\\n 79 | \\n 80 | \\t\\t\\tif (command && !isCommandDisabled) {\\n 81 | \\t\\t\\t\\tif (lastMessage && lastMessage.ask !== \\\"command\\\") {\\n 82 | \\t\\t\\t\\t\\t// Haven't sent a command message yet so first send completion_result then command.\\n 83 | \\t\\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", result, undefined, false)\\n 84 | \\t\\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n 85 | \\t\\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n 86 | \\t\\t\\t\\t}\\n 87 | \\n 88 | \\t\\t\\t\\t// Complete command message.\\n 89 | \\t\\t\\t\\tconst didApprove = await askApproval(\\\"command\\\", command)\\n 90 | \\n 91 | \\t\\t\\t\\tif (!didApprove) {\\n 92 | \\t\\t\\t\\t\\treturn\\n 93 | \\t\\t\\t\\t}\\n 94 | \\n 95 | \\t\\t\\t\\tconst executionId = cline.lastMessageTs?.toString() ?? Date.now().toString()\\n 96 | \\t\\t\\t\\tconst options: ExecuteCommandOptions = { executionId, command }\\n 97 | \\t\\t\\t\\tconst [userRejected, execCommandResult] = await executeCommand(cline, options)\\n 98 | \\n 99 | \\t\\t\\t\\tif (userRejected) {\\n100 | \\t\\t\\t\\t\\tcline.didRejectTool = true\\n101 | \\t\\t\\t\\t\\tpushToolResult(execCommandResult)\\n102 | \\t\\t\\t\\t\\treturn\\n103 | \\t\\t\\t\\t}\\n104 | \\n105 | \\t\\t\\t\\t// User didn't reject, but the command may have output.\\n106 | \\t\\t\\t\\tcommandResult = execCommandResult\\n107 | \\t\\t\\t} else {\\n108 | \\t\\t\\t\\tawait cline.say(\\\"completion_result\\\", result, undefined, false)\\n109 | \\t\\t\\t\\tTelemetryService.instance.captureTaskCompleted(cline.taskId)\\n110 | \\t\\t\\t\\tcline.emit(\\\"taskCompleted\\\", cline.taskId, cline.getTokenUsage(), cline.toolUsage)\\n111 | \\t\\t\\t}\\n112 | \\n113 | \\t\\t\\tif (cline.parentTask) {\\n114 | \\t\\t\\t\\tconst didApprove = await askFinishSubTaskApproval()\\n115 | \\n116 | \\t\\t\\t\\tif (!didApprove) {\\n117 | \\t\\t\\t\\t\\treturn\\n118 | \\t\\t\\t\\t}\\n119 | \\n120 | \\t\\t\\t\\t// tell the provider to remove the current subtask and resume the previous task in the stack\\n121 | \\t\\t\\t\\tawait cline.providerRef.deref()?.finishSubTask(result)\\n122 | \\t\\t\\t\\treturn\\n123 | \\t\\t\\t}\\n124 | \\n125 | \\t\\t\\t// We already sent completion_result says, an\\n126 | \\t\\t\\t// empty string asks relinquishes control over\\n127 | \\t\\t\\t// button and field.\\n128 | \\t\\t\\tconst { response, text, images } = await cline.ask(\\\"completion_result\\\", \\\"\\\", false)\\n129 | \\n130 | \\t\\t\\t// Signals to recursive loop to stop (for now\\n131 | \\t\\t\\t// cline never happens since yesButtonClicked\\n132 | \\t\\t\\t// will trigger a new task).\\n133 | \\t\\t\\tif (response === \\\"yesButtonClicked\\\") {\\n134 | \\t\\t\\t\\tpushToolResult(\\\"\\\")\\n135 | \\t\\t\\t\\treturn\\n136 | \\t\\t\\t}\\n137 | \\n138 | \\t\\t\\tawait cline.say(\\\"user_feedback\\\", text ?? \\\"\\\", images)\\n139 | \\t\\t\\tconst toolResults: (Anthropic.TextBlockParam | Anthropic.ImageBlockParam)[] = []\\n140 | \\n141 | \\t\\t\\tif (commandResult) {\\n142 | \\t\\t\\t\\tif (typeof commandResult === \\\"string\\\") {\\n143 | \\t\\t\\t\\t\\ttoolResults.push({ type: \\\"text\\\", text: commandResult })\\n144 | \\t\\t\\t\\t} else if (Array.isArray(commandResult)) {\\n145 | \\t\\t\\t\\t\\ttoolResults.push(...commandResult)\\n146 | \\t\\t\\t\\t}\\n147 | \\t\\t\\t}\\n148 | \\n149 | \\t\\t\\ttoolResults.push({\\n150 | \\t\\t\\t\\ttype: \\\"text\\\",\\n151 | \\t\\t\\t\\ttext: `The user has provided feedback on the results. Consider their input to continue the task, and then attempt completion again.\\\\n<feedback>\\\\n${text}\\\\n</feedback>`,\\n152 | \\t\\t\\t})\\n153 | \\n154 | \\t\\t\\ttoolResults.push(...formatResponse.imageBlocks(images))\\n155 | \\t\\t\\tcline.userMessageContent.push({ type: \\\"text\\\", text: `${toolDescription()} Result:` })\\n156 | \\t\\t\\tcline.userMessageContent.push(...toolResults)\\n157 | \\n158 | \\t\\t\\treturn\\n159 | \\t\\t}\\n160 | \\t} catch (error) {\\n161 | \\t\\tawait handleError(\\\"inspecting site\\\", error)\\n162 | \\t\\treturn\\n163 | \\t}\\n164 | }\\n</content>\\n</file>\\n</files>\\n\\nLoading...\"}"
}
[2025-06-16T20:27:20.330Z] {
  "ts": 1750105638499,
  "type": "say",
  "say": "text",
  "text": "Now I have a good understanding of the codebase. Let me implement the context overflow contingency feature as requested in the GitHub issue. I'll need to:\n\n1. Add new configuration options to the mode schema for context overflow handling\n2. Modify the context management logic to detect overflow and trigger the contingency\n3. Update the attempt completion tool to handle context overflow scenarios\n\nLet me start by implementing the solution:",
  "partial": false
}
[2025-06-16T20:27:33.303Z] {
  "ts": 1750105640595,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"editedExistingFile\",\"path\":\"packages/types/src/mode.ts\",\"isOutsideWorkspace\":false,\"isProtected\":false,\"diff\":\"@@ -38,8 +38,20 @@\\n \\n export type GroupEntry = z.infer<typeof groupEntrySchema>\\n \\n /**\\n+ * ContextOverflowContingency\\n+ */\\n+\\n+export const contextOverflowContingencySchema = z.object({\\n+\\tenabled: z.boolean().default(false),\\n+\\tmessage: z.string().optional(),\\n+\\ttriggerTools: z.array(z.string()).optional(),\\n+})\\n+\\n+export type ContextOverflowContingency = z.infer<typeof contextOverflowContingencySchema>\\n+\\n+/**\\n  * ModeConfig\\n  */\\n \\n const groupEntryArraySchema = z.array(groupEntrySchema).refine(\\n@@ -68,8 +80,9 @@\\n \\twhenToUse: z.string().optional(),\\n \\tcustomInstructions: z.string().optional(),\\n \\tgroups: groupEntryArraySchema,\\n \\tsource: z.enum([\\\"global\\\", \\\"project\\\"]).optional(),\\n+\\tcontextOverflowContingency: contextOverflowContingencySchema.optional(),\\n })\\n \\n export type ModeConfig = z.infer<typeof modeConfigSchema>\\n \\n@@ -124,5 +137,5 @@\\n  */\\n \\n export const customSupportPromptsSchema = z.record(z.string(), z.string().optional())\\n \\n-export type CustomSupportPrompts = z.infer<typeof customSupportPromptsSchema>\\n+export type CustomSupportPrompts = z.infer<typeof customSupportPromptsSchema>\\n\\\\ No newline at end of file\\n\"}",
  "partial": false,
  "isProtected": false
}
[2025-06-16T20:27:34.454Z] {
  "ts": 1750105654447,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[write_to_file for 'packages/types/src/mode.ts'] Result:\\n\\n<file_write_result>\\n<path>packages/types/src/mode.ts</path>\\n<operation>modified</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nTool [write_to_file] was not executed because a tool has already been used in this message. Only one tool may be used per message. You must assess the first tool's result before proceeding to use the next tool.\\n\\nLoading...\"}"
}
[2025-06-16T20:27:37.689Z] {
  "ts": 1750105657490,
  "type": "say",
  "say": "text",
  "text": "Great! Now let me create the context overflow handler:",
  "partial": false
}
[2025-06-16T20:27:50.477Z] {
  "ts": 1750105657939,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"newFileCreated\",\"path\":\"src/core/context-overflow/ContextOverflowHandler.ts\",\"content\":\"import { Task } from \\\"../task/Task\\\"\\nimport { getModeBySlug } from \\\"../../shared/modes\\\"\\nimport type { ContextOverflowContingency } from \\\"@roo-code/types\\\"\\n\\nexport class ContextOverflowHandler {\\n\\tprivate task: Task\\n\\tprivate lastToolUsed?: string\\n\\n\\tconstructor(task: Task) {\\n\\t\\tthis.task = task\\n\\t}\\n\\n\\t/**\\n\\t * Records the last tool used for context overflow tracking\\n\\t */\\n\\trecordToolUse(toolName: string): void {\\n\\t\\tthis.lastToolUsed = toolName\\n\\t}\\n\\n\\t/**\\n\\t * Checks if context overflow contingency should be triggered\\n\\t */\\n\\tasync shouldTriggerContingency(\\n\\t\\tcontextTokens: number,\\n\\t\\tcontextWindow: number,\\n\\t\\tmaxTokens?: number,\\n\\t): Promise<boolean> {\\n\\t\\tconst state = await this.task.providerRef.deref()?.getState()\\n\\t\\tif (!state) return false\\n\\n\\t\\tconst mode = getModeBySlug(state.mode, state.customModes)\\n\\t\\tconst contingency = mode?.contextOverflowContingency\\n\\n\\t\\tif (!contingency?.enabled) {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\t// Calculate if we're approaching context overflow\\n\\t\\tconst reservedTokens = maxTokens || contextWindow * 0.2\\n\\t\\tconst allowedTokens = contextWindow * 0.9 - reservedTokens // 90% threshold\\n\\t\\t\\n\\t\\tconst isOverflowing = contextTokens > allowedTokens\\n\\n\\t\\t// If specific tools are configured, only trigger for those tools\\n\\t\\tif (contingency.triggerTools && contingency.triggerTools.length > 0) {\\n\\t\\t\\treturn isOverflowing && this.lastToolUsed && contingency.triggerTools.includes(this.lastToolUsed)\\n\\t\\t}\\n\\n\\t\\t// Otherwise trigger for any overflow\\n\\t\\treturn isOverflowing\\n\\t}\\n\\n\\t/**\\n\\t * Triggers the context overflow contingency\\n\\t */\\n\\tasync triggerContingency(): Promise<void> {\\n\\t\\tconst state = await this.task.providerRef.deref()?.getState()\\n\\t\\tif (!state) return\\n\\n\\t\\tconst mode = getModeBySlug(state.mode, state.customModes)\\n\\t\\tconst contingency = mode?.contextOverflowContingency\\n\\n\\t\\tif (!contingency?.enabled) {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\n\\t\\t// Generate the contingency message\\n\\t\\tlet message = contingency.message || \\\"Task failed because of a context overflow, possibly because webpage returned from the browser was too big\\\"\\n\\n\\t\\t// If we have a last tool used, customize the message\\n\\t\\tif (this.lastToolUsed) {\\n\\t\\t\\tif (!contingency.message) {\\n\\t\\t\\t\\tmessage = `Task failed because of a context overflow after using ${this.lastToolUsed}, possibly because the content returned was too large`\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Log the contingency trigger\\n\\t\\tconsole.log(`[ContextOverflow] Triggering contingency for task ${this.task.taskId} due to context overflow`)\\n\\n\\t\\t// If this is a subtask, complete it with the overflow message\\n\\t\\tif (this.task.parentTask) {\\n\\t\\t\\tawait this.task.providerRef.deref()?.finishSubTask(message)\\n\\t\\t} else {\\n\\t\\t\\t// For main tasks, show the overflow message and pause\\n\\t\\t\\tawait this.task.say(\\\"context_overflow\\\", message)\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * Gets the contingency configuration for the current mode\\n\\t */\\n\\tasync getContingencyConfig(): Promise<ContextOverflowContingency | undefined> {\\n\\t\\tconst state = await this.task.providerRef.deref()?.getState()\\n\\t\\tif (!state) return undefined\\n\\n\\t\\tconst mode = getModeBySlug(state.mode, state.customModes)\\n\\t\\treturn mode?.contextOverflowContingency\\n\\t}\\n}\",\"isOutsideWorkspace\":false,\"isProtected\":false}",
  "partial": false,
  "isProtected": false
}
[2025-06-16T20:27:51.599Z] {
  "ts": 1750105671592,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[write_to_file for 'src/core/context-overflow/ContextOverflowHandler.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/context-overflow/ContextOverflowHandler.ts</path>\\n<operation>created</operation>\\n<problems>\\n\\nNew problems detected after saving the file:\\nsrc/core/context-overflow/ContextOverflowHandler.ts\\n- [ts Error] 46 | \\t\\t\\treturn isOverflowing &amp;&amp; this.lastToolUsed &amp;&amp; contingency.triggerTools.includes(this.lastToolUsed) : Type 'string | boolean | undefined' is not assignable to type 'boolean'.\\n  Type 'undefined' is not assignable to type 'boolean'.\\n- [ts Error] 85 | \\t\\t\\tawait this.task.say(\\\"context_overflow\\\", message) : Argument of type '\\\"context_overflow\\\"' is not assignable to parameter of type '\\\"reasoning\\\" | \\\"error\\\" | \\\"api_req_started\\\" | \\\"api_req_finished\\\" | \\\"api_req_retried\\\" | \\\"api_req_retry_delayed\\\" | \\\"api_req_deleted\\\" | \\\"text\\\" | \\\"completion_result\\\" | \\\"user_feedback\\\" | ... 13 more ... | \\\"codebase_search_result\\\"'.</problems>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nTool [apply_diff] was not executed because a tool has already been used in this message. Only one tool may be used per message. You must assess the first tool's result before proceeding to use the next tool.\\n\\nLoading...\"}"
}
[2025-06-16T20:27:55.157Z] {
  "ts": 1750105674700,
  "type": "say",
  "say": "text",
  "text": "I need to fix the TypeScript errors in the ContextOverflowHandler. Let me update it:",
  "partial": false
}
[2025-06-16T20:27:57.352Z] {
  "ts": 1750105675338,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/context-overflow/ContextOverflowHandler.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:44\\n-------\\n\\t\\t// If specific tools are configured, only trigger for those tools\\n\\t\\tif (contingency.triggerTools && contingency.triggerTools.length > 0) {\\n\\t\\t\\treturn isOverflowing && this.lastToolUsed && contingency.triggerTools.includes(this.lastToolUsed)\\n\\t\\t}\\n=======\\n\\t\\t// If specific tools are configured, only trigger for those tools\\n\\t\\tif (contingency.triggerTools && contingency.triggerTools.length > 0) {\\n\\t\\t\\treturn isOverflowing && !!this.lastToolUsed && contingency.triggerTools.includes(this.lastToolUsed)\\n\\t\\t}\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:27:58.454Z] {
  "ts": 1750105678441,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/context-overflow/ContextOverflowHandler.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/context-overflow/ContextOverflowHandler.ts</path>\\n<operation>modified</operation>\\n<problems>\\n\\nNew problems detected after saving the file:\\nsrc/core/context-overflow/ContextOverflowHandler.ts\\n- [ts Error] 85 | \\t\\t\\tawait this.task.say(\\\"context_overflow\\\", message) : Argument of type '\\\"context_overflow\\\"' is not assignable to parameter of type '\\\"reasoning\\\" | \\\"error\\\" | \\\"api_req_started\\\" | \\\"api_req_finished\\\" | \\\"api_req_retried\\\" | \\\"api_req_retry_delayed\\\" | \\\"api_req_deleted\\\" | \\\"text\\\" | \\\"completion_result\\\" | \\\"user_feedback\\\" | ... 13 more ... | \\\"codebase_search_result\\\"'.</problems>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:28:02.271Z] {
  "ts": 1750105681709,
  "type": "say",
  "say": "text",
  "text": "I need to fix the second TypeScript error by using an existing message type. Let me check what message types are available and update the code:",
  "partial": false
}
[2025-06-16T20:28:02.271Z] {
  "ts": 1750105681709,
  "type": "say",
  "say": "text",
  "text": "I need to fix the second TypeScript error by using an existing message type. Let me check what message types are available and update the code:",
  "partial": false
}
[2025-06-16T20:28:02.279Z] {
  "ts": 1750105681709,
  "type": "say",
  "say": "text",
  "text": "I need to fix the second TypeScript error by using an existing message type. Let me check what message types are available and update the code:",
  "partial": false
}
[2025-06-16T20:28:03.894Z] {
  "ts": 1750105683392,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/context-overflow/ContextOverflowHandler.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:83\\n-------\\n\\t\\t} else {\\n\\t\\t\\t// For main tasks, show the overflow message and pause\\n\\t\\t\\tawait this.task.say(\\\"context_overflow\\\", message)\\n\\t\\t}\\n=======\\n\\t\\t} else {\\n\\t\\t\\t// For main tasks, show the overflow message and pause\\n\\t\\t\\tawait this.task.say(\\\"error\\\", message)\\n\\t\\t}\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:28:04.985Z] {
  "ts": 1750105684977,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/context-overflow/ContextOverflowHandler.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/context-overflow/ContextOverflowHandler.ts</path>\\n<operation>modified</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:28:08.659Z] {
  "ts": 1750105688164,
  "type": "say",
  "say": "text",
  "text": "Great! Now let me update the Task class to integrate the context overflow handler:",
  "partial": false
}
[2025-06-16T20:28:11.390Z] {
  "ts": 1750105688827,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/task/Task.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:65\\n-------\\nimport { ToolRepetitionDetector } from \\\"../tools/ToolRepetitionDetector\\\"\\nimport { FileContextTracker } from \\\"../context-tracking/FileContextTracker\\\"\\nimport { RooIgnoreController } from \\\"../ignore/RooIgnoreController\\\"\\nimport { RooProtectedController } from \\\"../protect/RooProtectedController\\\"\\n=======\\nimport { ToolRepetitionDetector } from \\\"../tools/ToolRepetitionDetector\\\"\\nimport { FileContextTracker } from \\\"../context-tracking/FileContextTracker\\\"\\nimport { RooIgnoreController } from \\\"../ignore/RooIgnoreController\\\"\\nimport { RooProtectedController } from \\\"../protect/RooProtectedController\\\"\\nimport { ContextOverflowHandler } from \\\"../context-overflow/ContextOverflowHandler\\\"\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:28:12.475Z] {
  "ts": 1750105692467,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/task/Task.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/task/Task.ts</path>\\n<operation>modified</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:28:17.486Z] {
  "ts": 1750105696876,
  "type": "say",
  "say": "text",
  "text": "Now let me add the context overflow handler as a property to the Task class:",
  "partial": false
}
[2025-06-16T20:28:19.016Z] {
  "ts": 1750105697806,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/task/Task.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:146\\n-------\\n\\ttoolRepetitionDetector: ToolRepetitionDetector\\n\\trooIgnoreController?: RooIgnoreController\\n\\trooProtectedController?: RooProtectedController\\n\\tfileContextTracker: FileContextTracker\\n=======\\n\\ttoolRepetitionDetector: ToolRepetitionDetector\\n\\trooIgnoreController?: RooIgnoreController\\n\\trooProtectedController?: RooProtectedController\\n\\tfileContextTracker: FileContextTracker\\n\\tcontextOverflowHandler: ContextOverflowHandler\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:28:20.119Z] {
  "ts": 1750105700111,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/task/Task.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/task/Task.ts</path>\\n<operation>modified</operation>\\n<problems>\\n\\nNew problems detected after saving the file:\\nsrc/core/task/Task.ts\\n- [ts Error] 151 | \\tcontextOverflowHandler: ContextOverflowHandler : Property 'contextOverflowHandler' has no initializer and is not definitely assigned in the constructor.</problems>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:28:27.147Z] {
  "ts": 1750105706807,
  "type": "say",
  "say": "text",
  "text": "I need to initialize the context overflow handler in the constructor. Let me find the constructor and add the initialization:",
  "partial": false
}
[2025-06-16T20:28:31.536Z] {
  "ts": 1750105707538,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/task/Task.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:275\\n-------\\n\\t\\tthis.toolRepetitionDetector = new ToolRepetitionDetector(this.consecutiveMistakeLimit)\\n\\n\\t\\tonCreated?.(this)\\n=======\\n\\t\\tthis.toolRepetitionDetector = new ToolRepetitionDetector(this.consecutiveMistakeLimit)\\n\\t\\tthis.contextOverflowHandler = new ContextOverflowHandler(this)\\n\\n\\t\\tonCreated?.(this)\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:28:32.658Z] {
  "ts": 1750105712647,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/task/Task.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/task/Task.ts</path>\\n<operation>modified</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:28:36.757Z] {
  "ts": 1750105716077,
  "type": "say",
  "say": "text",
  "text": "Now I need to integrate the context overflow handler into the token management logic. Let me update the `attemptApiRequest` method to check for context overflow:",
  "partial": false
}
[2025-06-16T20:28:42.032Z] {
  "ts": 1750105716993,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/task/Task.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:1696\\n-------\\n\\t\\t\\tconst truncateResult = await truncateConversationIfNeeded({\\n\\t\\t\\t\\tmessages: this.apiConversationHistory,\\n\\t\\t\\t\\ttotalTokens: contextTokens,\\n\\t\\t\\t\\tmaxTokens,\\n\\t\\t\\t\\tcontextWindow,\\n\\t\\t\\t\\tapiHandler: this.api,\\n\\t\\t\\t\\tautoCondenseContext,\\n\\t\\t\\t\\tautoCondenseContextPercent,\\n\\t\\t\\t\\tsystemPrompt,\\n\\t\\t\\t\\ttaskId: this.taskId,\\n\\t\\t\\t\\tcustomCondensingPrompt,\\n\\t\\t\\t\\tcondensingApiHandler,\\n\\t\\t\\t})\\n=======\\n\\t\\t\\t// Check for context overflow contingency before truncation\\n\\t\\t\\tconst shouldTriggerContingency = await this.contextOverflowHandler.shouldTriggerContingency(\\n\\t\\t\\t\\tcontextTokens,\\n\\t\\t\\t\\tcontextWindow,\\n\\t\\t\\t\\tmaxTokens,\\n\\t\\t\\t)\\n\\n\\t\\t\\tif (shouldTriggerContingency) {\\n\\t\\t\\t\\tawait this.contextOverflowHandler.triggerContingency()\\n\\t\\t\\t\\tthrow new Error(\\\"Context overflow contingency triggered\\\")\\n\\t\\t\\t}\\n\\n\\t\\t\\tconst truncateResult = await truncateConversationIfNeeded({\\n\\t\\t\\t\\tmessages: this.apiConversationHistory,\\n\\t\\t\\t\\ttotalTokens: contextTokens,\\n\\t\\t\\t\\tmaxTokens,\\n\\t\\t\\t\\tcontextWindow,\\n\\t\\t\\t\\tapiHandler: this.api,\\n\\t\\t\\t\\tautoCondenseContext,\\n\\t\\t\\t\\tautoCondenseContextPercent,\\n\\t\\t\\t\\tsystemPrompt,\\n\\t\\t\\t\\ttaskId: this.taskId,\\n\\t\\t\\t\\tcustomCondensingPrompt,\\n\\t\\t\\t\\tcondensingApiHandler,\\n\\t\\t\\t})\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:28:43.232Z] {
  "ts": 1750105723223,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/task/Task.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/task/Task.ts</path>\\n<operation>modified</operation>\\n<problems>\\n\\nNew problems detected after saving the file:\\nsrc/core/task/Task.ts\\n- [ts Error] 1704 | \\t\\t\\t\\tmaxTokens, : Argument of type 'number | null | undefined' is not assignable to parameter of type 'number | undefined'.\\n  Type 'null' is not assignable to type 'number | undefined'.</problems>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:28:50.319Z] {
  "ts": 1750105729741,
  "type": "say",
  "say": "text",
  "text": "I need to fix the TypeScript error by handling the null case:",
  "partial": false
}
[2025-06-16T20:28:54.018Z] {
  "ts": 1750105730795,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/task/Task.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:1698\\n-------\\n\\t\\t\\t// Check for context overflow contingency before truncation\\n\\t\\t\\tconst shouldTriggerContingency = await this.contextOverflowHandler.shouldTriggerContingency(\\n\\t\\t\\t\\tcontextTokens,\\n\\t\\t\\t\\tcontextWindow,\\n\\t\\t\\t\\tmaxTokens,\\n\\t\\t\\t)\\n=======\\n\\t\\t\\t// Check for context overflow contingency before truncation\\n\\t\\t\\tconst shouldTriggerContingency = await this.contextOverflowHandler.shouldTriggerContingency(\\n\\t\\t\\t\\tcontextTokens,\\n\\t\\t\\t\\tcontextWindow,\\n\\t\\t\\t\\tmaxTokens || undefined,\\n\\t\\t\\t)\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:28:55.124Z] {
  "ts": 1750105735113,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/task/Task.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/task/Task.ts</path>\\n<operation>modified</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:29:04.502Z] {
  "ts": 1750105742646,
  "type": "say",
  "say": "text",
  "text": "Now I need to update the tool usage tracking to record which tools are being used. Let me update the `recordToolUsage` method:",
  "partial": false
}
[2025-06-16T20:29:13.843Z] {
  "ts": 1750105746004,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/core/task/Task.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:1875\\n-------\\n\\tpublic recordToolUsage(toolName: ToolName) {\\n\\t\\tif (!this.toolUsage[toolName]) {\\n\\t\\t\\tthis.toolUsage[toolName] = { attempts: 0, failures: 0 }\\n\\t\\t}\\n\\n\\t\\tthis.toolUsage[toolName].attempts++\\n\\t}\\n=======\\n\\tpublic recordToolUsage(toolName: ToolName) {\\n\\t\\tif (!this.toolUsage[toolName]) {\\n\\t\\t\\tthis.toolUsage[toolName] = { attempts: 0, failures: 0 }\\n\\t\\t}\\n\\n\\t\\tthis.toolUsage[toolName].attempts++\\n\\t\\t\\n\\t\\t// Record tool usage for context overflow tracking\\n\\t\\tthis.contextOverflowHandler.recordToolUse(toolName)\\n\\t}\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:29:14.961Z] {
  "ts": 1750105754953,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/core/task/Task.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/task/Task.ts</path>\\n<operation>modified</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:29:22.246Z] {
  "ts": 1750105761111,
  "type": "say",
  "say": "text",
  "text": "Now let me update the built-in modes to include an example of the context overflow contingency feature. I'll add it to the browser-focused modes:",
  "partial": false
}
[2025-06-16T20:29:43.647Z] {
  "ts": 1750105762467,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"appliedDiff\",\"path\":\"src/shared/modes.ts\",\"diff\":\"<<<<<<< SEARCH\\n:start_line:63\\n-------\\nexport const modes: readonly ModeConfig[] = [\\n\\t{\\n\\t\\tslug: \\\"code\\\",\\n\\t\\tname: \\\"💻 Code\\\",\\n\\t\\troleDefinition:\\n\\t\\t\\t\\\"You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.\\\",\\n\\t\\twhenToUse:\\n\\t\\t\\t\\\"Use this mode when you need to write, modify, or refactor code. Ideal for implementing features, fixing bugs, creating new files, or making code improvements across any programming language or framework.\\\",\\n\\t\\tgroups: [\\\"read\\\", \\\"edit\\\", \\\"browser\\\", \\\"command\\\", \\\"mcp\\\"],\\n\\t},\\n=======\\nexport const modes: readonly ModeConfig[] = [\\n\\t{\\n\\t\\tslug: \\\"code\\\",\\n\\t\\tname: \\\"💻 Code\\\",\\n\\t\\troleDefinition:\\n\\t\\t\\t\\\"You are Roo, a highly skilled software engineer with extensive knowledge in many programming languages, frameworks, design patterns, and best practices.\\\",\\n\\t\\twhenToUse:\\n\\t\\t\\t\\\"Use this mode when you need to write, modify, or refactor code. Ideal for implementing features, fixing bugs, creating new files, or making code improvements across any programming language or framework.\\\",\\n\\t\\tgroups: [\\\"read\\\", \\\"edit\\\", \\\"browser\\\", \\\"command\\\", \\\"mcp\\\"],\\n\\t\\tcontextOverflowContingency: {\\n\\t\\t\\tenabled: false,\\n\\t\\t\\tmessage: \\\"Task failed because of a context overflow, possibly because webpage returned from the browser was too big\\\",\\n\\t\\t\\ttriggerTools: [\\\"browser_action\\\"],\\n\\t\\t},\\n\\t},\\n>>>>>>> REPLACE\"}",
  "partial": false,
  "isProtected": false,
  "progressStatus": {
    "icon": "diff-multiple",
    "text": "1"
  }
}
[2025-06-16T20:29:44.748Z] {
  "ts": 1750105784739,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[apply_diff for 'src/shared/modes.ts'] Result:\\n\\n<file_write_result>\\n<path>src/shared/modes.ts</path>\\n<operation>modified</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:29:52.465Z] {
  "ts": 1750105791654,
  "type": "say",
  "say": "text",
  "text": "Now let me create a test file to verify the implementation works correctly:",
  "partial": false
}
[2025-06-16T20:31:05.081Z] {
  "ts": 1750105793483,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"newFileCreated\",\"path\":\"src/core/context-overflow/__tests__/ContextOverflowHandler.test.ts\",\"content\":\"import { describe, it, expect, beforeEach, vi } from \\\"vitest\\\"\\nimport { ContextOverflowHandler } from \\\"../ContextOverflowHandler\\\"\\nimport { Task } from \\\"../../task/Task\\\"\\nimport { getModeBySlug } from \\\"../../../shared/modes\\\"\\n\\n// Mock the dependencies\\nvi.mock(\\\"../../task/Task\\\")\\nvi.mock(\\\"../../../shared/modes\\\")\\n\\ndescribe(\\\"ContextOverflowHandler\\\", () => {\\n\\tlet handler: ContextOverflowHandler\\n\\tlet mockTask: any\\n\\tlet mockProvider: any\\n\\n\\tbeforeEach(() => {\\n\\t\\tmockProvider = {\\n\\t\\t\\tgetState: vi.fn(),\\n\\t\\t\\tfinishSubTask: vi.fn(),\\n\\t\\t}\\n\\n\\t\\tmockTask = {\\n\\t\\t\\ttaskId: \\\"test-task-id\\\",\\n\\t\\t\\tparentTask: null,\\n\\t\\t\\tproviderRef: {\\n\\t\\t\\t\\tderef: vi.fn().mockReturnValue(mockProvider),\\n\\t\\t\\t},\\n\\t\\t\\tsay: vi.fn(),\\n\\t\\t}\\n\\n\\t\\thandler = new ContextOverflowHandler(mockTask)\\n\\t})\\n\\n\\tdescribe(\\\"recordToolUse\\\", () => {\\n\\t\\tit(\\\"should record the last tool used\\\", () => {\\n\\t\\t\\thandler.recordToolUse(\\\"browser_action\\\")\\n\\t\\t\\texpect(handler[\\\"lastToolUsed\\\"]).toBe(\\\"browser_action\\\")\\n\\t\\t})\\n\\t})\\n\\n\\tdescribe(\\\"shouldTriggerContingency\\\", () => {\\n\\t\\tit(\\\"should return false when contingency is disabled\\\", async () => {\\n\\t\\t\\tmockProvider.getState.mockResolvedValue({\\n\\t\\t\\t\\tmode: \\\"code\\\",\\n\\t\\t\\t\\tcustomModes: [],\\n\\t\\t\\t})\\n\\n\\t\\t\\tvi.mocked(getModeBySlug).mockReturnValue({\\n\\t\\t\\t\\tslug: \\\"code\\\",\\n\\t\\t\\t\\tname: \\\"Code\\\",\\n\\t\\t\\t\\troleDefinition: \\\"test\\\",\\n\\t\\t\\t\\tgroups: [],\\n\\t\\t\\t\\tcontextOverflowContingency: {\\n\\t\\t\\t\\t\\tenabled: false,\\n\\t\\t\\t\\t},\\n\\t\\t\\t})\\n\\n\\t\\t\\tconst result = await handler.shouldTriggerContingency(100000, 200000, 50000)\\n\\t\\t\\texpect(result).toBe(false)\\n\\t\\t})\\n\\n\\t\\tit(\\\"should return true when context is overflowing and contingency is enabled\\\", async () => {\\n\\t\\t\\tmockProvider.getState.mockResolvedValue({\\n\\t\\t\\t\\tmode: \\\"code\\\",\\n\\t\\t\\t\\tcustomModes: [],\\n\\t\\t\\t})\\n\\n\\t\\t\\tvi.mocked(getModeBySlug).mockReturnValue({\\n\\t\\t\\t\\tslug: \\\"code\\\",\\n\\t\\t\\t\\tname: \\\"Code\\\",\\n\\t\\t\\t\\troleDefinition: \\\"test\\\",\\n\\t\\t\\t\\tgroups: [],\\n\\t\\t\\t\\tcontextOverflowContingency: {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tmessage: \\\"Context overflow detected\\\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t})\\n\\n\\t\\t\\t// Set context tokens to exceed the threshold (90% of context window - reserved tokens)\\n\\t\\t\\t// contextWindow = 200000, maxTokens = 50000\\n\\t\\t\\t// allowedTokens = 200000 * 0.9 - 50000 = 180000 - 50000 = 130000\\n\\t\\t\\tconst result = await handler.shouldTriggerContingency(150000, 200000, 50000)\\n\\t\\t\\texpect(result).toBe(true)\\n\\t\\t})\\n\\n\\t\\tit(\\\"should only trigger for specific tools when configured\\\", async () => {\\n\\t\\t\\thandler.recordToolUse(\\\"browser_action\\\")\\n\\n\\t\\t\\tmockProvider.getState.mockResolvedValue({\\n\\t\\t\\t\\tmode: \\\"code\\\",\\n\\t\\t\\t\\tcustomModes: [],\\n\\t\\t\\t})\\n\\n\\t\\t\\tvi.mocked(getModeBySlug).mockReturnValue({\\n\\t\\t\\t\\tslug: \\\"code\\\",\\n\\t\\t\\t\\tname: \\\"Code\\\",\\n\\t\\t\\t\\troleDefinition: \\\"test\\\",\\n\\t\\t\\t\\tgroups: [],\\n\\t\\t\\t\\tcontextOverflowContingency: {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\ttriggerTools: [\\\"browser_action\\\"],\\n\\t\\t\\t\\t},\\n\\t\\t\\t})\\n\\n\\t\\t\\tconst result = await handler.shouldTriggerContingency(150000, 200000, 50000)\\n\\t\\t\\texpect(result).toBe(true)\\n\\t\\t})\\n\\n\\t\\tit(\\\"should not trigger for non-configured tools\\\", async () => {\\n\\t\\t\\thandler.recordToolUse(\\\"read_file\\\")\\n\\n\\t\\t\\tmockProvider.getState.mockResolvedValue({\\n\\t\\t\\t\\tmode: \\\"code\\\",\\n\\t\\t\\t\\tcustomModes: [],\\n\\t\\t\\t})\\n\\n\\t\\t\\tvi.mocked(getModeBySlug).mockReturnValue({\\n\\t\\t\\t\\tslug: \\\"code\\\",\\n\\t\\t\\t\\tname: \\\"Code\\\",\\n\\t\\t\\t\\troleDefinition: \\\"test\\\",\\n\\t\\t\\t\\tgroups: [],\\n\\t\\t\\t\\tcontextOverflowContingency: {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\ttriggerTools: [\\\"browser_action\\\"],\\n\\t\\t\\t\\t},\\n\\t\\t\\t})\\n\\n\\t\\t\\tconst result = await handler.shouldTriggerContingency(150000, 200000, 50000)\\n\\t\\t\\texpect(result).toBe(false)\\n\\t\\t})\\n\\t})\\n\\n\\tdescribe(\\\"triggerContingency\\\", () => {\\n\\t\\tit(\\\"should finish subtask when task has a parent\\\", async () => {\\n\\t\\t\\tmockTask.parentTask = { taskId: \\\"parent-task\\\" }\\n\\n\\t\\t\\tmockProvider.getState.mockResolvedValue({\\n\\t\\t\\t\\tmode: \\\"code\\\",\\n\\t\\t\\t\\tcustomModes: [],\\n\\t\\t\\t})\\n\\n\\t\\t\\tvi.mocked(getModeBySlug).mockReturnValue({\\n\\t\\t\\t\\tslug: \\\"code\\\",\\n\\t\\t\\t\\tname: \\\"Code\\\",\\n\\t\\t\\t\\troleDefinition: \\\"test\\\",\\n\\t\\t\\t\\tgroups: [],\\n\\t\\t\\t\\tcontextOverflowContingency: {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tmessage: \\\"Custom overflow message\\\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t})\\n\\n\\t\\t\\tawait handler.triggerContingency()\\n\\n\\t\\t\\texpect(mockProvider.finishSubTask).toHaveBeenCalledWith(\\\"Custom overflow message\\\")\\n\\t\\t})\\n\\n\\t\\tit(\\\"should show error message for main tasks\\\", async () => {\\n\\t\\t\\tmockProvider.getState.mockResolvedValue({\\n\\t\\t\\t\\tmode: \\\"code\\\",\\n\\t\\t\\t\\tcustomModes: [],\\n\\t\\t\\t})\\n\\n\\t\\t\\tvi.mocked(getModeBySlug).mockReturnValue({\\n\\t\\t\\t\\tslug: \\\"code\\\",\\n\\t\\t\\t\\tname: \\\"Code\\\",\\n\\t\\t\\t\\troleDefinition: \\\"test\\\",\\n\\t\\t\\t\\tgroups: [],\\n\\t\\t\\t\\tcontextOverflowContingency: {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tmessage: \\\"Custom overflow message\\\",\\n\\t\\t\\t\\t},\\n\\t\\t\\t})\\n\\n\\t\\t\\tawait handler.triggerContingency()\\n\\n\\t\\t\\texpect(mockTask.say).toHaveBeenCalledWith(\\\"error\\\", \\\"Custom overflow message\\\")\\n\\t\\t})\\n\\n\\t\\tit(\\\"should use default message when none is configured\\\", async () => {\\n\\t\\t\\tmockProvider.getState.mockResolvedValue({\\n\\t\\t\\t\\tmode: \\\"code\\\",\\n\\t\\t\\t\\tcustomModes: [],\\n\\t\\t\\t})\\n\\n\\t\\t\\tvi.mocked(getModeBySlug).mockReturnValue({\\n\\t\\t\\t\\tslug: \\\"code\\\",\\n\\t\\t\\t\\tname: \\\"Code\\\",\\n\\t\\t\\t\\troleDefinition: \\\"test\\\",\\n\\t\\t\\t\\tgroups: [],\\n\\t\\t\\t\\tcontextOverflowContingency: {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t},\\n\\t\\t\\t})\\n\\n\\t\\t\\tawait handler.triggerContingency()\\n\\n\\t\\t\\texpect(mockTask.say).toHaveBeenCalledWith(\\n\\t\\t\\t\\t\\\"error\\\",\\n\\t\\t\\t\\t\\\"Task failed because of a context overflow, possibly because webpage returned from the browser was too big\\\",\\n\\t\\t\\t)\\n\\t\\t})\\n\\t})\\n})\",\"isOutsideWorkspace\":false,\"isProtected\":false}",
  "partial": false,
  "isProtected": false
}
[2025-06-16T20:31:06.345Z] {
  "ts": 1750105866334,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[write_to_file for 'src/core/context-overflow/__tests__/ContextOverflowHandler.test.ts'] Result:\\n\\n<file_write_result>\\n<path>src/core/context-overflow/__tests__/ContextOverflowHandler.test.ts</path>\\n<operation>created</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nTool [write_to_file] was not executed because a tool has already been used in this message. Only one tool may be used per message. You must assess the first tool's result before proceeding to use the next tool.\\n\\nLoading...\"}"
}
[2025-06-16T20:31:25.128Z] {
  "ts": 1750105884873,
  "type": "say",
  "say": "text",
  "text": "Now let me create documentation for this new feature:",
  "partial": false
}
[2025-06-16T20:31:42.859Z] {
  "ts": 1750105885371,
  "type": "ask",
  "ask": "tool",
  "text": "{\"tool\":\"newFileCreated\",\"path\":\"docs/context-overflow-contingency.md\",\"content\":\"# Context Overflow Contingency\\n\\nThis feature allows modes to automatically handle context overflow situations by exiting subtasks with customizable messages when the token window is exceeded.\\n\\n## Overview\\n\\nWhen working with browser interactions or other tools that can return large amounts of content, the context window can overflow, causing the AI to get stuck. The Context Overflow Contingency feature provides a way to gracefully handle these situations by:\\n\\n1. Monitoring context token usage\\n2. Detecting when the context window is approaching its limit\\n3. Automatically exiting subtasks with a customizable message\\n4. Optionally restricting the contingency to specific tools\\n\\n## Configuration\\n\\nThe feature is configured at the mode level using the `contextOverflowContingency` property:\\n\\n```typescript\\n{\\n  slug: \\\"my-mode\\\",\\n  name: \\\"My Mode\\\",\\n  roleDefinition: \\\"...\\\",\\n  groups: [\\\"browser\\\"],\\n  contextOverflowContingency: {\\n    enabled: true,\\n    message: \\\"Task failed because of a context overflow, possibly because webpage returned from the browser was too big\\\",\\n    triggerTools: [\\\"browser_action\\\"] // Optional: only trigger for specific tools\\n  }\\n}\\n```\\n\\n### Configuration Options\\n\\n- **`enabled`** (boolean): Whether the context overflow contingency is active for this mode\\n- **`message`** (string, optional): Custom message to display when context overflow occurs. If not provided, a default message will be used\\n- **`triggerTools`** (string[], optional): Array of tool names that should trigger the contingency. If not provided, any tool can trigger it\\n\\n## How It Works\\n\\n1. **Token Monitoring**: The system continuously monitors the context token usage during task execution\\n2. **Threshold Detection**: When tokens exceed 90% of the context window minus reserved tokens, overflow is detected\\n3. **Tool Filtering**: If `triggerTools` is configured, the contingency only triggers for those specific tools\\n4. **Subtask Completion**: For subtasks, the system calls `finishSubTask()` with the configured message\\n5. **Main Task Handling**: For main tasks, an error message is displayed\\n\\n## Usage Examples\\n\\n### Browser-Focused Mode\\n\\n```typescript\\n{\\n  slug: \\\"browser-expert\\\",\\n  name: \\\"🌐 Browser Expert\\\",\\n  roleDefinition: \\\"You are an expert at browser automation and web scraping.\\\",\\n  groups: [\\\"browser\\\", \\\"read\\\"],\\n  contextOverflowContingency: {\\n    enabled: true,\\n    message: \\\"Browser task failed due to context overflow - webpage content was too large\\\",\\n    triggerTools: [\\\"browser_action\\\"]\\n  }\\n}\\n```\\n\\n### General Purpose Mode\\n\\n```typescript\\n{\\n  slug: \\\"general\\\",\\n  name: \\\"🔧 General\\\",\\n  roleDefinition: \\\"You are a general-purpose assistant.\\\",\\n  groups: [\\\"read\\\", \\\"edit\\\", \\\"browser\\\", \\\"command\\\"],\\n  contextOverflowContingency: {\\n    enabled: true,\\n    message: \\\"Task failed due to context overflow - please try with smaller content\\\"\\n  }\\n}\\n```\\n\\n## Implementation Details\\n\\n### ContextOverflowHandler Class\\n\\nThe `ContextOverflowHandler` class manages the overflow detection and contingency triggering:\\n\\n- **`recordToolUse(toolName: string)`**: Records the last tool used for filtering\\n- **`shouldTriggerContingency(contextTokens, contextWindow, maxTokens)`**: Determines if contingency should trigger\\n- **`triggerContingency()`**: Executes the contingency action\\n\\n### Integration Points\\n\\n1. **Task Class**: Each task has a `contextOverflowHandler` instance\\n2. **Token Monitoring**: Integrated into the `attemptApiRequest` method\\n3. **Tool Tracking**: Tool usage is recorded in `recordToolUsage` method\\n\\n## Benefits\\n\\n1. **Prevents Stuck Tasks**: Automatically handles situations where the AI would otherwise get stuck\\n2. **Customizable Messages**: Allows mode creators to provide context-specific error messages\\n3. **Tool-Specific Control**: Can be configured to only trigger for problematic tools\\n4. **Graceful Degradation**: Provides a clean way to exit subtasks and return control to parent tasks\\n\\n## Testing\\n\\nThe feature includes comprehensive unit tests covering:\\n\\n- Tool usage recording\\n- Contingency triggering logic\\n- Message customization\\n- Tool-specific filtering\\n- Subtask vs main task handling\\n\\nRun tests with:\\n```bash\\nnpm test src/core/context-overflow/__tests__/ContextOverflowHandler.test.ts\\n```\\n\\n## Future Enhancements\\n\\nPotential improvements could include:\\n\\n1. **Dynamic Thresholds**: Allow configurable overflow thresholds per mode\\n2. **Retry Logic**: Attempt to reduce context before triggering contingency\\n3. **Tool-Specific Messages**: Different messages for different tools\\n4. **Telemetry**: Track overflow occurrences for analysis\",\"isOutsideWorkspace\":false,\"isProtected\":false}",
  "partial": false,
  "isProtected": false
}
[2025-06-16T20:31:43.975Z] {
  "ts": 1750105903961,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[write_to_file for 'docs/context-overflow-contingency.md'] Result:\\n\\n<file_write_result>\\n<path>docs/context-overflow-contingency.md</path>\\n<operation>created</operation>\\n<notice>\\n<i>You do not need to re-read the file, as you have seen all changes</i>\\n<i>Proceed with the task using these changes as the new baseline.</i>\\n</notice>\\n</file_write_result>\\n\\n\\nTool [execute_command] was not executed because a tool has already been used in this message. Only one tool may be used per message. You must assess the first tool's result before proceeding to use the next tool.\\n\\nLoading...\"}"
}
[2025-06-16T20:31:47.405Z] {
  "ts": 1750105907123,
  "type": "say",
  "say": "text",
  "text": "Now let me create a git branch and commit the changes:",
  "partial": false
}
[2025-06-16T20:31:47.628Z] {
  "ts": 1750105907405,
  "type": "ask",
  "ask": "command",
  "text": "git checkout -b feature/context-overflow-contingency",
  "partial": false,
  "isProtected": false
}
[2025-06-16T20:31:47.761Z] {
  "ts": 1750105907747,
  "type": "ask",
  "ask": "command_output",
  "text": ""
}
[2025-06-16T20:31:47.765Z] {
  "ts": 1750105907755,
  "type": "say",
  "say": "command_output",
  "text": "Switched to a new branch 'feature/context-overflow-contingency'\n"
}
[2025-06-16T20:31:47.982Z] {
  "ts": 1750105907971,
  "type": "say",
  "say": "api_req_started",
  "text": "{\"request\":\"[execute_command for 'git checkout -b feature/context-overflow-contingency'] Result:\\n\\nCommand executed in terminal  within working directory '/roo/repos/Roo-Code'. Exit code: 0\\nOutput:\\nSwitched to a new branch 'feature/context-overflow-contingency'\\n\\n\\nLoading...\"}"
}
[2025-06-16T20:31:51.367Z] {
  "ts": 1750105911241,
  "type": "say",
  "say": "text",
  "text": "Now let me add all the changes to git and commit them:",
  "partial": false
}
[2025-06-16T20:31:51.540Z] {
  "ts": 1750105911367,
  "type": "ask",
  "ask": "command",
  "text": "git add .",
  "partial": false,
  "isProtected": false
}
