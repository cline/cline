---
title: "Conditional Rules"
description: "Activate rules automatically based on which files you're working with"
---

Conditional rules let you scope rules to specific parts of your codebase. Rules activate only when you're working with matching files, keeping your context focused and relevant.

For an introduction to Cline Rules, see the [Overview](/features/cline-rules/overview).

- **Without conditionals**: every rule loads for every request.
- **With conditionals**, rules activate only when your current files match their defined scope.

For example, React component rules should appear when you're working with React components, not when you're editing Python or documentation.

## How It Works

Conditional rules use YAML frontmatter at the top of your rule files. When Cline processes a request, it gathers context from your current work (open files, visible tabs, mentioned paths, edited files), evaluates each rule's conditions, and activates matching rules.

<Note>
When a conditional rule activates, you'll see a notification: **"Conditional rules applied: workspace:frontend-rules.md"**
</Note>

## Writing Conditional Rules

Add YAML frontmatter to the top of any rule file in your `.clinerules/` directory:

```yaml
---
paths:
  - "src/components/**"
  - "src/hooks/**"
---

# React Component Guidelines

When creating or modifying React components:
- Use functional components with React hooks
- Extract reusable logic into custom React hooks
- Keep components focused on a single responsibility
```

The `---` markers delimit the frontmatter. Everything after the closing `---` is your rule content.

### The `paths` Conditional

Currently, `paths` is the supported conditional. It takes an array of glob patterns:

```yaml
---
paths:
  - "src/**"           # All files under src/
  - "*.config.js"      # Config files in root
  - "packages/*/src/"  # Monorepo package sources
---
```

**Glob pattern syntax:**

- `*` matches any characters except `/`
- `**` matches any characters including `/` (recursive)
- `?` matches a single character
- `[abc]` matches any character in the brackets
- `{a,b}` matches either pattern

**Examples:**

| Pattern | Matches |
|---------|---------|
| `src/**/*.ts` | All TypeScript files under `src/` |
| `*.md` | Markdown files in root only |
| `**/*.test.ts` | Test files anywhere in the project |
| `packages/{web,api}/**` | Files in web or api packages |
| `src/components/*.tsx` | TSX files directly in components (not nested) |

### Behavior Details

**Multiple patterns**: A rule activates if any pattern matches any file in your context.

```yaml
---
paths:
  - "frontend/**"
  - "mobile/**"
---
# Activates when working in frontend OR mobile
```

**No frontmatter**: Rules without frontmatter are always active.

**Empty paths array**: `paths: []` means the rule never activates. Use this to temporarily disable a rule.

**Invalid YAML**: If frontmatter can't be parsed, Cline fails open: the rule activates with raw content visible to help debugging.

## What Counts as "Current Context"

Cline evaluates rules based on:

1. **Your message**: File paths mentioned in your prompt (e.g., "update `src/App.tsx`")
2. **Open tabs**: Files currently open in your editor
3. **Visible files**: Files visible in your active editor panes
4. **Recent edits**: Files modified in the current task

This ensures rules activate when they're relevant to your current work.

## Practical Examples

### Frontend vs Backend Rules

**File: `.clinerules/frontend.md`**
```yaml
---
paths:
  - "src/components/**"
  - "src/pages/**"
  - "src/hooks/**"
  - "*.tsx"
  - "*.jsx"
---

# Frontend Guidelines

- Use TypeScript for all new components
- Follow the component structure: Props interface, component function, styles
- Use CSS modules for styling
- Implement proper error boundaries
- Ensure accessibility (ARIA labels, keyboard navigation)
```

**File: `.clinerules/backend.md`**
```yaml
---
paths:
  - "src/api/**"
  - "src/services/**"
  - "src/models/**"
  - "src/controllers/**"
---

# Backend Guidelines

- Validate all input data
- Use proper error handling middleware
- Implement request logging
- Follow RESTful conventions
- Document API endpoints with OpenAPI/Swagger
```

### Test File Rules

**File: `.clinerules/testing.md`**
```yaml
---
paths:
  - "**/*.test.ts"
  - "**/*.test.tsx"
  - "**/*.spec.ts"
  - "tests/**"
  - "__tests__/**"
---

# Testing Standards

- Write descriptive test names that explain the scenario
- Follow AAA pattern: Arrange, Act, Assert
- Mock external dependencies
- Test edge cases and error conditions
- Aim for high coverage on business logic
```

### Documentation Rules

**File: `.clinerules/docs.md`**
```yaml
---
paths:
  - "docs/**"
  - "*.md"
  - "README.md"
---

# Documentation Guidelines

- Use clear, concise language
- Include code examples where appropriate
- Keep table of contents updated
- Add screenshots for UI features
- Follow the established documentation structure
```

## Combining with Rule Toggles

Conditional rules work seamlessly with the rule toggle UI. You can:

1. **Toggle conditional rules on/off**: Disable a conditional rule entirely via the UI
2. **Mix conditional and always-on rules**: Some rules always active, others conditional
3. **Override with manual toggles**: Turn off a conditional rule even when its conditions match

This gives you fine-grained control over which rules are active at any time.

## Tips for Effective Conditional Rules

### Start Broad, Then Narrow

Begin with broader patterns and refine based on experience:

```yaml
# Start with:
paths:
  - "src/**"

# Refine to:
paths:
  - "src/components/**"
  - "src/hooks/**"
```

### Use Descriptive Filenames

Name your rule files to clearly indicate their scope:

- `frontend-react.md` - React-specific frontend rules
- `backend-api.md` - API development rules
- `testing-unit.md` - Unit testing standards
- `docs-api.md` - API documentation rules

### Keep Universal Rules Separate

Rules that apply everywhere should not have conditionals:

**File: `.clinerules/00-universal.md`** (no frontmatter)
```markdown
# Universal Standards

- Write clear commit messages
- Keep functions small and focused
- Use meaningful variable names
- Comment complex logic
```

### Test Your Patterns

Verify your patterns match the intended files:

1. Open a file that should trigger the rule
2. Check the notification for "Conditional rules applied"
3. Adjust patterns if needed

## Troubleshooting

**Rule not activating?**
- Check that your glob patterns match the file paths
- Verify the YAML frontmatter is valid
- Ensure the rule file is in `.clinerules/` directory
- Check if the rule is toggled off in the UI

**Rule activating too often?**
- Make your glob patterns more specific
- Use more restrictive patterns (e.g., `src/components/*.tsx` instead of `**/*.tsx`)

**YAML parsing errors?**
- Ensure proper indentation (use spaces, not tabs)
- Quote paths that contain special characters
- Verify the `---` markers are on their own lines

## Related

- [Cline Rules Overview](/features/cline-rules/overview) - Introduction to Cline Rules
- [Slash Commands](/features/slash-commands/new-rule) - Create rules with `/newrule`
- [Memory Bank](/features/memory-bank) - Long-term context storage
