---
title: "Hooks"
sidebarTitle: "Hooks"
---

Hooks let you inject custom logic into Cline's workflow at key moments. Think of them as automated checkpoints where you can validate operations before they execute, monitor tool usage as it happens, and shape how Cline makes decisions.

Hooks run automatically when specific events happen during AI-assisted development. They receive detailed information about each operation, can block problematic actions before they cause issues, and can inject context that guides future AI decisions.

The real power comes from combining these capabilities. You can:

- Stop operations before they cause problems (like creating `.js` files in a TypeScript project)
- Learn from what's happening and build up project knowledge over time
- Monitor performance and catch issues as they emerge
- Track everything for analytics or compliance
- Trigger external tools or services at the right moments



<Warning>
Hooks are currently supported on macOS and Linux only. Windows support is not available.
</Warning>

## Getting Started

Enabling hooks in Cline is straightforward. Here's what you need to do:

<Steps>
<Step title="Enable Hooks in Settings">
Open Cline settings and check the **"Enable Hooks"** checkbox.

You can find this setting by:
1. Opening Cline
2. Click the "Settings" button on the top right corner
3. Click the "Feature" section in the left side navigation menu.
4. Scroll down until you see the "Enable Hooks" checkbox and check it. 
</Step>

<Step title="Choose Your Hook Location">
Decide where to place your hooks:

**For personal or organization-wide hooks:**
- Create hooks in `~/Documents/Cline/Rules/Hooks/`
- These apply to all workspaces automatically

**For project-specific hooks:**
- Create hooks in `.clinerules/hooks/` in your project root
- These only apply to the specific workspace
- Commit them to version control so your team can use them too
</Step>

<Step title="Create Your First Hook">
Hook files must have exact names with no file extensions. For example, to create a TaskStart hook:

```bash
# Create the hook file
vim .clinerules/hooks/TaskStart
```

Add your script (must start with shebang)
``` bash
#!/usr/bin/env bash
echo 'Hello World'
```
Make it executable
``` bash
chmod +x .clinerules/hooks/TaskStart
```
</Step>

<Step title="Test Your Hook">
Start a task in Cline and verify your hook executes.
</Step>
</Steps>

<Tip>
Start with a simple hook that just logs information before building complex validation logic. This helps you understand the data structure and timing.
</Tip>

## How Hooks Work

### Hook Types

Cline provides eight hook types that let you tap into different stages of the AI workflow. Each hook serves a distinct purpose and receives specific information about what's happening.

<Note>
The hook names in the tables below are the exact file names you need to create. For example, to use the TaskStart hook, create a file named `TaskStart` (no file extension) in your hooks directory.
</Note>

**Task Lifecycle Hooks**

Monitor and respond to task state changes from start to finish.

| Hook | When It Runs | Common Uses |
|------|--------------|-------------|
| `TaskStart` | New task begins | Initialize context, set up project rules, start tracking |
| `TaskResume` | Task resumes | Restore state, refresh context, log continuation |
| `TaskCancel` | Task cancelled | Cleanup, log cancellation reason, analytics |
| `TaskComplete` | Task finishes | Final cleanup, generate reports, completion tracking |

Intercept and enhance communication between you and Cline.

| Hook | When It Runs | Common Uses |
|------|--------------|-------------|
| `UserPromptSubmit` | User sends message | Validate input, preprocess prompts, inject context |
| `PreToolUse` | Before tool executes | Block invalid operations, validate parameters, enforce policies |
| `PostToolUse` | After tool completes | Learn from results, track patterns, monitor performance |
| `PreCompact` | Before context truncation | Monitor context usage, log compaction events, track token usage |



### JSON Communication

Hooks receive JSON via stdin and return JSON via stdout.

**Input structure:**
```json
{
  "hookName": "PreToolUse",
  "taskId": "abc123",
  "timestamp": "2024-01-15T10:30:00Z",
  "preToolUse": {
    "toolName": "write_to_file",
    "parameters": {"path": "src/index.ts"}
  }
}
```

**Output structure:**
```json
{
  "cancel": false,
  "contextModification": "WORKSPACE_RULES: Use TypeScript",
  "errorMessage": "Error details if blocking"
}
```

The `cancel` field controls whether execution continues. Set it to `true` to block an action, `false` to allow it.

The `contextModification` field injects text into the conversation. This affects future AI decisions, not the current one. Use prefixes like `WORKSPACE_RULES:` or `PERFORMANCE:` to help categorize the context.



### Hook-Specific Input Fields

Each hook type receives different input data. See the full JSON structures:

<CodeGroup>
```json TaskStart
{
  "taskStart": {
    "taskMetadata": {
      "taskId": "string",
      "ulid": "string", 
      "initialTask": "string"
    }
  }
}
```

```json TaskResume
{
  "taskResume": {
    "taskMetadata": {"taskId": "string", "ulid": "string"},
    "previousState": {
      "lastMessageTs": "string",
      "messageCount": "string",
      "conversationHistoryDeleted": "string"
    }
  }
}
```

```json UserPromptSubmit
{
  "userPromptSubmit": {
    "prompt": "string",
    "attachments": ["string"]
  }
}
```

```json PreToolUse
{
  "preToolUse": {
    "toolName": "string",
    "parameters": {}
  }
}
```

```json PostToolUse
{
  "postToolUse": {
    "toolName": "string",
    "parameters": {},
    "result": "string",
    "success": boolean,
    "executionTimeMs": number
  }
}
```

```json PreCompact
{
  "preCompact": {
    "contextSize": number,
    "messagesToCompact": number,
    "compactionStrategy": "string"
  }
}
```
</CodeGroup>

All hooks also receive base fields: `clineVersion`, `hookName`, `timestamp`, `taskId`, `workspaceRoots`, `userId`.


### Execution Details

When multiple hooks exist (global + workspace), they all run concurrently. If any hook blocks an action (`cancel: true`), the action doesn't happen. Context from all hooks gets combined.

Hooks have 30 seconds to complete (configurable via `HOOK_EXECUTION_TIMEOUT_MS`). Context modifications are limited to 50KB (configurable via `MAX_CONTEXT_MODIFICATION_SIZE`).


### Understanding Context Timing

Context injection affects future decisions, not current ones. When a hook runs:

1. The AI has already decided what to do
2. The hook can block or allow it
3. Any context gets added to the conversation
4. The next AI request sees that context

This means PreToolUse hooks are for blocking bad actions, while PostToolUse hooks are for learning from completed ones.

## Real Examples

Here are practical hooks solving real problems.

### Block JavaScript in TypeScript Projects

Sometimes the simplest hook is the most valuable. This one prevents a common mistake:

```bash PreToolUse
#!/usr/bin/env bash

input=$(cat)
tool=$(echo "$input" | jq -r '.preToolUse.toolName')
path=$(echo "$input" | jq -r '.preToolUse.parameters.path // ""')

if [[ "$tool" == "write_to_file" && "$path" == *.js ]]; then
  echo '{"cancel": true, "errorMessage": "Use .ts files in this TypeScript project"}'
  exit 0
fi

echo '{"cancel": false}'
```

This runs before every file operation. If Cline tries to create a `.js` file, the hook blocks it and explains why. Simple, fast, and prevents issues before they happen.

### Learn Naming Patterns

This hook observes file creation and builds context over time:

```bash PostToolUse
#!/usr/bin/env bash

input=$(cat)
tool=$(echo "$input" | jq -r '.postToolUse.toolName')
path=$(echo "$input" | jq -r '.postToolUse.parameters.path // ""')
success=$(echo "$input" | jq -r '.postToolUse.success')

if [[ "$tool" == "write_to_file" && "$success" == "true" && -n "$path" ]]; then
  filename=$(basename "$path")
  
  if [[ "$filename" =~ ^[a-z]+(-[a-z]+)*\. ]]; then
    pattern="kebab-case"
  elif [[ "$filename" =~ ^[a-z]+([A-Z][a-z]+)*\. ]]; then
    pattern="camelCase"
  else
    pattern="mixed"
  fi
  
  echo "{\"cancel\": false, \"contextModification\": \"FILE_OPERATIONS: Created '$filename' using $pattern naming\"}"
  exit 0
fi

echo '{"cancel": false}'
```

After each file gets created, this hook detects the naming convention and adds it to the conversation. Over time, Cline learns your project's patterns without you having to explain them.

### Watch Performance

Track how long operations take and flag slow ones:

```bash PostToolUse
#!/usr/bin/env bash

input=$(cat)
tool=$(echo "$input" | jq -r '.postToolUse.toolName')
duration=$(echo "$input" | jq -r '.postToolUse.executionTimeMs')

if (( $(echo "$duration > 5000" | bc -l) )); then
  echo "{\"cancel\": false, \"contextModification\": \"PERFORMANCE: '$tool' took ${duration}ms - consider optimizing\"}"
  exit 0
fi

echo '{"cancel": false}'
```

When something takes over 5 seconds, Cline gets a note about it. This builds awareness about performance patterns without manual monitoring.

### Initialize Tasks with Context

Set up the environment at the start of each task:

```bash TaskStart
#!/usr/bin/env bash

context=""

[[ -f "package.json" ]] && context+="Node.js project. "
[[ -f "tsconfig.json" ]] && context+="TypeScript enabled. "
[[ -d ".git" ]] && context+="Git branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null). "

echo "{\"cancel\": false, \"contextModification\": \"WORKSPACE_RULES: $context\"}"
```

This runs once when a task starts, detecting the project type and current branch automatically. Cline knows the environment before making any decisions.

## What You Could Build

Once you understand the basics, hooks open up creative possibilities:

**Intelligent Code Review**
Run linters or custom validators before files get saved. Block commits that don't pass checks. Track code quality metrics over time.

**Security Enforcement**
Prevent operations that violate security policies. Detect when sensitive data might be exposed. Audit all file access for compliance.

**Custom Workflows**
Trigger CI/CD pipelines when specific files change. Send notifications to team channels. Update external documentation automatically.

**Project Knowledge Base**
Track architectural decisions as they're made. Build a map of dependencies and relationships. Create automatic change logs from tool usage.

**Development Analytics**
Measure how long different operations take. Identify patterns in how the AI works. Generate productivity reports from hook data.

**Integration Hub**
Connect to issue trackers when certain keywords appear. Update project management tools. Sync with external APIs at the right moments.

The key is combining hooks with external tools. A hook can be the glue between Cline's workflow and the rest of your development ecosystem.

## Troubleshooting

### Hook Not Running
- Ensure the "Enable Hooks" setting is checked
- Verify the hook file is executable (`chmod +x hookname`)
- Check the hook file has no syntax errors
- Look for errors in VSCode's Output panel (Cline channel)

### Hook Timing Out
- Reduce complexity of the hook script
- Avoid expensive operations (network calls, heavy computations)
- Consider moving complex logic to a background process

### Context Not Affecting Behavior
- Remember: context affects FUTURE decisions, not the current tool
- Use PreToolUse for validation (blocking) if you need immediate effect
- Ensure context modifications are clear and actionable
- Check that context isn't being truncated (50KB limit)

## Security Considerations

- Hooks run with the same permissions as VSCode
- Be cautious with hooks from untrusted sources
- Review hook scripts before enabling them
- Consider using `.gitignore` to avoid committing sensitive hook logic
- Hooks can access all workspace files and environment variables

## Advanced Topics

### Security Considerations

Hooks run with the same permissions as VS Code. They can access all workspace files and environment variables. Review hooks from untrusted sources before enabling them.

Consider using `.gitignore` to keep sensitive hook logic private while committing the general structure.

## Related Features

Hooks complement other Cline features:

- [Cline Rules](/features/cline-rules) define high-level guidance that hooks can enforce
- [Checkpoints](/features/checkpoints) let you roll back changes if a hook didn't catch an issue
- [Auto-Approve](/features/auto-approve) works well with hooks as safety nets for automated operations
