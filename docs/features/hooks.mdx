---
title: "Hooks"
sidebarTitle: "Hooks"
description: "Inject custom logic into Cline's workflow to validate operations, monitor tool usage, and shape AI decisions"
---

Hooks let you inject custom logic into Cline's workflow at key moments. Think of them as automated checkpoints where you can validate operations before they execute, monitor tool usage as it happens, and shape how Cline makes decisions.

Hooks run automatically when specific events happen during development. They receive detailed information about each operation, can block problematic actions before they cause issues, and can inject context that guides future AI decisions.

The real power comes from combining these capabilities. You can:

- Stop operations before they cause problems (like creating `.js` files in a TypeScript project)
- Learn from what's happening and build up project knowledge over time
- Monitor performance and catch issues as they emerge
- Track everything for analytics or compliance
- Trigger external tools or services at the right moments

<Warning>
Hooks are currently supported on macOS and Linux only. Windows support is not available.
</Warning>

## Getting Started

<Frame>
	<img src="https://storage.googleapis.com/cline_public_images/hooks.gif" alt="Hooks in action" />
</Frame>

Enabling hooks in Cline is straightforward. Here's what you need to do:

<Steps>
<Step title="Enable Hooks in Settings">
Open Cline settings and check the **"Enable Hooks"** checkbox.

You can find this setting by:
1. Opening Cline
2. Click the "Settings" button on the top right corner
3. Click the "Feature" section in the left side navigation menu.
4. Scroll down until you see the "Enable Hooks" checkbox and check it. 
</Step>

<Step title="Choose Your Hook Location">
Decide where to place your hooks:

**For personal or organization-wide hooks:**
- Create hooks in `~/Documents/Cline/Rules/Hooks/`
- These apply to all workspaces automatically

**For project-specific hooks:**
- Create hooks in `.clinerules/hooks/` in your project root
- These only apply to the specific workspace
- Commit them to version control so your team can use them too
</Step>

<Step title="Create Your First Hook">
Hook files must have exact names with no file extensions. For example, to create a TaskStart hook:

```bash
# Create the hook file
vim .clinerules/hooks/TaskStart
```

Add your script (must start with shebang)
``` bash
#!/usr/bin/env bash
echo 'Hello World'
```

#### Make it executable

```bash
chmod +x .clinerules/hooks/TaskStart
```
</Step>

<Step title="Test Your Hook">
Start a task in Cline and verify your hook executes.
</Step>
</Steps>

<Tip>
Start with a simple hook that just logs information before building complex validation logic. This helps you understand the data structure and timing.
</Tip>

## Hook Types

Cline provides eight hook types that let you tap into different stages of the AI workflow. They're organized into two categories: **Task Lifecycle Hooks** (monitor task state changes) and **Communication Hooks** (intercept and enhance interactions).

<Note>
The hook names below are the exact file names you need to create. For example, to use the TaskStart hook, create a file named `TaskStart` (no file extension) in your hooks directory.
</Note>

Each hook receives base fields in addition to its specific data: `clineVersion`, `hookName`, `timestamp`, `taskId`, `workspaceRoots`, `userId`.

### Task Lifecycle Hooks

These hooks monitor and respond to task state changes from start to finish.

#### TaskStart

Runs when a new task begins. Use it to detect project type, initialize tracking, and inject initial context that shapes how Cline approaches the work.

**Input Fields:**
```json
{
  "taskStart": {
    "taskMetadata": {
      "taskId": "string",
      "ulid": "string", 
      "initialTask": "string"
    }
  }
}
```

#### TaskResume

Runs when a task resumes after interruption. Use it to restore state, refresh context, and log resumption for analytics or external system notifications.

**Input Fields:**
```json
{
  "taskResume": {
    "taskMetadata": {"taskId": "string", "ulid": "string"},
    "previousState": {
      "lastMessageTs": "string",
      "messageCount": "string",
      "conversationHistoryDeleted": "string"
    }
  }
}
```

#### TaskCancel

Runs when a task is cancelled. Use it to cleanup resources, log cancellation details, and notify external systems about interrupted work.

**Input Fields:**
```json
{
  "taskCancel": {
    "taskMetadata": {"taskId": "string", "ulid": "string"},
    "reason": "string"
  }
}
```

#### TaskComplete

Runs when a task finishes successfully. Use it for final cleanup, tracking metrics, generating reports, and triggering post-task workflows.

**Input Fields:**
```json
{
  "taskComplete": {
    "taskMetadata": {"taskId": "string", "ulid": "string"},
    "completionDetails": {
      "totalMessages": "string",
      "executionTimeMs": "string"
    }
  }
}
```

### Communication Hooks

These hooks intercept and enhance communication between you and Cline.

#### UserPromptSubmit

Runs when a user sends a message to Cline. Use it to validate input, inject context based on the prompt, and track interaction patterns.

**Input Fields:**
```json
{
  "userPromptSubmit": {
    "prompt": "string",
    "attachments": ["string"]
  }
}
```

#### PreToolUse

Runs before any tool executes. Use it to block invalid operations, validate parameters, and enforce project policies before changes happen.

**Input Fields:**
```json
{
  "preToolUse": {
    "toolName": "string",
    "parameters": {}
  }
}
```

#### PostToolUse

Runs after a tool completes. Use it to learn from results, track performance metrics, and build project knowledge based on operations performed.

**Input Fields:**
```json
{
  "postToolUse": {
    "toolName": "string",
    "parameters": {},
    "result": "string",
    "success": boolean,
    "executionTimeMs": number
  }
}
```

#### PreCompact

Runs before conversation context is truncated to fit token limits. Use it to monitor compaction frequency, log events, and track context usage patterns.

**Input Fields:**
```json
{
  "preCompact": {
    "contextSize": number,
    "messagesToCompact": number,
    "compactionStrategy": "string"
  }
}
```



### JSON Communication

Hooks receive JSON via stdin and return JSON via stdout.

**Input structure:**
```json
{
  "hookName": "PreToolUse",
  "taskId": "abc123",
  "timestamp": "2024-01-15T10:30:00Z",
  "preToolUse": {
    "toolName": "write_to_file",
    "parameters": {"path": "src/index.ts"}
  }
}
```

**Output structure:**
```json
{
  "cancel": false,
  "contextModification": "WORKSPACE_RULES: Use TypeScript",
  "errorMessage": "Error details if blocking"
}
```

The `cancel` field controls whether execution continues. Set it to `true` to block an action, `false` to allow it.

The `contextModification` field injects text into the conversation. This affects future AI decisions, not the current one. Use prefixes like `WORKSPACE_RULES:` or `PERFORMANCE:` to help categorize the context.




### Execution Details

When multiple hooks exist (global + workspace), they all run concurrently. If any hook blocks an action (`cancel: true`), the action doesn't happen. Context from all hooks gets combined.

Hooks have 30 seconds to complete (configurable via `HOOK_EXECUTION_TIMEOUT_MS`). Context modifications are limited to 50KB (configurable via `MAX_CONTEXT_MODIFICATION_SIZE`).


### Understanding Context Timing

Context injection affects future decisions, not current ones. When a hook runs:

1. The AI has already decided what to do
2. The hook can block or allow it
3. Any context gets added to the conversation
4. The next AI request sees that context

This means PreToolUse hooks are for blocking bad actions, while PostToolUse hooks are for learning from completed ones.


## What You Can Build

Once you understand the basics, hooks open up creative possibilities:

- **Intelligent Code Review**:
Run linters or custom validators before files get saved. Block commits that don't pass checks. Track code quality metrics over time.

- **Security Enforcement**:
Prevent operations that violate security policies. Detect when sensitive data might be exposed. Audit all file access for compliance.

- **Development Analytics**: Measure how long different operations take. Identify patterns in how the AI works. Generate productivity reports from hook data.

- **Integration Hub**: Connect to issue trackers when certain keywords appear. Update project management tools. Sync with external APIs at the right moments.

The key is combining hooks with external tools. A hook can be the glue between Cline's workflow and the rest of your development ecosystem.

## Troubleshooting

### Hook Not Running
- Ensure the "Enable Hooks" setting is checked
- Verify the hook file is executable (`chmod +x hookname`)
- Check the hook file has no syntax errors
- Look for errors in VSCode's Output panel (Cline channel)

### Hook Timing Out
- Reduce complexity of the hook script
- Avoid expensive operations (network calls, heavy computations)
- Consider moving complex logic to a background process

### Context Not Affecting Behavior
- Remember: context affects FUTURE decisions, not the current tool
- Use PreToolUse for validation (blocking) if you need immediate effect
- Ensure context modifications are clear and actionable
- Check that context isn't being truncated (50KB limit)

<Warning>
Hooks run with the same permissions as VS Code. They can access all workspace files and environment variables. Review hooks from untrusted sources before enabling them.
</Warning>

## Related Features

Hooks complement other Cline features:

- [Cline Rules](/features/cline-rules) define high-level guidance that hooks can enforce
- [Checkpoints](/features/checkpoints) let you roll back changes if a hook didn't catch an issue
- [Auto-Approve](/features/auto-approve) works well with hooks as safety nets for automated operations
