---
title: "Control Other Cline Features"
sidebarTitle: "Control Features"
description: "Enable or disable specific Cline features across your organization with granular permission controls"
---

Enterprise Feature Controls provide granular management over Cline's capabilities across your organization. Control which features are available to different teams, users, and use cases while maintaining security and compliance requirements.

## Feature Control Benefits

<CardGroup cols={2}>
  <Card title="Granular Permissions" icon="sliders">
    Control access to individual features based on user roles, teams, and project requirements.
  </Card>
  
  <Card title="Security Enforcement" icon="shield-lock">
    Disable potentially risky features in production environments or for specific user groups.
  </Card>
  
  <Card title="Compliance Management" icon="clipboard-check">
    Ensure regulatory compliance by controlling AI capabilities and data access patterns.
  </Card>
  
  <Card title="Cost Optimization" icon="dollar-sign">
    Manage resource usage by controlling access to expensive or resource-intensive features.
  </Card>
</CardGroup>

## Feature Categories

### Core AI Features

Control fundamental AI capabilities and model access:

```yaml
# core-ai-features.yaml
feature_controls:
  ai_capabilities:
    chat_interface:
      enabled: true
      restrictions:
        - role: "intern"
          daily_limit: 50
        - role: "contractor"
          requires_approval: true
          
    code_generation:
      enabled: true
      restrictions:
        - file_patterns: ["*.config.js", "*.env*"]
          action: "block"
          message: "AI code generation blocked for configuration files"
        - languages: ["sql", "bash"]
          requires_review: true
          
    model_selection:
      enabled: true
      available_models:
        - role: "developer"
          models: ["claude-3-haiku", "gpt-3.5-turbo"]
        - role: "senior-developer"
          models: ["claude-3-sonnet", "gpt-4-turbo"]
        - role: "architect"
          models: ["*"]  # All models available
          
    context_switching:
      enabled: true
      max_context_size:
        - role: "developer"
          size: "32k"
        - role: "senior-developer"  
          size: "128k"
```

### Development Tools

Control access to development and debugging tools:

```yaml
# development-tools.yaml
feature_controls:
  development_tools:
    file_explorer:
      enabled: true
      restrictions:
        - paths: ["/etc/*", "~/.ssh/*", "*.pem", "*.key"]
          action: "block"
        - file_size: "> 10MB"
          action: "warn"
          
    terminal_access:
      enabled: false  # Disabled by default for security
      allowed_roles: ["admin", "devops"]
      restrictions:
        - commands: ["rm", "sudo", "curl"]
          action: "require_approval"
        - environment: "production"
          action: "block"
          
    browser_automation:
      enabled: true
      restrictions:
        - domains: ["*.internal.company.com"]
          action: "allow"
        - domains: ["*"]
          action: "require_approval"
          
    git_operations:
      enabled: true
      restrictions:
        - actions: ["push", "force-push"]
          branches: ["main", "master", "production"]
          requires_review: true
        - repositories: ["company/secrets", "company/infrastructure"]
          action: "block"
```

### Advanced Features

Control access to advanced Cline capabilities:

```yaml
# advanced-features.yaml
feature_controls:
  advanced_features:
    workflows:
      enabled: true
      restrictions:
        - role: "developer"
          actions: ["view", "run"]
        - role: "tech-lead"
          actions: ["view", "run", "create", "edit"]
        - role: "admin"
          actions: ["*"]
          
    hooks:
      enabled: true
      restrictions:
        - role: "developer"
          hook_types: ["PreToolUse", "PostToolUse"]
        - role: "security-lead"
          hook_types: ["*"]
        - paths: ["/.clinerules/hooks/security/*"]
          requires_approval: true
          
    checkpoints:
      enabled: true
      max_checkpoints:
        - role: "developer"
          limit: 10
        - role: "senior-developer"
          limit: 25
        - storage_limit: "1GB"
          
    mcp_servers:
      enabled: true
      restrictions:
        - role: "developer"
          servers: ["github", "jira", "slack"]
        - role: "admin"  
          servers: ["*"]
        - custom_servers: 
            requires_approval: true
            approvers: ["security-team"]
```

### Integration Controls

Manage external service integrations:

```yaml
# integration-controls.yaml
feature_controls:
  integrations:
    api_access:
      external_apis:
        enabled: true
        restrictions:
          - domains: ["api.github.com", "api.slack.com"]
            action: "allow"
          - domains: ["*"]
            requires_approval: true
            approvers: ["security-team"]
            
    data_export:
      enabled: true
      restrictions:
        - data_types: ["code", "logs"]
          action: "allow"
        - data_types: ["credentials", "secrets"]
          action: "block"
        - file_size: "> 100MB"
          requires_approval: true
          
    cloud_services:
      aws_integration:
        enabled: true
        allowed_services: ["bedrock", "s3", "lambda"]
        regions: ["us-east-1", "us-west-2"]
        
      gcp_integration:  
        enabled: true
        allowed_services: ["vertex-ai", "cloud-storage"]
        regions: ["us-central1", "us-east1"]
```

## Role-Based Feature Matrix

Define feature access based on organizational roles:

```yaml
# role-based-matrix.yaml
role_definitions:
  intern:
    features:
      chat_interface: "limited"      # 50 requests/day
      code_generation: "supervised"  # Requires review
      file_explorer: "restricted"    # No system files
      terminal_access: false
      browser_automation: false
      workflows: "view-only"
      hooks: false
      mcp_servers: "curated"        # Pre-approved only
      
  developer:
    features:
      chat_interface: true
      code_generation: true
      file_explorer: "standard"
      terminal_access: false
      browser_automation: "limited"  # Internal domains only
      workflows: "run-only" 
      hooks: "basic"                # PreToolUse/PostToolUse
      mcp_servers: "standard"       # Common integrations
      
  senior_developer:
    features:
      chat_interface: true
      code_generation: true
      file_explorer: "extended"
      terminal_access: "limited"     # Safe commands only
      browser_automation: true
      workflows: "create-edit"
      hooks: "advanced"
      mcp_servers: "extended"
      
  tech_lead:
    features:
      chat_interface: true
      code_generation: true
      file_explorer: true
      terminal_access: "extended"
      browser_automation: true
      workflows: true
      hooks: true
      mcp_servers: true
      feature_controls: "team"       # Can control team features
      
  admin:
    features:
      "*": true                     # All features enabled
      feature_controls: "organization"  # Can control all features
```

## Environment-Specific Controls

Apply different feature controls based on environment:

```yaml
# environment-controls.yaml
environments:
  development:
    feature_overrides:
      terminal_access: true          # Allow in dev
      external_api_access: true     # Allow external APIs
      workflow_execution: true      # Allow workflow testing
      
  staging:
    feature_overrides:
      terminal_access: "limited"    # Restricted commands
      external_api_access: "staging-only"  # Staging endpoints
      production_deployments: false
      
  production:
    feature_overrides:
      terminal_access: false        # Blocked in prod
      code_generation: "reviewed"   # Requires review
      workflow_execution: "approved-only"
      debug_features: false
      experimental_features: false
```

## Project-Specific Controls

Control features based on project sensitivity:

```yaml
# project-controls.yaml
project_classifications:
  public:
    features:
      external_api_access: true
      data_export: true
      code_sharing: true
      
  internal:
    features:
      external_api_access: "approved-domains"
      data_export: "limited"
      code_sharing: "internal-only"
      
  confidential:
    features:
      external_api_access: false
      data_export: false
      code_sharing: false
      audit_all_actions: true
      
  restricted:
    features:
      ai_assistance: "supervised"   # Human oversight required
      external_api_access: false
      data_export: false
      terminal_access: false
      comprehensive_logging: true
```

## Feature Control Implementation

### Configuration Deployment

Deploy feature controls through infrastructure as code:

```yaml
# terraform/feature-controls.tf
resource "cline_feature_controls" "enterprise" {
  name = "enterprise-feature-controls"
  
  # Core AI controls
  ai_capabilities = {
    chat_interface = {
      enabled = true
      rate_limits = {
        developer = 100
        intern = 50
      }
    }
    
    code_generation = {
      enabled = true
      blocked_patterns = [
        "*.env*",
        "*.key",
        "*.pem",
        "**/secrets/**"
      ]
    }
  }
  
  # Development tool controls
  development_tools = {
    terminal_access = {
      enabled = false
      allowed_roles = ["admin", "devops"]
    }
    
    file_explorer = {
      enabled = true
      blocked_paths = [
        "/etc/*",
        "~/.ssh/*",
        "**/node_modules/**"
      ]
    }
  }
  
  # Role-based permissions
  role_permissions = {
    developer = ["chat", "code_gen", "file_explorer"]
    senior_dev = ["chat", "code_gen", "file_explorer", "browser", "workflows"]
    admin = ["*"]
  }
}
```

### GitOps Integration

Manage feature controls through version control:

```yaml
# .github/workflows/deploy-feature-controls.yml
name: Deploy Feature Controls
on:
  push:
    branches: [main]
    paths: ['feature-controls/**']
    
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Validate Configuration
        run: |
          cline-enterprise features validate feature-controls/
          
      - name: Deploy to Staging
        run: |
          cline-enterprise features deploy feature-controls/ \
            --environment staging \
            --dry-run
            
      - name: Deploy to Production
        if: github.ref == 'refs/heads/main'
        run: |
          cline-enterprise features deploy feature-controls/ \
            --environment production
```

### Dynamic Feature Flags

Implement dynamic feature controls:

```typescript
// feature-flag-service.ts
export class FeatureFlagService {
  async isFeatureEnabled(
    featureName: string, 
    user: User, 
    context: FeatureContext
  ): Promise<boolean> {
    // Check role-based permissions
    if (!this.hasRolePermission(user.role, featureName)) {
      return false;
    }
    
    // Check environment restrictions
    if (!this.isEnvironmentAllowed(featureName, context.environment)) {
      return false;
    }
    
    // Check project sensitivity
    if (!this.isProjectAllowed(featureName, context.project)) {
      return false;
    }
    
    // Check dynamic conditions
    const dynamicRules = await this.getDynamicRules(featureName);
    return this.evaluateRules(dynamicRules, user, context);
  }
  
  async requiresApproval(
    featureName: string,
    user: User,
    context: FeatureContext
  ): Promise<ApprovalRequirement | null> {
    const rules = await this.getApprovalRules(featureName);
    
    for (const rule of rules) {
      if (this.matchesConditions(rule.conditions, user, context)) {
        return {
          approvers: rule.approvers,
          timeout: rule.timeout,
          justificationRequired: rule.requiresJustification
        };
      }
    }
    
    return null;
  }
}
```

## Real-Time Feature Management

### Feature Control Dashboard

Monitor and manage features in real-time:

```typescript
// feature-dashboard.tsx
export function FeatureDashboard() {
  const [features, setFeatures] = useState<FeatureStatus[]>([]);
  const [users, setUsers] = useState<UserActivity[]>([]);
  
  return (
    <Dashboard>
      <MetricsGrid>
        <Metric title="Features Enabled" value={features.filter(f => f.enabled).length} />
        <Metric title="Approval Requests" value={pendingApprovals.length} />
        <Metric title="Feature Usage" value={dailyUsage.total} />
        <Metric title="Blocked Attempts" value={blockedAttempts.today} />
      </MetricsGrid>
      
      <FeatureTogglePanel>
        {features.map(feature => (
          <FeatureToggle
            key={feature.name}
            feature={feature}
            onChange={updateFeature}
            disabled={!canModifyFeature(feature)}
          />
        ))}
      </FeatureTogglePanel>
      
      <UserActivityTable users={users} />
      <ApprovalQueue requests={pendingApprovals} />
    </Dashboard>
  );
}
```

### Emergency Controls

Implement emergency feature disabling:

```yaml
# emergency-controls.yaml
emergency_procedures:
  security_incident:
    actions:
      - disable_all_external_api_access
      - enable_comprehensive_logging
      - require_approval_for_all_actions
      - notify_security_team
      
  compliance_audit:
    actions:
      - enable_detailed_audit_logging
      - disable_data_export_features
      - require_justification_for_ai_requests
      - snapshot_all_configurations
      
  resource_exhaustion:
    actions:
      - reduce_rate_limits
      - disable_expensive_features
      - prioritize_admin_access
      - enable_resource_monitoring

triggers:
  - name: "security-alert"
    webhook_url: "${SECURITY_WEBHOOK}"
    procedure: "security_incident"
    
  - name: "compliance-mode"
    manual_trigger: true
    requires_approval: ["legal-team"]
    procedure: "compliance_audit"
```

## Monitoring & Analytics

### Feature Usage Analytics

Track feature adoption and usage patterns:

```yaml
# feature-analytics.yaml
metrics:
  - name: "feature_usage_total"
    type: "counter"
    labels: ["feature_name", "user_role", "environment"]
    
  - name: "feature_blocked_attempts"
    type: "counter"
    labels: ["feature_name", "block_reason", "user_role"]
    
  - name: "approval_queue_size"
    type: "gauge"
    labels: ["feature_name", "approval_type"]
    
  - name: "feature_performance_impact"
    type: "histogram"
    labels: ["feature_name", "operation_type"]

dashboards:
  - name: "Feature Adoption"
    panels:
      - title: "Top Used Features"
        query: "topk(10, sum(rate(feature_usage_total[24h])) by (feature_name))"
      
      - title: "Feature Blocks by Reason"
        query: "sum(feature_blocked_attempts) by (block_reason)"
        
      - title: "Approval Queue Trends"
        query: "avg_over_time(approval_queue_size[7d])"
```

### Audit Reporting

Generate comprehensive audit reports:

```typescript
// audit-reporter.ts
export class FeatureAuditReporter {
  async generateAccessReport(period: DateRange) {
    return {
      summary: {
        totalUsers: await this.getTotalUsers(),
        featuresUsed: await this.getFeaturesUsed(period),
        blockedAttempts: await this.getBlockedAttempts(period),
        approvalRequests: await this.getApprovalRequests(period)
      },
      
      userActivity: await this.getUserActivity(period),
      featureUsage: await this.getFeatureUsage(period),
      securityEvents: await this.getSecurityEvents(period),
      complianceViolations: await this.getComplianceViolations(period)
    };
  }
  
  async generateComplianceReport(framework: 'soc2' | 'hipaa' | 'gdpr') {
    const controls = await this.getComplianceControls(framework);
    const evidence = await this.collectEvidence(controls);
    
    return {
      framework,
      controlsAssessed: controls.length,
      controlsCompliant: evidence.filter(e => e.compliant).length,
      findings: evidence.filter(e => !e.compliant),
      recommendations: await this.generateRecommendations(evidence)
    };
  }
}
```

## Integration with External Systems

### LDAP/Active Directory Integration

Sync feature permissions with enterprise directory:

```yaml
# ldap-integration.yaml
ldap:
  server: "ldaps://ad.company.com:636"
  bind_dn: "CN=cline-service,OU=Service Accounts,DC=company,DC=com"
  bind_password: "${LDAP_PASSWORD}"
  
  user_search:
    base_dn: "OU=Users,DC=company,DC=com"
    filter: "(&(objectClass=user)(memberOf=CN=Cline Users,OU=Groups,DC=company,DC=com))"
    
  group_mapping:
    "CN=Cline Admins,OU=Groups,DC=company,DC=com": "admin"
    "CN=Senior Developers,OU=Groups,DC=company,DC=com": "senior_developer"
    "CN=Developers,OU=Groups,DC=company,DC=com": "developer"
    "CN=Interns,OU=Groups,DC=company,DC=com": "intern"
    
  sync_schedule: "0 */4 * * *"  # Every 4 hours
```

### SAML/SSO Integration

Integrate with enterprise SSO for feature permissions:

```yaml
# saml-integration.yaml
saml:
  idp_metadata_url: "https://sso.company.com/metadata"
  entity_id: "cline-enterprise"
  assertion_consumer_service: "https://cline.company.com/saml/acs"
  
  attribute_mapping:
    role: "http://schemas.company.com/identity/claims/role"
    team: "http://schemas.company.com/identity/claims/team"
    department: "http://schemas.company.com/identity/claims/department"
    
  feature_mapping:
    - saml_role: "Enterprise_Admin"
      cline_features: ["*"]
    - saml_role: "Senior_Developer" 
      cline_features: ["advanced"]
    - saml_role: "Developer"
      cline_features: ["standard"]
```

## Best Practices

### Security-First Approach
1. **Default Deny**: Start with minimal permissions and add as needed
2. **Regular Reviews**: Periodically audit feature permissions and usage
3. **Least Privilege**: Grant only the minimum features required for each role
4. **Separation of Duties**: Require multiple approvers for sensitive features
5. **Audit Everything**: Log all feature access attempts and decisions

### User Experience
1. **Clear Communication**: Inform users when features are disabled and why
2. **Graceful Degradation**: Provide alternatives when features are unavailable
3. **Self-Service**: Allow users to request feature access through automated workflows
4. **Documentation**: Maintain up-to-date documentation of available features
5. **Training**: Educate users on approved features and best practices

### Operational Excellence
1. **Automated Testing**: Test feature controls in staging before production
2. **Rollback Capabilities**: Maintain ability to quickly revert feature changes
3. **Performance Monitoring**: Track performance impact of feature controls
4. **Emergency Procedures**: Have plans for emergency feature disabling
5. **Change Management**: Use formal processes for feature control changes

## Troubleshooting

### Common Issues

**Features Not Applying**:
```bash
# Check feature control status
cline-enterprise features status --user alice@company.com

# Validate configuration
cline-enterprise features validate --config feature-controls.yaml

# Sync user permissions
cline-enterprise features sync-permissions --user alice@company.com
```

**Performance Impact**:
```bash
# Monitor feature control overhead
cline-enterprise features metrics --timeframe 1h

# Optimize slow rules
cline-enterprise features optimize --rule complex-permission-rule

# Check cache status
cline-enterprise features cache-status
```

**Approval Workflow Issues**:
```bash
# Check approval queue
cline-enterprise approvals list --status pending

# Escalate stuck approvals
cline-enterprise approvals escalate --request req-12345

# Update approval rules
cline-enterprise features update-approval-rules --dry-run
```

Enterprise Feature Controls provide comprehensive governance over Cline's capabilities while maintaining flexibility for legitimate use cases. Start with basic role-based controls and gradually implement more sophisticated policies as your organization's needs evolve.
